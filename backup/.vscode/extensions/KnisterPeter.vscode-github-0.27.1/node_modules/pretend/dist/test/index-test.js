"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ava_1 = require("ava");
require("isomorphic-fetch");
var nock = require("nock");
var src_1 = require("../src");
var TestImpl = /** @class */ (function () {
    function TestImpl() {
    }
    TestImpl.prototype.getSimple = function () { };
    TestImpl.prototype.get = function (_id) { };
    TestImpl.prototype.getWithQuery = function (_id, _parameters) { };
    TestImpl.prototype.getWithHeader = function () { };
    TestImpl.prototype.post = function (_body) { };
    TestImpl.prototype.postWithQueryAndBody = function () { };
    TestImpl.prototype.put = function () { };
    TestImpl.prototype.putWithQuery = function (_parameters) { };
    TestImpl.prototype.delete = function (_id) { };
    TestImpl.prototype.deleteBody = function (_id, _body) { };
    TestImpl.prototype.patchBody = function (_id, _body) { };
    __decorate([
        src_1.Get('/path', true)
    ], TestImpl.prototype, "getSimple", null);
    __decorate([
        src_1.Get('/path/{id}')
    ], TestImpl.prototype, "get", null);
    __decorate([
        src_1.Get('/path/{id}', true)
    ], TestImpl.prototype, "getWithQuery", null);
    __decorate([
        src_1.Headers('Accept: accept'),
        src_1.Get('/with/header')
    ], TestImpl.prototype, "getWithHeader", null);
    __decorate([
        src_1.Post('/path')
    ], TestImpl.prototype, "post", null);
    __decorate([
        src_1.Post('/path', true)
    ], TestImpl.prototype, "postWithQueryAndBody", null);
    __decorate([
        src_1.Put('/path')
    ], TestImpl.prototype, "put", null);
    __decorate([
        src_1.Put('/path', true)
    ], TestImpl.prototype, "putWithQuery", null);
    __decorate([
        src_1.Delete('/path/:id')
    ], TestImpl.prototype, "delete", null);
    __decorate([
        src_1.Delete('/path/:id', true)
    ], TestImpl.prototype, "deleteBody", null);
    __decorate([
        src_1.Patch('/path/:id')
    ], TestImpl.prototype, "patchBody", null);
    return TestImpl;
}());
var mockResponse = {
    key: 'value'
};
function setup() {
    return src_1.Pretend.builder().target(TestImpl, 'http://host:port/');
}
ava_1.default('Pretend should call a get method without any parameter or query', function (t) {
    var test = setup();
    nock('http://host:port/').get('/path').reply(200, mockResponse);
    return test.getSimple()
        .then(function (response) {
        t.deepEqual(response, mockResponse);
    });
});
ava_1.default('Pretend should call a get method', function (t) {
    var test = setup();
    nock('http://host:port/').get('/path/id').reply(200, mockResponse);
    return test.get('id')
        .then(function (response) {
        t.deepEqual(response, mockResponse);
    });
});
ava_1.default('Pretend should call a get method with query parameters', function (t) {
    var test = setup();
    nock('http://host:port/').get('/path/id?a=b&c=d').reply(200, mockResponse);
    return test.getWithQuery('id', { a: 'b', c: 'd' })
        .then(function (response) {
        t.deepEqual(response, mockResponse);
    });
});
ava_1.default('Pretend should call a get method and add a custom header', function (t) {
    var test = setup();
    nock('http://host:port/', {
        reqheaders: {
            accept: 'accept'
        }
    }).get('/with/header').reply(200, mockResponse);
    return test.getWithHeader()
        .then(function (response) {
        t.deepEqual(response, mockResponse);
    });
});
ava_1.default('Pretend should throw on wrong custom header format', function (t) {
    /* tslint:disable */
    var Api = /** @class */ (function () {
        function Api() {
        }
        Api.prototype.get = function () { return undefined; };
        ;
        __decorate([
            src_1.Headers('syntactically-wrong'),
            src_1.Get('/path')
        ], Api.prototype, "get", null);
        return Api;
    }());
    /* tslint:enable */
    var test = src_1.Pretend.builder()
        .target(Api, 'http://host:port/');
    return test.get()
        .then(function () {
        t.fail('should throw');
    })
        .catch(function () {
        t.pass();
    });
});
ava_1.default('Pretend should call a post method', function (t) {
    var test = setup();
    nock('http://host:port/').post('/path', { mockResponse: mockResponse }).reply(200, mockResponse);
    return test.post({ mockResponse: mockResponse })
        .then(function (response) {
        t.deepEqual(response, mockResponse);
    });
});
ava_1.default('Pretend should call a post method with query and body', function (t) {
    var test = setup();
    nock('http://host:port/').post('/path?query=param', { mockResponse: mockResponse }).reply(200, mockResponse);
    return test.postWithQueryAndBody({ query: 'param' }, { mockResponse: mockResponse })
        .then(function (response) {
        t.deepEqual(response, mockResponse);
    });
});
ava_1.default('Pretend should call a put method', function (t) {
    var test = src_1.Pretend.builder().target(TestImpl, 'http://host:port');
    nock('http://host:port/').put('/path').reply(200, mockResponse);
    return test.put()
        .then(function (response) {
        t.deepEqual(response, mockResponse);
    });
});
ava_1.default('Pretend should call a put method with query parameters', function (t) {
    var test = setup();
    nock('http://host:port/').put('/path?query=param').reply(200, mockResponse);
    return test.putWithQuery({ query: 'param' })
        .then(function (response) {
        t.deepEqual(response, mockResponse);
    });
});
ava_1.default('Pretend should call a delete method', function (t) {
    var test = setup();
    nock('http://host:port/').delete('/path/id').reply(200, mockResponse);
    return test.delete('id')
        .then(function (response) {
        t.deepEqual(response, mockResponse);
    });
});
ava_1.default('Pretend should throw on error', function (t) {
    var test = setup();
    nock('http://host:port/').delete('/path/id').replyWithError('server-fail');
    return test.delete('id')
        .then(function () {
        t.fail('should throw');
    })
        .catch(function () {
        t.pass();
    });
});
ava_1.default('Pretend should call a delete method and send a body', function (t) {
    var test = setup();
    nock('http://host:port/').delete('/path/id', { data: 'data' }).reply(200, mockResponse);
    return test.deleteBody('id', { data: 'data' })
        .then(function (response) {
        t.deepEqual(response, mockResponse);
    });
});
ava_1.default('Pretend should call a patch method and send a body', function (t) {
    var test = setup();
    nock('http://host:port/').patch('/path/id', { data: 'data' }).reply(200, mockResponse);
    return test.patchBody('id', { data: 'data' })
        .then(function (response) {
        t.deepEqual(response, mockResponse);
    });
});
ava_1.default('Pretend should return content based on decoder configuration', function (t) {
    /* tslint:disable */
    var Api = /** @class */ (function () {
        function Api() {
        }
        Api.prototype.get = function () { return undefined; };
        ;
        __decorate([
            src_1.Get('/path')
        ], Api.prototype, "get", null);
        return Api;
    }());
    /* tslint:enable */
    nock('http://host:port/').get('/path').reply(200, 'some-string');
    var decoderCalled = false;
    var api = src_1.Pretend.builder()
        .decode(function (res) {
        decoderCalled = true;
        return res.text();
    })
        .target(Api, 'http://host:port/');
    return api.get()
        .then(function (text) {
        t.true(decoderCalled, 'The decoder should be called');
        t.is(text, 'some-string');
    });
});
ava_1.default('Pretend should use basic auth if configured', function (t) {
    /* tslint:disable */
    var Api = /** @class */ (function () {
        function Api() {
        }
        Api.prototype.get = function () { return undefined; };
        ;
        __decorate([
            src_1.Get('/')
        ], Api.prototype, "get", null);
        return Api;
    }());
    /* tslint:enable */
    nock('http://host:port/', {
        reqheaders: {
            Authorization: 'Basic QWxhZGRpbjpPcGVuU2VzYW1l'
        }
    })
        .get('/')
        .reply(200, '{}');
    var api = src_1.Pretend.builder()
        .basicAuthentication('Aladdin', 'OpenSesame')
        .target(Api, 'http://host:port');
    return api.get()
        .then(function (response) {
        t.deepEqual(response, {});
    });
});
ava_1.default('Pretend should return from the interceptor', function (t) {
    nock('http://host:port/')
        .get('/path/id').reply(200, mockResponse)
        .get('/path/id').reply(500, {});
    var firstReponse = undefined;
    var test = src_1.Pretend.builder()
        .interceptor(function (chain, request) {
        if (!firstReponse) {
            firstReponse = chain(request);
        }
        return firstReponse;
    })
        .target(TestImpl, 'http://host:port/');
    // first call gets through
    return test.get('id')
        .then(function () { return test.get('id'); })
        .then(function (response) {
        // second should be return from the interceptor (nock would fail)
        t.deepEqual(response, mockResponse);
    });
});
ava_1.default('Pretend should reset per-request data after each request', function (t) {
    var test = setup();
    nock('http://host:port/').get('/with/header').reply(200, mockResponse);
    return test.getWithHeader()
        .then(function () {
        t.is(test.__Pretend__.perRequest, undefined);
    });
});
ava_1.default('Pretend should reset per-request data after error requests', function (t) {
    var test = setup();
    nock('http://host:port/').get('/with/header').replyWithError('failed');
    return test.getWithHeader()
        .catch(function () {
        t.is(test.__Pretend__.perRequest, undefined);
    });
});
//# sourceMappingURL=index-test.js.map