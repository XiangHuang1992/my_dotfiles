var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { assert } from 'chai';
import 'source-map-support/register';
import { TSDI, Component, component, Inject, inject, Factory, factory, External, external, Initialize, initialize, destroy } from '../lib/tsdi';
import { Cyclic1 } from './cyclic1';
import { Dependency } from './dependency';
import { EagerComponent1 } from './eager1';
import { EagerComponent2 } from './eager2';
import { User } from './user';
describe('TSDI', function () {
    describe('when creating a container instance', function () {
        var tsdi;
        beforeEach(function () {
            tsdi = new TSDI();
        });
        afterEach(function () {
            tsdi.close();
        });
        it('a returned component should be of the requested instance', function () {
            tsdi.register(User);
            tsdi.register(Dependency);
            var user = tsdi.get(User);
            assert.isTrue(user instanceof User);
        });
        it('a returned instance should have all dependencies satisfied', function () {
            tsdi.register(User);
            tsdi.register(Dependency);
            var user = tsdi.get(User);
            assert.equal(user.method(), 'hello');
        });
        it('two returned instances should have the same dependency instances', function () {
            tsdi.register(User);
            tsdi.register(Dependency);
            var user1 = tsdi.get(User);
            var user2 = tsdi.get(User);
            assert.equal(user1.getDep(), user2.getDep());
        });
        it('a returned instance should call decorated lifecycle methods when available', function () {
            tsdi.register(User);
            tsdi.register(Dependency);
            var user = tsdi.get(User);
            assert.equal(user.initResult(), 'init');
        });
        it('enabling componentScanner should add all known components to the container', function () {
            tsdi.enableComponentScanner();
            var user = tsdi.get(User);
            assert.isTrue(user instanceof User);
        });
        it('a container with enabled componentScanner should lazy register components', function () {
            tsdi.enableComponentScanner();
            var Late = /** @class */ (function () {
                function Late() {
                }
                Late = __decorate([
                    component()
                ], Late);
                return Late;
            }());
            var late = tsdi.get(Late);
            assert.isTrue(late instanceof Late);
        });
        it('components could registered by name', function () {
            var A = /** @class */ (function () {
                function A() {
                }
                return A;
            }());
            var B = /** @class */ (function (_super) {
                __extends(B, _super);
                function B() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                B = __decorate([
                    Component()
                ], B);
                return B;
            }(A));
            tsdi.register(A);
            tsdi.register(B, 'Foo');
            assert.equal(tsdi.get(A, 'Foo'), tsdi.get(B));
        });
        it('components could registered with metadata', function () {
            var A = /** @class */ (function () {
                function A() {
                }
                return A;
            }());
            var B = /** @class */ (function (_super) {
                __extends(B, _super);
                function B() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                B = __decorate([
                    Component({ name: 'RegisteredWithMetadata' })
                ], B);
                return B;
            }(A));
            tsdi.register(A);
            tsdi.register(B);
            assert.equal(tsdi.get(A, 'RegisteredWithMetadata'), tsdi.get(B));
        });
        it('components could be queried by name', function () {
            tsdi.enableComponentScanner();
            var A = /** @class */ (function () {
                function A() {
                }
                A.prototype.m = function () { return 'a'; };
                A = __decorate([
                    Component()
                ], A);
                return A;
            }());
            // @ts-ignore
            var BExtendsA = /** @class */ (function (_super) {
                __extends(BExtendsA, _super);
                function BExtendsA() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                BExtendsA.prototype.m = function () { return 'b'; };
                BExtendsA = __decorate([
                    Component()
                ], BExtendsA);
                return BExtendsA;
            }(A));
            // @ts-ignore
            var CExtendsA = /** @class */ (function (_super) {
                __extends(CExtendsA, _super);
                function CExtendsA() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                CExtendsA.prototype.m = function () { return 'c'; };
                CExtendsA = __decorate([
                    Component({ name: 'Foo' })
                ], CExtendsA);
                return CExtendsA;
            }(A));
            // @ts-ignore
            var DExtendsA = /** @class */ (function (_super) {
                __extends(DExtendsA, _super);
                function DExtendsA() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                DExtendsA.prototype.m = function () {
                    return this.a.m();
                };
                __decorate([
                    inject({ name: 'Foo' }),
                    __metadata("design:type", A)
                ], DExtendsA.prototype, "a", void 0);
                DExtendsA = __decorate([
                    Component({ name: 'Bar' })
                ], DExtendsA);
                return DExtendsA;
            }(A));
            assert.equal(tsdi.get(A, 'Bar').m(), 'c');
        });
        it('should warn if register component with duplicate name', function (done) {
            var A = /** @class */ (function () {
                function A() {
                }
                return A;
            }());
            var B = /** @class */ (function () {
                function B() {
                }
                return B;
            }());
            var consoleWarn = console.warn;
            try {
                console.warn = function (msg) {
                    assert.equal(msg, "Component with name 'DuplicateComponentName' already registered.");
                    done();
                };
                tsdi.register(A, 'DuplicateComponentName');
                tsdi.register(B, 'DuplicateComponentName');
            }
            finally {
                console.warn = consoleWarn;
            }
        });
        it('should inject defined properties', function () {
            var ComponentWithProperties = /** @class */ (function () {
                function ComponentWithProperties() {
                }
                Object.defineProperty(ComponentWithProperties.prototype, "prop", {
                    get: function () { return this._prop; },
                    enumerable: true,
                    configurable: true
                });
                __decorate([
                    Inject({ name: 'prop' }),
                    __metadata("design:type", Boolean)
                ], ComponentWithProperties.prototype, "_prop", void 0);
                ComponentWithProperties = __decorate([
                    Component()
                ], ComponentWithProperties);
                return ComponentWithProperties;
            }());
            tsdi.addProperty('prop', false);
            tsdi.register(ComponentWithProperties);
            assert.equal(tsdi.get(ComponentWithProperties).prop, false);
        });
        it('should throw if requried component was not found', function () {
            var NonRegisteredComponent = /** @class */ (function () {
                function NonRegisteredComponent() {
                }
                NonRegisteredComponent = __decorate([
                    Component()
                ], NonRegisteredComponent);
                return NonRegisteredComponent;
            }());
            try {
                tsdi.get(NonRegisteredComponent);
                assert.fail('Should throw');
            }
            catch (e) {
                assert.equal(e.message, "Component 'NonRegisteredComponent' not found");
            }
        });
        it('should add itself to the component list', function () {
            tsdi.enableComponentScanner();
            var ComponentWithContainerDependency = /** @class */ (function () {
                function ComponentWithContainerDependency() {
                }
                Object.defineProperty(ComponentWithContainerDependency.prototype, "prop", {
                    get: function () { return this._tsdi; },
                    enumerable: true,
                    configurable: true
                });
                __decorate([
                    Inject,
                    __metadata("design:type", TSDI)
                ], ComponentWithContainerDependency.prototype, "_tsdi", void 0);
                ComponentWithContainerDependency = __decorate([
                    Component()
                ], ComponentWithContainerDependency);
                return ComponentWithContainerDependency;
            }());
            assert.strictEqual(tsdi.get(ComponentWithContainerDependency).prop, tsdi);
        });
        it('should call the initalizer', function () {
            tsdi.enableComponentScanner();
            var called = false;
            var ComponentWithInitializer = /** @class */ (function () {
                function ComponentWithInitializer() {
                }
                ComponentWithInitializer.prototype.init = function () {
                    called = true;
                };
                __decorate([
                    Initialize,
                    __metadata("design:type", Function),
                    __metadata("design:paramtypes", []),
                    __metadata("design:returntype", void 0)
                ], ComponentWithInitializer.prototype, "init", null);
                ComponentWithInitializer = __decorate([
                    Component()
                ], ComponentWithInitializer);
                return ComponentWithInitializer;
            }());
            tsdi.get(ComponentWithInitializer);
            assert.isTrue(called);
        });
        it('should inject annotated constructor parameters', function () {
            tsdi.enableComponentScanner();
            var ConstructorParameterComponent = /** @class */ (function () {
                function ConstructorParameterComponent() {
                }
                ConstructorParameterComponent = __decorate([
                    Component
                ], ConstructorParameterComponent);
                return ConstructorParameterComponent;
            }());
            var ComponentWithConstructor = /** @class */ (function () {
                function ComponentWithConstructor(container, b) {
                    this._tsdi = container;
                    this.b = b;
                }
                Object.defineProperty(ComponentWithConstructor.prototype, "prop", {
                    get: function () { return this._tsdi; },
                    enumerable: true,
                    configurable: true
                });
                ComponentWithConstructor = __decorate([
                    Component,
                    __param(0, Inject()), __param(1, Inject),
                    __metadata("design:paramtypes", [TSDI, ConstructorParameterComponent])
                ], ComponentWithConstructor);
                return ComponentWithConstructor;
            }());
            assert.strictEqual(tsdi.get(ComponentWithConstructor).prop, tsdi);
            assert.instanceOf(tsdi.get(ComponentWithConstructor).b, ConstructorParameterComponent);
        });
        it('should create a new instance for non-singletons', function () {
            tsdi.enableComponentScanner();
            var NonSingletonComponent = /** @class */ (function () {
                function NonSingletonComponent() {
                }
                NonSingletonComponent = __decorate([
                    Component({ singleton: false })
                ], NonSingletonComponent);
                return NonSingletonComponent;
            }());
            assert.notEqual(tsdi.get(NonSingletonComponent), tsdi.get(NonSingletonComponent));
        });
        it('should register factories on components', function () {
            tsdi.enableComponentScanner();
            var NonSingletonObject = /** @class */ (function () {
                function NonSingletonObject() {
                }
                return NonSingletonObject;
            }());
            // @ts-ignore
            var FactoryComponentWithSingletonFactory = /** @class */ (function () {
                // @ts-ignore
                function FactoryComponentWithSingletonFactory() {
                }
                FactoryComponentWithSingletonFactory.prototype.someFactory = function () {
                    return new NonSingletonObject();
                };
                __decorate([
                    factory,
                    __metadata("design:type", Function),
                    __metadata("design:paramtypes", []),
                    __metadata("design:returntype", NonSingletonObject)
                ], FactoryComponentWithSingletonFactory.prototype, "someFactory", null);
                FactoryComponentWithSingletonFactory = __decorate([
                    Component()
                    // @ts-ignore
                ], FactoryComponentWithSingletonFactory);
                return FactoryComponentWithSingletonFactory;
            }());
            // @Component()
            // class C {}
            assert.instanceOf(tsdi.get(NonSingletonObject), NonSingletonObject);
            assert.strictEqual(tsdi.get(NonSingletonObject), tsdi.get(NonSingletonObject));
        });
        it('should return a new component on each call for non singleton factories', function () {
            tsdi.enableComponentScanner();
            var NonSingletonObject = /** @class */ (function () {
                function NonSingletonObject() {
                }
                return NonSingletonObject;
            }());
            // @ts-ignore
            var FactoryComponentWithNonSingletonFactory = /** @class */ (function () {
                // @ts-ignore
                function FactoryComponentWithNonSingletonFactory() {
                }
                FactoryComponentWithNonSingletonFactory.prototype.someFactory = function () {
                    return new NonSingletonObject();
                };
                __decorate([
                    Factory({ singleton: false }),
                    __metadata("design:type", Function),
                    __metadata("design:paramtypes", []),
                    __metadata("design:returntype", NonSingletonObject)
                ], FactoryComponentWithNonSingletonFactory.prototype, "someFactory", null);
                FactoryComponentWithNonSingletonFactory = __decorate([
                    Component()
                    // @ts-ignore
                ], FactoryComponentWithNonSingletonFactory);
                return FactoryComponentWithNonSingletonFactory;
            }());
            assert.instanceOf(tsdi.get(NonSingletonObject), NonSingletonObject);
            assert.notEqual(tsdi.get(NonSingletonObject), tsdi.get(NonSingletonObject));
        });
        it('inject should fallback to typename if no explicit name given', function () {
            tsdi.enableComponentScanner();
            var InjectedComponent = /** @class */ (function () {
                function InjectedComponent() {
                }
                InjectedComponent = __decorate([
                    Component()
                ], InjectedComponent);
                return InjectedComponent;
            }());
            var ComponentWithNonNamedInject = /** @class */ (function () {
                function ComponentWithNonNamedInject() {
                }
                Object.defineProperty(ComponentWithNonNamedInject.prototype, "comp", {
                    get: function () {
                        return this._comp;
                    },
                    enumerable: true,
                    configurable: true
                });
                __decorate([
                    Inject(),
                    __metadata("design:type", InjectedComponent)
                ], ComponentWithNonNamedInject.prototype, "_comp", void 0);
                ComponentWithNonNamedInject = __decorate([
                    Component()
                ], ComponentWithNonNamedInject);
                return ComponentWithNonNamedInject;
            }());
            assert.strictEqual(tsdi.get(ComponentWithNonNamedInject).comp, tsdi.get(InjectedComponent));
        });
        it('should report an error if named injection could not resolve to a component', function () {
            tsdi.enableComponentScanner();
            var UnknownComponent = /** @class */ (function () {
                function UnknownComponent() {
                }
                UnknownComponent = __decorate([
                    Component()
                ], UnknownComponent);
                return UnknownComponent;
            }());
            var ComponentWithNamedInject = /** @class */ (function () {
                function ComponentWithNamedInject() {
                }
                Object.defineProperty(ComponentWithNamedInject.prototype, "comp", {
                    get: function () {
                        return this._comp;
                    },
                    enumerable: true,
                    configurable: true
                });
                __decorate([
                    Inject('unknown'),
                    __metadata("design:type", UnknownComponent)
                ], ComponentWithNamedInject.prototype, "_comp", void 0);
                ComponentWithNamedInject = __decorate([
                    Component()
                ], ComponentWithNamedInject);
                return ComponentWithNamedInject;
            }());
            assert.throws(function () { return tsdi.get(ComponentWithNamedInject).comp; }, "Component named 'unknown' not found");
        });
        it('should report an error for a probable cyclic dependency', function () {
            tsdi.enableComponentScanner();
            assert.throws(function () { return tsdi.get(Cyclic1); }, /Probably a cyclic dependency/);
        });
        it('should get a component by hint/name only', function () {
            tsdi.enableComponentScanner();
            var NamedComponent = /** @class */ (function () {
                function NamedComponent() {
                }
                NamedComponent = __decorate([
                    Component('Component')
                ], NamedComponent);
                return NamedComponent;
            }());
            assert.instanceOf(tsdi.get('Component'), NamedComponent);
        });
        it('should report an error duplicate named component', function () {
            tsdi.enableComponentScanner();
            try {
                // @ts-ignore
                var NamedComponent1 = /** @class */ (function () {
                    function NamedComponent1() {
                    }
                    NamedComponent1 = __decorate([
                        Component('Component')
                    ], NamedComponent1);
                    return NamedComponent1;
                }());
                // @ts-ignore
                var NamedComponent2 = /** @class */ (function () {
                    function NamedComponent2() {
                    }
                    NamedComponent2 = __decorate([
                        Component('Component')
                    ], NamedComponent2);
                    return NamedComponent2;
                }());
                assert.fail('Should throw error');
            }
            catch (e) {
                assert.match(e.message, /Duplicate name 'Component' for known Components/);
            }
        });
        it('should lazy create an inject dependencies', function () {
            tsdi.enableComponentScanner();
            var Injected = /** @class */ (function () {
                function Injected() {
                }
                Injected = __decorate([
                    Component()
                ], Injected);
                return Injected;
            }());
            var ComponentWithLazyInjection = /** @class */ (function () {
                function ComponentWithLazyInjection() {
                }
                __decorate([
                    Inject({ lazy: true }),
                    __metadata("design:type", Injected)
                ], ComponentWithLazyInjection.prototype, "dependency", void 0);
                ComponentWithLazyInjection = __decorate([
                    Component()
                ], ComponentWithLazyInjection);
                return ComponentWithLazyInjection;
            }());
            var component = tsdi.get(ComponentWithLazyInjection);
            var instances = tsdi.instances;
            var injected = Object
                .keys(instances)
                .map(function (key) { return instances[key]; })
                .filter(function (instance) { return instance instanceof Injected; });
            assert.lengthOf(injected, 0);
            assert.isDefined(component.dependency);
        });
        it('should create eager components as soon as possible', function (done) {
            tsdi.enableComponentScanner();
            var count = 0;
            // @ts-ignore
            var EagerComponent = /** @class */ (function () {
                function EagerComponent() {
                }
                EagerComponent.prototype.init = function () {
                    count++;
                };
                __decorate([
                    initialize,
                    __metadata("design:type", Function),
                    __metadata("design:paramtypes", []),
                    __metadata("design:returntype", void 0)
                ], EagerComponent.prototype, "init", null);
                EagerComponent = __decorate([
                    component({ eager: true })
                ], EagerComponent);
                return EagerComponent;
            }());
            setTimeout(function () {
                assert.equal(count, 1);
                done();
            }, 1);
        });
        it('should respect dependency tree for eager creation', function (done) {
            tsdi.enableComponentScanner();
            var eager1 = tsdi.get(EagerComponent1);
            var eager2 = tsdi.get(EagerComponent2);
            setTimeout(function () {
                assert.strictEqual(eager1.dependency, eager2);
                done();
            }, 1);
        });
        it('should call lifecycle listener on component creation', function () {
            tsdi.enableComponentScanner();
            var count = 0;
            var Component = /** @class */ (function () {
                function Component() {
                }
                Component = __decorate([
                    component
                ], Component);
                return Component;
            }());
            tsdi.addLifecycleListener({
                onCreate: function (component) {
                    if (component instanceof Component) {
                        count++;
                    }
                }
            });
            tsdi.get(Component);
            assert.equal(count, 1);
        });
        it('should call lifecycle listener on component destruction', function () {
            tsdi.enableComponentScanner();
            var count = 0;
            var Component = /** @class */ (function () {
                function Component() {
                }
                Component = __decorate([
                    component
                ], Component);
                return Component;
            }());
            tsdi.addLifecycleListener({
                onDestroy: function (component) {
                    if (component instanceof Component) {
                        count++;
                    }
                }
            });
            tsdi.get(Component);
            tsdi.close();
            assert.equal(count, 1);
        });
        it('should allow overriding a dependency', function () {
            tsdi.enableComponentScanner();
            var Component = /** @class */ (function () {
                function Component() {
                }
                Component.prototype.foo = function () {
                    return 'foo';
                };
                Component = __decorate([
                    component
                ], Component);
                return Component;
            }());
            var ComponentOverride = /** @class */ (function () {
                function ComponentOverride() {
                }
                ComponentOverride.prototype.foo = function () {
                    return 'foo-override';
                };
                return ComponentOverride;
            }());
            tsdi.override(Component, new ComponentOverride());
            assert.equal(tsdi.get(Component).foo(), 'foo-override');
        });
        it('should call destructor on container close', function () {
            var calledDestructor = false;
            var ComponentWithDestructor = /** @class */ (function () {
                function ComponentWithDestructor() {
                }
                ComponentWithDestructor.prototype.foo = function () {
                    calledDestructor = true;
                };
                __decorate([
                    destroy,
                    __metadata("design:type", Function),
                    __metadata("design:paramtypes", []),
                    __metadata("design:returntype", void 0)
                ], ComponentWithDestructor.prototype, "foo", null);
                ComponentWithDestructor = __decorate([
                    component
                ], ComponentWithDestructor);
                return ComponentWithDestructor;
            }());
            tsdi.enableComponentScanner();
            tsdi.get(ComponentWithDestructor);
            tsdi.close();
            assert.isTrue(calledDestructor);
        });
        it('should not fail if destructor is removed', function () {
            var destructorCalled = false;
            var ComponentWithDestructor = /** @class */ (function () {
                function ComponentWithDestructor() {
                }
                ComponentWithDestructor.prototype.foo = function () {
                    destructorCalled = true;
                };
                __decorate([
                    destroy,
                    __metadata("design:type", Function),
                    __metadata("design:paramtypes", []),
                    __metadata("design:returntype", void 0)
                ], ComponentWithDestructor.prototype, "foo", null);
                ComponentWithDestructor = __decorate([
                    component
                ], ComponentWithDestructor);
                return ComponentWithDestructor;
            }());
            tsdi.enableComponentScanner();
            tsdi.override(ComponentWithDestructor, {});
            tsdi.get(ComponentWithDestructor);
            tsdi.close();
            assert.isFalse(destructorCalled);
        });
        it('should re-resolve dependency if injected as dynamic  one', function () {
            var Dependency = /** @class */ (function () {
                function Dependency() {
                    this.value = 1;
                }
                Dependency = __decorate([
                    component({ scope: 're-resolve' })
                ], Dependency);
                return Dependency;
            }());
            var Dependent = /** @class */ (function () {
                function Dependent() {
                }
                __decorate([
                    inject({ dynamic: true }),
                    __metadata("design:type", Dependency)
                ], Dependent.prototype, "dependency", void 0);
                __decorate([
                    inject({ lazy: false, dynamic: true }),
                    __metadata("design:type", Dependency)
                ], Dependent.prototype, "eagerDependency", void 0);
                Dependent = __decorate([
                    component
                ], Dependent);
                return Dependent;
            }());
            tsdi.enableComponentScanner();
            tsdi.getScope('re-resolve').enter();
            var dependent = tsdi.get(Dependent);
            var dependency1 = dependent.dependency;
            var eagerDependency1 = dependent.eagerDependency;
            tsdi.getScope('re-resolve').leave();
            tsdi.getScope('re-resolve').enter();
            var dependency2 = dependent.dependency;
            var eagerDependency2 = dependent.eagerDependency;
            assert.notEqual(dependency1, dependency2);
            assert.notEqual(eagerDependency1, eagerDependency2);
        });
        it('should throw if use unavailable dependency injected as dynamic one', function () {
            var Dependency = /** @class */ (function () {
                function Dependency() {
                    this.value = 1;
                }
                Dependency = __decorate([
                    component({ scope: 'scope' })
                ], Dependency);
                return Dependency;
            }());
            var Dependent = /** @class */ (function () {
                function Dependent() {
                }
                __decorate([
                    inject({ dynamic: true }),
                    __metadata("design:type", Dependency)
                ], Dependent.prototype, "dependency", void 0);
                Dependent = __decorate([
                    component
                ], Dependent);
                return Dependent;
            }());
            tsdi.enableComponentScanner();
            var dependent = tsdi.get(Dependent);
            assert.throws(function () { return dependent.dependency.value; }, "Component 'Dependency' not found: required scope 'scope' is not enabled");
        });
        describe('with external classes', function () {
            it('should inject dependencies', function () {
                tsdi.enableComponentScanner();
                var User2 = /** @class */ (function (_super) {
                    __extends(User2, _super);
                    function User2() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    User2 = __decorate([
                        Component('user2')
                    ], User2);
                    return User2;
                }(User));
                var ExternalClass = /** @class */ (function () {
                    function ExternalClass() {
                    }
                    __decorate([
                        Inject(),
                        __metadata("design:type", User)
                    ], ExternalClass.prototype, "user", void 0);
                    __decorate([
                        Inject('user2'),
                        __metadata("design:type", User)
                    ], ExternalClass.prototype, "user2", void 0);
                    ExternalClass = __decorate([
                        external
                    ], ExternalClass);
                    return ExternalClass;
                }());
                var test = new ExternalClass();
                assert.strictEqual(test.user, tsdi.get(User));
                assert.strictEqual(test.user2, tsdi.get(User2));
            });
            it('should call the initializer', function () {
                tsdi.enableComponentScanner();
                var called = false;
                var fn = function () { return called = true; };
                var ExternalClass = /** @class */ (function () {
                    function ExternalClass() {
                    }
                    ExternalClass.prototype.init = function () {
                        fn();
                    };
                    __decorate([
                        initialize(),
                        __metadata("design:type", Function),
                        __metadata("design:paramtypes", []),
                        __metadata("design:returntype", void 0)
                    ], ExternalClass.prototype, "init", null);
                    ExternalClass = __decorate([
                        External()
                    ], ExternalClass);
                    return ExternalClass;
                }());
                // tslint:disable-next-line:no-unused-expression
                new ExternalClass();
                assert.isTrue(called);
            });
            it('should inject defined properties', function () {
                tsdi.enableComponentScanner();
                var ExternalClass = /** @class */ (function () {
                    function ExternalClass() {
                    }
                    Object.defineProperty(ExternalClass.prototype, "prop", {
                        get: function () { return this._prop; },
                        enumerable: true,
                        configurable: true
                    });
                    __decorate([
                        Inject('prop'),
                        __metadata("design:type", Boolean)
                    ], ExternalClass.prototype, "_prop", void 0);
                    ExternalClass = __decorate([
                        External()
                    ], ExternalClass);
                    return ExternalClass;
                }());
                tsdi.addProperty('prop', false);
                assert.equal(new ExternalClass().prop, false);
            });
            it('should allow constructor injection', function () {
                tsdi.enableComponentScanner();
                var ExternalClass = /** @class */ (function () {
                    function ExternalClass(_value, user) {
                        this.injected = user;
                    }
                    ExternalClass = __decorate([
                        External(),
                        __param(1, Inject()),
                        __metadata("design:paramtypes", [String, User])
                    ], ExternalClass);
                    return ExternalClass;
                }());
                assert.equal(new ExternalClass('value').injected, tsdi.get(User));
            });
            it('should keep static methods and properties', function () {
                tsdi.enableComponentScanner();
                var noop = function () { return console.log('noop'); };
                var ExternalClass = /** @class */ (function () {
                    function ExternalClass() {
                    }
                    ExternalClass.user = 'test';
                    ExternalClass.noop = noop;
                    ExternalClass = __decorate([
                        External()
                    ], ExternalClass);
                    return ExternalClass;
                }());
                assert.strictEqual(ExternalClass.user, 'test');
                assert.strictEqual(ExternalClass.noop, noop);
            });
            it('should keep prototype chain correct', function () {
                tsdi.enableComponentScanner();
                var Base = /** @class */ (function () {
                    function Base() {
                    }
                    return Base;
                }());
                var ExternalClass = /** @class */ (function (_super) {
                    __extends(ExternalClass, _super);
                    function ExternalClass() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    ExternalClass = __decorate([
                        External()
                    ], ExternalClass);
                    return ExternalClass;
                }(Base));
                assert.instanceOf(new ExternalClass(), Base);
            });
        });
        describe('and scope', function () {
            it('should create components for that scopes', function () {
                tsdi.enableComponentScanner();
                var ComponentWithScope = /** @class */ (function () {
                    function ComponentWithScope() {
                    }
                    ComponentWithScope = __decorate([
                        component({ scope: 'scope' })
                    ], ComponentWithScope);
                    return ComponentWithScope;
                }());
                tsdi.getScope('scope').enter();
                var instance = tsdi.get(ComponentWithScope);
                assert.isDefined(instance);
            });
            it('should throw if scope is not enabled', function () {
                tsdi.enableComponentScanner();
                var ComponentWithScope = /** @class */ (function () {
                    function ComponentWithScope() {
                    }
                    ComponentWithScope = __decorate([
                        component({ scope: 'scope' })
                    ], ComponentWithScope);
                    return ComponentWithScope;
                }());
                assert.throws(function () { return tsdi.get(ComponentWithScope); }, "Component 'ComponentWithScope' not found: required scope 'scope' is not enabled");
            });
            it('should destroy instances when their scope was left', function () {
                tsdi.enableComponentScanner();
                var destructorCalled = false;
                var ComponentWithScope = /** @class */ (function () {
                    function ComponentWithScope() {
                    }
                    ComponentWithScope.prototype.destroy = function () {
                        destructorCalled = true;
                    };
                    __decorate([
                        destroy,
                        __metadata("design:type", Function),
                        __metadata("design:paramtypes", []),
                        __metadata("design:returntype", void 0)
                    ], ComponentWithScope.prototype, "destroy", null);
                    ComponentWithScope = __decorate([
                        component({ scope: 'scope' })
                    ], ComponentWithScope);
                    return ComponentWithScope;
                }());
                tsdi.getScope('scope').enter();
                tsdi.get(ComponentWithScope);
                tsdi.getScope('scope').leave();
                assert.isTrue(destructorCalled);
            });
            it('should keep instances which are out of left scope', function () {
                tsdi.enableComponentScanner();
                var destructorCalled = false;
                var ComponentWithoutScope = /** @class */ (function () {
                    function ComponentWithoutScope() {
                    }
                    ComponentWithoutScope.prototype.destroy = function () {
                        destructorCalled = true;
                    };
                    __decorate([
                        destroy,
                        __metadata("design:type", Function),
                        __metadata("design:paramtypes", []),
                        __metadata("design:returntype", void 0)
                    ], ComponentWithoutScope.prototype, "destroy", null);
                    ComponentWithoutScope = __decorate([
                        component
                    ], ComponentWithoutScope);
                    return ComponentWithoutScope;
                }());
                var ComponentWithOtherScope = /** @class */ (function () {
                    function ComponentWithOtherScope() {
                    }
                    ComponentWithOtherScope.prototype.destroy = function () {
                        destructorCalled = true;
                    };
                    __decorate([
                        destroy,
                        __metadata("design:type", Function),
                        __metadata("design:paramtypes", []),
                        __metadata("design:returntype", void 0)
                    ], ComponentWithOtherScope.prototype, "destroy", null);
                    ComponentWithOtherScope = __decorate([
                        component({ scope: 'other' })
                    ], ComponentWithOtherScope);
                    return ComponentWithOtherScope;
                }());
                tsdi.getScope('other').enter();
                tsdi.getScope('scope').enter();
                tsdi.get(ComponentWithoutScope);
                tsdi.get(ComponentWithOtherScope);
                tsdi.getScope('scope').leave();
                assert.isFalse(destructorCalled);
            });
            it('should warn user if statically injecting scoped component into unscoped component', function (done) {
                tsdi.enableComponentScanner();
                // @ts-ignore
                var ComponentToBeInjected = /** @class */ (function () {
                    function ComponentToBeInjected() {
                    }
                    ComponentToBeInjected = __decorate([
                        component({ scope: 'scope' })
                    ], ComponentToBeInjected);
                    return ComponentToBeInjected;
                }());
                // @ts-ignore
                var ComponentToInjectTo = /** @class */ (function () {
                    function ComponentToInjectTo() {
                    }
                    __decorate([
                        inject,
                        __metadata("design:type", ComponentToBeInjected)
                    ], ComponentToInjectTo.prototype, "dependency", void 0);
                    ComponentToInjectTo = __decorate([
                        component
                    ], ComponentToInjectTo);
                    return ComponentToInjectTo;
                }());
                var consoleWarn = console.warn;
                try {
                    console.warn = function (msg) {
                        // tslint:disable-next-line:prefer-template
                        assert.equal(msg, "Component 'ComponentToBeInjected' is scoped to 'scope' "
                            + "and injected into 'ComponentToInjectTo' without scope. This could easily "
                            + "lead to stale references. Consider to add the scope 'scope' to "
                            + "'ComponentToInjectTo' as well or make the inject dynamic.");
                        done();
                    };
                    tsdi.getScope('scope').enter();
                    // tslint:disable-next-line:no-unused-expression
                    tsdi.get(ComponentToInjectTo).dependency;
                    tsdi.getScope('scope').leave();
                }
                finally {
                    console.warn = consoleWarn;
                }
            });
            it('should not warn about scope issues for external components', function () {
                tsdi.enableComponentScanner();
                // @ts-ignore
                var ComponentToBeInjected = /** @class */ (function () {
                    function ComponentToBeInjected() {
                    }
                    ComponentToBeInjected = __decorate([
                        component({ scope: 'scope' })
                    ], ComponentToBeInjected);
                    return ComponentToBeInjected;
                }());
                // @ts-ignore
                var ComponentToInjectTo = /** @class */ (function () {
                    function ComponentToInjectTo() {
                    }
                    __decorate([
                        inject,
                        __metadata("design:type", ComponentToBeInjected)
                    ], ComponentToInjectTo.prototype, "dependency", void 0);
                    ComponentToInjectTo = __decorate([
                        external
                    ], ComponentToInjectTo);
                    return ComponentToInjectTo;
                }());
                var consoleWarn = console.warn;
                try {
                    console.warn = function () {
                        assert.fail();
                    };
                    tsdi.getScope('scope').enter();
                    // tslint:disable-next-line:no-unused-expression
                    new ComponentToInjectTo().dependency;
                    tsdi.getScope('scope').leave();
                }
                finally {
                    console.warn = consoleWarn;
                }
            });
        });
    });
    describe('without container instance', function () {
        it('a created instance should not have dependencies satisified', function () {
            var comp = new User();
            assert.throw(comp.method);
        });
        it('a created instance should have mockable dependencies', function () {
            var comp = new User();
            comp['dependency'] = {
                echo: function () {
                    return 'world';
                }
            };
            assert.equal(comp.method(), 'world');
        });
    });
});
//# sourceMappingURL=index-test.js.map