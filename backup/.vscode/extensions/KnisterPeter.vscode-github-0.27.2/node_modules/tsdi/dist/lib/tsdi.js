"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
var global_state_1 = require("./global-state");
var helper_1 = require("./helper");
var debug = require("debug");
var log = debug('tsdi');
var TSDI = /** @class */ (function () {
    function TSDI() {
        this.autoMock = undefined;
        this.components = [];
        this.instances = {};
        this.properties = {};
        this.lifecycleListeners = [];
        this.scopes = {};
        this.registerComponent({
            fn: TSDI,
            options: {}
        });
        this.instances[0] = this;
    }
    TSDI.prototype.addLifecycleListener = function (lifecycleListener) {
        var _this = this;
        this.lifecycleListeners.push(lifecycleListener);
        Object.keys(this.instances).forEach(function (idx) {
            _this.notifyOnCreate(_this.instances[parseInt(idx, 10)]);
        });
    };
    TSDI.prototype.notifyOnCreate = function (component) {
        this.lifecycleListeners.forEach(function (l) {
            if (l.onCreate) {
                l.onCreate(component);
            }
        });
    };
    TSDI.prototype.notifyOnDestroy = function (component) {
        this.lifecycleListeners.forEach(function (l) {
            if (l.onDestroy) {
                l.onDestroy(component);
            }
        });
    };
    TSDI.prototype.addProperty = function (key, value) {
        this.properties[key] = value;
    };
    TSDI.prototype.close = function () {
        var _this = this;
        Object.keys(this.instances).forEach(function (key) {
            var idx = parseInt(key, 10);
            var metadata = _this.components[idx];
            if (!helper_1.isFactoryMetadata(metadata)) {
                _this.destroyInstance(idx, metadata);
            }
        });
        this.instances = [];
        if (this.listener) {
            global_state_1.removeListener(this.listener);
            this.listener = undefined;
        }
    };
    TSDI.prototype.destroyInstance = function (idx, metadata) {
        var instance = this.instances[idx];
        if (instance) {
            this.notifyOnDestroy(instance);
            var destroy = Reflect.getMetadata('component:destroy', helper_1.isFactoryMetadata(metadata) ? metadata.rtti : metadata.fn.prototype);
            if (destroy && instance[destroy]) {
                instance[destroy].call(instance);
            }
            this.instances[idx] = undefined;
        }
    };
    TSDI.prototype.enableComponentScanner = function () {
        var _this = this;
        if (!this.listener) {
            this.listener = function (metadataOrExternal) {
                if (typeof metadataOrExternal === 'function') {
                    metadataOrExternal.__tsdi__ = _this;
                }
                else {
                    _this.registerComponent(metadataOrExternal);
                }
            };
            if (this.listener) {
                global_state_1.addListener(this.listener);
            }
        }
    };
    TSDI.prototype.enableAutomock = function () {
        var allowedDependencies = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            allowedDependencies[_i] = arguments[_i];
        }
        this.autoMock = allowedDependencies;
    };
    TSDI.prototype.registerComponent = function (componentMetadata) {
        var _this = this;
        if (this.components.indexOf(componentMetadata) === -1) {
            if (componentMetadata.options.name && helper_1.findIndexOf(this.components, function (meta) { return meta.options.name === componentMetadata.options.name; }) > -1) {
                console.warn("Component with name '" + componentMetadata.options.name + "' already registered.");
            }
            log('registerComponent %o', helper_1.isFactoryMetadata(componentMetadata) ?
                componentMetadata.rtti.name : componentMetadata.fn.name);
            this.components.push(componentMetadata);
            if (componentMetadata.options.eager) {
                var idx_1 = this.components.length - 1;
                setTimeout(function () {
                    _this.getOrCreate(componentMetadata, idx_1);
                }, 0);
            }
        }
    };
    TSDI.prototype.register = function (component, name) {
        var options = Reflect.getMetadata('component:options', component) || {};
        this.registerComponent({
            fn: component,
            options: __assign({}, options, { name: name || options.name })
        });
    };
    TSDI.prototype.getComponentMetadataIndex = function (component, name) {
        for (var i = 0, n = this.components.length; i < n; i++) {
            if (name) {
                if (name === this.components[i].options.name) {
                    return i;
                }
            }
            else {
                if (this.isComponentMetadataIndexFromComponentOrFactory(component, this.components[i])) {
                    return i;
                }
            }
        }
        return -1;
    };
    TSDI.prototype.isComponentMetadataIndexFromComponentOrFactory = function (component, metadata) {
        return typeof component !== 'undefined'
            && (metadata.fn === component
                || helper_1.isFactoryMetadata(metadata)
                    && metadata.rtti === component);
    };
    TSDI.prototype.throwComponentNotFoundError = function (component, name, additionalInfo) {
        if (component && !name) {
            name = component.name;
        }
        if (!name) {
            name = 'unknown';
        }
        throw new Error("Component '" + name + "' not found" + (additionalInfo ? ": " + additionalInfo : ''));
    };
    TSDI.prototype.getConstructorParameters = function (metadata) {
        var _this = this;
        var parameterMetadata = Reflect.getMetadata('component:parameters', metadata.fn);
        if (parameterMetadata) {
            return parameterMetadata
                .sort(function (a, b) { return a.index - b.index; })
                .map(function (parameter) { return ({ index: _this.getComponentMetadataIndex(parameter.rtti, parameter.options.name) }); })
                .map(function (_a) {
                var index = _a.index;
                return _this.getOrCreate(_this.components[index], index);
            });
        }
        return [];
    };
    TSDI.prototype.isSingleton = function (metadata) {
        return typeof metadata.options.singleton === 'undefined' || metadata.options.singleton;
    };
    TSDI.prototype.getOrCreate = function (metadata, idx) {
        log('> getOrCreate %o', metadata);
        // todo: Use T here
        var instance = this.instances[idx];
        if (!instance || !this.isSingleton(metadata)) {
            if (helper_1.isFactoryMetadata(metadata)) {
                log('create %o from factory with %o', metadata.rtti.name, metadata.options);
                instance = this.get(metadata.target.constructor)[metadata.property]();
                this.instances[idx] = instance;
            }
            else {
                instance = this.createComponent(metadata, idx);
            }
            this.notifyOnCreate(instance);
        }
        log('< getOrCreate %o -> %o', metadata, instance);
        return instance;
    };
    TSDI.prototype.createComponent = function (metadata, idx) {
        if (!this.hasEnteredScope(metadata)) {
            this.throwComponentNotFoundError(metadata.fn, undefined, "required scope '" + metadata.options.scope + "' is not enabled");
        }
        log('create %o with %o', metadata.fn.name, metadata.options);
        var constructor = metadata.fn;
        var parameters = this.getConstructorParameters(metadata);
        var instance = new (constructor.bind.apply(constructor, [void 0].concat(parameters)))();
        // note: This stores an incomplete instance (injects/properties/...)
        // but it allows recursive use of injects
        this.instances[idx] = instance;
        this.injectIntoInstance(instance, false, metadata);
        var init = Reflect.getMetadata('component:init', metadata.fn.prototype);
        if (init) {
            instance[init].call(instance);
        }
        return instance;
    };
    TSDI.prototype.hasEnteredScope = function (metadata) {
        return !metadata.options.scope || Boolean(metadata.options.scope && this.scopes[metadata.options.scope]);
    };
    TSDI.prototype.configureExternal = function (args, target) {
        var parameters = this.getConstructorParameters({ fn: target, options: {} });
        var instance = new (target.bind.apply(target, [void 0].concat(args, parameters)))();
        this.injectIntoInstance(instance, true, { fn: target, options: {} });
        var init = Reflect.getMetadata('component:init', target.prototype);
        if (init) {
            instance[init].call(instance);
        }
        return instance;
    };
    TSDI.prototype.injectIntoInstance = function (instance, externalInstance, componentMetadata) {
        var injects = Reflect.getMetadata('component:injects', componentMetadata.fn.prototype);
        if (injects) {
            for (var _i = 0, injects_1 = injects; _i < injects_1.length; _i++) {
                var inject = injects_1[_i];
                log('injecting %s.%s', instance.constructor.name, inject.property);
                if (inject.options.name && typeof this.properties[inject.options.name] !== 'undefined') {
                    instance[inject.property] = this.properties[inject.options.name];
                }
                else {
                    this.injectDependency(instance, externalInstance, inject, componentMetadata);
                }
            }
        }
    };
    TSDI.prototype.injectDependency = function (instance, externalInstance, inject, componentMetadata) {
        if (this.injectAutoMock(instance, inject)) {
            return;
        }
        if (inject.options.lazy || inject.options.dynamic) {
            var tsdi_1 = this;
            Object.defineProperty(instance, inject.property, {
                configurable: true,
                enumerable: true,
                get: function () {
                    log('lazy-resolve injected property %s.%s', instance.constructor.name, inject.property);
                    var value = tsdi_1.getComponentDependency(inject, componentMetadata, externalInstance);
                    if (inject.options.dynamic) {
                        return value;
                    }
                    Object.defineProperty(instance, inject.property, {
                        enumerable: true,
                        value: value
                    });
                    log('lazy-resolved injected property %s.%s <- %o', instance.constructor.name, inject.property, instance[inject.property]);
                    return instance[inject.property];
                }
            });
        }
        else {
            instance[inject.property] = this.getComponentDependency(inject, componentMetadata, externalInstance);
        }
    };
    TSDI.prototype.injectAutoMock = function (instance, inject) {
        if (!this.autoMock) {
            return false;
        }
        var injectMetadata = this.getInjectComponentMetadata(inject)[0];
        if (injectMetadata) {
            var constructor = helper_1.isFactoryMetadata(injectMetadata) ? injectMetadata.rtti : injectMetadata.fn;
            if (this.autoMock.indexOf(constructor) > -1) {
                return false;
            }
            var automock = this.mock(constructor);
            if (automock) {
                instance[inject.property] = automock;
                return true;
            }
        }
        return false;
    };
    TSDI.prototype.createAutoMock = function (constructor) {
        if (!this.autoMock || this.autoMock.indexOf(constructor) > -1) {
            return undefined;
        }
        var automock = {
            __tsdi__mock__: 'This is a TSDI automock'
        };
        var proto = constructor.prototype;
        Object.keys(proto).forEach(function (property) {
            if (typeof proto[property] === 'function') {
                automock[property] = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return args;
                };
            }
        });
        if (automock) {
            return automock;
        }
        return undefined;
    };
    TSDI.prototype.mock = function (component) {
        var idx = this.getComponentMetadataIndex(component);
        if (!this.instances[idx]) {
            var mock = this.createAutoMock(component);
            if (!mock) {
                throw new Error("Failed to create mock from " + component.name);
            }
            this.instances[idx] = mock;
        }
        return this.instances[idx];
    };
    TSDI.prototype.getInjectComponentMetadata = function (inject) {
        var injectIdx = this.getComponentMetadataIndex(inject.type, inject.options.name);
        if (injectIdx === -1) {
            this.checkAndThrowDependencyError(inject);
            injectIdx = this.getComponentMetadataIndex(inject.type, inject.type.name);
        }
        var injectMetadata = this.components[injectIdx];
        if (!injectMetadata) {
            throw new Error("Failed to get inject '" + inject.options.name + "' for "
                + ("'" + inject.target.constructor.name + "#" + inject.property + "'"));
        }
        return [injectMetadata, injectIdx];
    };
    TSDI.prototype.getComponentDependency = function (inject, dependentMetadata, noScopeWarning) {
        var _a = this.getInjectComponentMetadata(inject), metadata = _a[0], injectIdx = _a[1];
        if (!noScopeWarning && !inject.options.dynamic && !helper_1.isFactoryMetadata(metadata)
            && metadata.options.scope && !dependentMetadata.options.scope) {
            // tslint:disable-next-line:prefer-template
            console.warn("Component '" + metadata.fn.name + "' is scoped to '" + metadata.options.scope + "' "
                + ("and injected into '" + dependentMetadata.fn.name + "' without scope. This could easily ")
                + ("lead to stale references. Consider to add the scope '" + metadata.options.scope + "' to ")
                + ("'" + dependentMetadata.fn.name + "' as well or make the inject dynamic."));
        }
        return this.getOrCreate(metadata, injectIdx);
    };
    TSDI.prototype.checkAndThrowDependencyError = function (inject) {
        if (inject.type && inject.options.name) {
            var e = new Error("Injecting undefined type on " + inject.target.constructor.name
                + ("#" + inject.property + ": Component named '" + inject.options.name + "' not found"));
            log(e);
            log('Known Components: %o', this.components.map(function (component) {
                return helper_1.isFactoryMetadata(component) ? component.rtti.name : component.fn.name;
            }));
            throw e;
        }
        if (!inject.type || inject.options.name) {
            var e = new Error("Injecting undefined type on " + inject.target.constructor.name
                + ("#" + inject.property + ": Probably a cyclic dependency, switch to name based injection"));
            log(e);
            throw e;
        }
    };
    TSDI.prototype.get = function (componentOrHint, hint) {
        var component;
        if (typeof componentOrHint === 'string') {
            hint = componentOrHint;
            component = undefined;
        }
        else {
            component = componentOrHint;
        }
        var idx = this.getComponentMetadataIndex(component, hint);
        var metadata = this.components[idx];
        if (!metadata) {
            this.throwComponentNotFoundError(component, hint);
        }
        return this.getOrCreate(metadata, idx);
    };
    TSDI.prototype.override = function (component, override) {
        var idx = this.getComponentMetadataIndex(component);
        this.instances[idx] = override;
        log('Override %o with %o', component, override);
    };
    TSDI.prototype.getScope = function (name) {
        var self = this;
        return {
            enter: function () {
                self.scopes[name] = true;
            },
            leave: function () {
                delete self.scopes[name];
                self.components
                    .filter(function (metadata) { return !helper_1.isFactoryMetadata(metadata) && metadata.options.scope === name; })
                    .forEach(function (metadata) {
                    var idx = self.getComponentMetadataIndex(helper_1.isFactoryMetadata(metadata) ? metadata.rtti : metadata.fn);
                    self.destroyInstance(idx, metadata);
                });
            }
        };
    };
    return TSDI;
}());
exports.TSDI = TSDI;
var component_1 = require("./component");
exports.component = component_1.component;
exports.Component = component_1.Component;
var external_1 = require("./external");
exports.external = external_1.external;
exports.External = external_1.External;
var inject_1 = require("./inject");
exports.inject = inject_1.inject;
exports.Inject = inject_1.Inject;
var initialize_1 = require("./initialize");
exports.initialize = initialize_1.initialize;
exports.Initialize = initialize_1.Initialize;
var destroy_1 = require("./destroy");
exports.destroy = destroy_1.destroy;
exports.Destroy = destroy_1.Destroy;
var factory_1 = require("./factory");
exports.factory = factory_1.factory;
exports.Factory = factory_1.Factory;
//# sourceMappingURL=tsdi.js.map