/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
"use strict";
/**
 * A node in a virtual DOM hierarchy.
 *
 * #### Notes
 * User code will not usually instantiate an node directly. Rather, the
 * `h()` function will be called to create a node in a type-safe manner.
 *
 * A node *must* be treated as immutable. Mutating the state of a node
 * **will** result in undefined rendering behavior.
 */
var VNode = (function () {
    /**
     * Construct a new virtual DOM node.
     *
     * @param type - The type of the node.
     *
     * @param tag - The node tag.
     *
     * @param attrs - The node attributes.
     *
     * @param children - The node children.
     */
    function VNode(type, tag, attrs, children) {
        this.type = type;
        this.tag = tag;
        this.attrs = attrs;
        this.children = children;
    }
    return VNode;
}());
exports.VNode = VNode;
function h(tag, first) {
    // Setup the variables to hold the parsed data.
    var attrs;
    var children;
    // Parse the first variadic argument.
    if (first) {
        if (typeof first === 'string') {
            children = [first];
        }
        else if (first instanceof VNode) {
            children = [first];
        }
        else if (first instanceof Array) {
            children = first.slice();
        }
        else {
            attrs = first;
        }
    }
    // Parse the rest of the variadic arguments.
    if (arguments.length > 2) {
        children = children || [];
        for (var i = 2, n = arguments.length; i < n; ++i) {
            var child = arguments[i];
            if (child instanceof Array) {
                for (var j = 0, k = child.length; j < k; ++j) {
                    if (child[j])
                        children.push(child[j]);
                }
            }
            else if (child) {
                children.push(child);
            }
        }
    }
    // Convert string literal children into text nodes.
    if (children) {
        for (var i = 0, n = children.length; i < n; ++i) {
            var child = children[i];
            if (typeof child === 'string') {
                children[i] = Private.createTextVNode(child);
            }
        }
    }
    // Return a new virtual DOM node.
    return Private.createElementVNode(tag, attrs, children);
}
exports.h = h;
/**
 * The namespace for the `h()` function statics.
 */
(function (h) {
    h.a = h.bind(void 0, 'a');
    h.abbr = h.bind(void 0, 'abbr');
    h.address = h.bind(void 0, 'address');
    h.area = h.bind(void 0, 'area');
    h.article = h.bind(void 0, 'article');
    h.aside = h.bind(void 0, 'aside');
    h.audio = h.bind(void 0, 'audio');
    h.b = h.bind(void 0, 'b');
    h.bdi = h.bind(void 0, 'bdi');
    h.bdo = h.bind(void 0, 'bdo');
    h.blockquote = h.bind(void 0, 'blockquote');
    h.br = h.bind(void 0, 'br');
    h.button = h.bind(void 0, 'button');
    h.canvas = h.bind(void 0, 'canvas');
    h.caption = h.bind(void 0, 'caption');
    h.cite = h.bind(void 0, 'cite');
    h.code = h.bind(void 0, 'code');
    h.col = h.bind(void 0, 'col');
    h.colgroup = h.bind(void 0, 'colgroup');
    h.data = h.bind(void 0, 'data');
    h.datalist = h.bind(void 0, 'datalist');
    h.dd = h.bind(void 0, 'dd');
    h.del = h.bind(void 0, 'del');
    h.dfn = h.bind(void 0, 'dfn');
    h.div = h.bind(void 0, 'div');
    h.dl = h.bind(void 0, 'dl');
    h.dt = h.bind(void 0, 'dt');
    h.em = h.bind(void 0, 'em');
    h.embed = h.bind(void 0, 'embed');
    h.fieldset = h.bind(void 0, 'fieldset');
    h.figcaption = h.bind(void 0, 'figcaption');
    h.figure = h.bind(void 0, 'figure');
    h.footer = h.bind(void 0, 'footer');
    h.form = h.bind(void 0, 'form');
    h.h1 = h.bind(void 0, 'h1');
    h.h2 = h.bind(void 0, 'h2');
    h.h3 = h.bind(void 0, 'h3');
    h.h4 = h.bind(void 0, 'h4');
    h.h5 = h.bind(void 0, 'h5');
    h.h6 = h.bind(void 0, 'h6');
    h.header = h.bind(void 0, 'header');
    h.hr = h.bind(void 0, 'hr');
    h.i = h.bind(void 0, 'i');
    h.iframe = h.bind(void 0, 'iframe');
    h.img = h.bind(void 0, 'img');
    h.input = h.bind(void 0, 'input');
    h.ins = h.bind(void 0, 'ins');
    h.kbd = h.bind(void 0, 'kbd');
    h.label = h.bind(void 0, 'label');
    h.legend = h.bind(void 0, 'legend');
    h.li = h.bind(void 0, 'li');
    h.main = h.bind(void 0, 'main');
    h.map = h.bind(void 0, 'map');
    h.mark = h.bind(void 0, 'mark');
    h.meter = h.bind(void 0, 'meter');
    h.nav = h.bind(void 0, 'nav');
    h.noscript = h.bind(void 0, 'noscript');
    h.object = h.bind(void 0, 'object');
    h.ol = h.bind(void 0, 'ol');
    h.optgroup = h.bind(void 0, 'optgroup');
    h.option = h.bind(void 0, 'option');
    h.output = h.bind(void 0, 'output');
    h.p = h.bind(void 0, 'p');
    h.param = h.bind(void 0, 'param');
    h.pre = h.bind(void 0, 'pre');
    h.progress = h.bind(void 0, 'progress');
    h.q = h.bind(void 0, 'q');
    h.rp = h.bind(void 0, 'rp');
    h.rt = h.bind(void 0, 'rt');
    h.ruby = h.bind(void 0, 'ruby');
    h.s = h.bind(void 0, 's');
    h.samp = h.bind(void 0, 'samp');
    h.section = h.bind(void 0, 'section');
    h.select = h.bind(void 0, 'select');
    h.small = h.bind(void 0, 'small');
    h.source = h.bind(void 0, 'source');
    h.span = h.bind(void 0, 'span');
    h.strong = h.bind(void 0, 'strong');
    h.sub = h.bind(void 0, 'sub');
    h.summary = h.bind(void 0, 'summary');
    h.sup = h.bind(void 0, 'sup');
    h.table = h.bind(void 0, 'table');
    h.tbody = h.bind(void 0, 'tbody');
    h.td = h.bind(void 0, 'td');
    h.textarea = h.bind(void 0, 'textarea');
    h.tfoot = h.bind(void 0, 'tfoot');
    h.th = h.bind(void 0, 'th');
    h.thead = h.bind(void 0, 'thead');
    h.time = h.bind(void 0, 'time');
    h.title = h.bind(void 0, 'title');
    h.tr = h.bind(void 0, 'tr');
    h.track = h.bind(void 0, 'track');
    h.u = h.bind(void 0, 'u');
    h.ul = h.bind(void 0, 'ul');
    h.var_ = h.bind(void 0, 'var');
    h.video = h.bind(void 0, 'video');
    h.wbr = h.bind(void 0, 'wbr');
})(h = exports.h || (exports.h = {}));
/**
 * Create a real DOM node from a virtual DOM node.
 *
 * @param content - The virtual DOM content to realize.
 *
 * @returns A new DOM node for the given virtual DOM tree.
 *
 * #### Notes
 * The content node is assumed to be of the `'element'` type.
 *
 * This creates a brand new *real* DOM node with a structure which
 * matches the given virtual DOM node.
 *
 * If virtual diffing is desired, use the `render` function instead.
 */
function realize(content) {
    return Private.realizeImpl(content);
}
exports.realize = realize;
/**
 * Render virtual DOM content into a host element.
 *
 * @param content - The virtual DOM content to render.
 *
 * @param host - The host element for the rendered content.
 *
 * #### Notes
 * This renders the delta from the previous rendering. It assumes that
 * the content of the host element is not manipulated by external code.
 *
 * Providing `null` content will clear the rendering.
 *
 * Externally modifying the provided content or the host element will
 * result in undefined rendering behavior.
 */
function render(content, host) {
    Private.renderImpl(content, host);
}
exports.render = render;
/**
 * The namespace for the private module data.
 */
var Private;
(function (Private) {
    /**
     * Create a virtual text node for the given string.
     */
    function createTextVNode(text) {
        return new VNode('text', text, emptyObject, emptyArray);
    }
    Private.createTextVNode = createTextVNode;
    /**
     * Create a virtual element node for the given parameters.
     */
    function createElementVNode(tag, attrs, children) {
        attrs = attrs || emptyObject;
        children = children || emptyArray;
        return new VNode('element', tag, attrs, children);
    }
    Private.createElementVNode = createElementVNode;
    /**
     * The internal `realize` entry point.
     */
    function realizeImpl(content) {
        return createDOMNode(content);
    }
    Private.realizeImpl = realizeImpl;
    /**
     * The internal `render` entry point.
     */
    function renderImpl(content, host) {
        var oldContent = hostMap.get(host) || emptyArray;
        var newContent = asVNodeArray(content);
        hostMap.set(host, newContent);
        updateContent(host, oldContent, newContent);
    }
    Private.renderImpl = renderImpl;
    /**
     * A shared frozen empty array.
     */
    var emptyArray = Object.freeze([]);
    /**
     * A shared frozen empty object.
     */
    var emptyObject = Object.freeze({});
    /**
     * A weak mapping of host element to virtual DOM content.
     */
    var hostMap = new WeakMap();
    /**
     * Coerce content into a virtual node array.
     *
     * Null content will be coerced to an empty array.
     */
    function asVNodeArray(content) {
        if (content instanceof Array) {
            return content;
        }
        if (content) {
            return [content];
        }
        return emptyArray;
    }
    /**
     * Update a host element with the delta of the virtual content.
     *
     * This is the core "diff" algorithm. There is no explicit "patch"
     * phase. The host is patched at each step as the diff progresses.
     */
    function updateContent(host, oldContent, newContent) {
        // Bail early if the content is identical. This can occur when an
        // node has no children or if the user is rendering cached content.
        if (oldContent === newContent) {
            return;
        }
        // Collect the old keyed elems into a mapping.
        var oldKeyed = collectKeys(host, oldContent);
        // Create a copy of the old content which can be modified in-place.
        var oldCopy = oldContent.slice();
        // Update the host with the new content. The diff always proceeds
        // forward and never modifies a previously visited index. The old
        // copy array is modified in-place to reflect the changes made to
        // the host children. This causes the stale nodes to be pushed to
        // the end of the host node and removed at the end of the loop.
        var currNode = host.firstChild;
        var newCount = newContent.length;
        for (var i = 0; i < newCount; ++i) {
            // If the old elems are exhausted, create a new node.
            if (i >= oldCopy.length) {
                host.appendChild(createDOMNode(newContent[i]));
                continue;
            }
            // Cache a reference to the old and new elems.
            var oldVNode = oldCopy[i];
            var newVNode = newContent[i];
            // If the new elem is keyed, move an old keyed elem to the proper
            // location before proceeding with the diff. The search can start
            // at the current index, since the unmatched old keyed elems are
            // pushed forward in the old copy array.
            var newKey = newVNode.attrs.key;
            if (newKey && newKey in oldKeyed) {
                var pair = oldKeyed[newKey];
                if (pair.vNode !== oldVNode) {
                    arrayMove(oldCopy, oldCopy.indexOf(pair.vNode), i);
                    host.insertBefore(pair.element, currNode);
                    oldVNode = pair.vNode;
                    currNode = pair.element;
                }
            }
            // If both elements are identical, there is nothing to do.
            // This can occur when the user renders cached content.
            if (oldVNode === newVNode) {
                currNode = currNode.nextSibling;
                continue;
            }
            // If the old elem is keyed and does not match the new elem key,
            // create a new node. This is necessary since the old keyed elem
            // may be matched at a later point in the diff.
            var oldKey = oldVNode.attrs.key;
            if (oldKey && oldKey !== newKey) {
                arrayInsert(oldCopy, i, newVNode);
                host.insertBefore(createDOMNode(newVNode), currNode);
                continue;
            }
            // If the elements have different types, create a new node.
            if (oldVNode.type !== newVNode.type) {
                arrayInsert(oldCopy, i, newVNode);
                host.insertBefore(createDOMNode(newVNode), currNode);
                continue;
            }
            // If the element is a text node, update its text content.
            if (newVNode.type === 'text') {
                currNode.textContent = newVNode.tag;
                currNode = currNode.nextSibling;
                continue;
            }
            // At this point, the node is an 'element' type. If the tags
            // are different, create a new node.
            if (oldVNode.tag !== newVNode.tag) {
                arrayInsert(oldCopy, i, newVNode);
                host.insertBefore(createDOMNode(newVNode), currNode);
                continue;
            }
            // The element tags match, update the element in place.
            updateAttrs(currNode, oldVNode.attrs, newVNode.attrs);
            updateContent(currNode, oldVNode.children, newVNode.children);
            currNode = currNode.nextSibling;
        }
        // Dispose of the old nodes pushed to the end of the host.
        for (var i = oldCopy.length - 1; i >= newCount; --i) {
            host.removeChild(host.lastChild);
        }
    }
    /**
     * Add attributes to a newly created DOM node.
     */
    function addAttrs(node, attrs) {
        // Set the known attributes defined in the attr table.
        for (var name_1 in attrs) {
            var mode = attrModeTable[name_1];
            if (mode === 0 /* Property */ || mode === 2 /* Event */) {
                node[name_1] = attrs[name_1];
            }
            else if (mode === 1 /* Attribute */) {
                node.setAttribute(name_1.toLowerCase(), attrs[name_1]);
            }
        }
        // Handle the dataset values.
        var dataset = attrs.dataset;
        if (dataset) {
            for (var name_2 in dataset) {
                node.setAttribute("data-" + name_2, dataset[name_2]);
            }
        }
        // Handle the inline styles.
        var styles = attrs.style;
        if (styles) {
            var nodeStyle = node.style;
            for (var name_3 in styles) {
                nodeStyle[name_3] = styles[name_3];
            }
        }
    }
    /**
     * Update the node attributes with the delta of attribute objects.
     */
    function updateAttrs(node, oldAttrs, newAttrs) {
        // Do nothing if the attrs are the same object.
        if (oldAttrs === newAttrs) {
            return;
        }
        // Remove attributes which no longer exist.
        for (var name_4 in oldAttrs) {
            if (!(name_4 in newAttrs)) {
                var mode = attrModeTable[name_4];
                if (mode === 0 /* Property */) {
                    node.removeAttribute(name_4);
                }
                else if (mode === 1 /* Attribute */) {
                    node.removeAttribute(name_4.toLowerCase());
                }
                else if (mode === 2 /* Event */) {
                    node[name_4] = null;
                }
            }
        }
        // Add new attributes an update existing ones.
        for (var name_5 in newAttrs) {
            var value = newAttrs[name_5];
            if (oldAttrs[name_5] !== value) {
                var mode = attrModeTable[name_5];
                if (mode === 0 /* Property */ || mode === 2 /* Event */) {
                    node[name_5] = value;
                }
                else if (mode === 1 /* Attribute */) {
                    node.setAttribute(name_5.toLowerCase(), value);
                }
            }
        }
        // Handle the dataset values.
        var oldDataset = oldAttrs.dataset || emptyObject;
        var newDataset = newAttrs.dataset || emptyObject;
        if (oldDataset !== newDataset) {
            for (var name_6 in oldDataset) {
                if (!(name_6 in newDataset)) {
                    node.removeAttribute('data-' + name_6);
                }
            }
            for (var name_7 in newDataset) {
                var value = newDataset[name_7];
                if (oldDataset[name_7] !== value) {
                    node.setAttribute('data-' + name_7, value);
                }
            }
        }
        // Handle the inline styles.
        var oldStyle = oldAttrs.style || emptyObject;
        var newStyle = newAttrs.style || emptyObject;
        if (oldStyle !== newStyle) {
            var nodeStyle = node.style;
            for (var name_8 in oldStyle) {
                if (!(name_8 in newStyle)) {
                    nodeStyle[name_8] = '';
                }
            }
            for (var name_9 in newStyle) {
                var value = newStyle[name_9];
                if (oldStyle[name_9] !== value) {
                    nodeStyle[name_9] = value;
                }
            }
        }
    }
    /**
     * Collect a mapping of keyed elements for the host content.
     */
    function collectKeys(host, content) {
        var node = host.firstChild;
        var keyed = Object.create(null);
        for (var i = 0, n = content.length; i < n; ++i) {
            var vNode = content[i];
            if (vNode.type === 'element') {
                var key = vNode.attrs.key;
                if (key)
                    keyed[key] = { vNode: vNode, element: node };
            }
            node = node.nextSibling;
        }
        return keyed;
    }
    /**
     * Create and return a new DOM node for a virtual element.
     */
    function createDOMNode(elem) {
        var node;
        if (elem.type === 'text') {
            node = document.createTextNode(elem.tag);
        }
        else {
            node = document.createElement(elem.tag);
            addAttrs(node, elem.attrs);
            addContent(node, elem.children);
        }
        return node;
    }
    /**
     * Create and add child content to a newly created DOM node.
     */
    function addContent(node, content) {
        for (var i = 0, n = content.length; i < n; ++i) {
            node.appendChild(createDOMNode(content[i]));
        }
    }
    /**
     * A mapping of attribute name to attribute mode.
     */
    var attrModeTable = {
        accept: 0 /* Property */,
        acceptCharset: 0 /* Property */,
        accessKey: 0 /* Property */,
        action: 0 /* Property */,
        allowFullscreen: 1 /* Attribute */,
        alt: 0 /* Property */,
        autocomplete: 0 /* Property */,
        autofocus: 0 /* Property */,
        autoplay: 0 /* Property */,
        checked: 0 /* Property */,
        cite: 0 /* Property */,
        className: 0 /* Property */,
        colSpan: 0 /* Property */,
        cols: 0 /* Property */,
        contentEditable: 0 /* Property */,
        controls: 0 /* Property */,
        coords: 0 /* Property */,
        crossOrigin: 0 /* Property */,
        data: 0 /* Property */,
        dateTime: 0 /* Property */,
        default: 0 /* Property */,
        dir: 0 /* Property */,
        dirName: 0 /* Property */,
        disabled: 0 /* Property */,
        download: 0 /* Property */,
        draggable: 0 /* Property */,
        enctype: 0 /* Property */,
        form: 1 /* Attribute */,
        formAction: 0 /* Property */,
        formEnctype: 0 /* Property */,
        formMethod: 0 /* Property */,
        formNoValidate: 0 /* Property */,
        formTarget: 0 /* Property */,
        headers: 0 /* Property */,
        height: 0 /* Property */,
        hidden: 0 /* Property */,
        high: 0 /* Property */,
        href: 0 /* Property */,
        hreflang: 0 /* Property */,
        htmlFor: 0 /* Property */,
        id: 0 /* Property */,
        inputMode: 0 /* Property */,
        isMap: 0 /* Property */,
        kind: 0 /* Property */,
        label: 0 /* Property */,
        lang: 0 /* Property */,
        list: 1 /* Attribute */,
        loop: 0 /* Property */,
        low: 0 /* Property */,
        max: 0 /* Property */,
        maxLength: 0 /* Property */,
        media: 1 /* Attribute */,
        mediaGroup: 0 /* Property */,
        method: 0 /* Property */,
        min: 0 /* Property */,
        minLength: 0 /* Property */,
        multiple: 0 /* Property */,
        muted: 0 /* Property */,
        name: 0 /* Property */,
        noValidate: 0 /* Property */,
        optimum: 0 /* Property */,
        pattern: 0 /* Property */,
        placeholder: 0 /* Property */,
        poster: 0 /* Property */,
        preload: 0 /* Property */,
        readOnly: 0 /* Property */,
        rel: 0 /* Property */,
        required: 0 /* Property */,
        reversed: 0 /* Property */,
        rowSpan: 0 /* Property */,
        rows: 0 /* Property */,
        sandbox: 0 /* Property */,
        scope: 0 /* Property */,
        seamless: 1 /* Attribute */,
        selected: 0 /* Property */,
        shape: 0 /* Property */,
        size: 0 /* Property */,
        sizes: 1 /* Attribute */,
        sorted: 0 /* Property */,
        span: 0 /* Property */,
        spellcheck: 0 /* Property */,
        src: 0 /* Property */,
        srcdoc: 0 /* Property */,
        srclang: 0 /* Property */,
        srcset: 1 /* Attribute */,
        start: 0 /* Property */,
        step: 0 /* Property */,
        tabIndex: 0 /* Property */,
        target: 0 /* Property */,
        title: 0 /* Property */,
        type: 0 /* Property */,
        typeMustMatch: 0 /* Property */,
        useMap: 0 /* Property */,
        value: 0 /* Property */,
        volume: 0 /* Property */,
        width: 0 /* Property */,
        wrap: 0 /* Property */,
        onabort: 2 /* Event */,
        onbeforecopy: 2 /* Event */,
        onbeforecut: 2 /* Event */,
        onbeforepaste: 2 /* Event */,
        onblur: 2 /* Event */,
        oncanplay: 2 /* Event */,
        oncanplaythrough: 2 /* Event */,
        onchange: 2 /* Event */,
        onclick: 2 /* Event */,
        oncontextmenu: 2 /* Event */,
        oncopy: 2 /* Event */,
        oncuechange: 2 /* Event */,
        oncut: 2 /* Event */,
        ondblclick: 2 /* Event */,
        ondrag: 2 /* Event */,
        ondragend: 2 /* Event */,
        ondragenter: 2 /* Event */,
        ondragleave: 2 /* Event */,
        ondragover: 2 /* Event */,
        ondragstart: 2 /* Event */,
        ondrop: 2 /* Event */,
        ondurationchange: 2 /* Event */,
        onended: 2 /* Event */,
        onemptied: 2 /* Event */,
        onerror: 2 /* Event */,
        onfocus: 2 /* Event */,
        onhelp: 2 /* Event */,
        oninput: 2 /* Event */,
        onkeydown: 2 /* Event */,
        onkeypress: 2 /* Event */,
        onkeyup: 2 /* Event */,
        onload: 2 /* Event */,
        onloadeddata: 2 /* Event */,
        onloadedmetadata: 2 /* Event */,
        onloadstart: 2 /* Event */,
        onmousedown: 2 /* Event */,
        onmouseenter: 2 /* Event */,
        onmouseleave: 2 /* Event */,
        onmousemove: 2 /* Event */,
        onmouseout: 2 /* Event */,
        onmouseover: 2 /* Event */,
        onmouseup: 2 /* Event */,
        onmousewheel: 2 /* Event */,
        onpaste: 2 /* Event */,
        onpause: 2 /* Event */,
        onplay: 2 /* Event */,
        onplaying: 2 /* Event */,
        onprogress: 2 /* Event */,
        onratechange: 2 /* Event */,
        onreadystatechange: 2 /* Event */,
        onreset: 2 /* Event */,
        onscroll: 2 /* Event */,
        onseeked: 2 /* Event */,
        onseeking: 2 /* Event */,
        onselect: 2 /* Event */,
        onselectstart: 2 /* Event */,
        onstalled: 2 /* Event */,
        onsubmit: 2 /* Event */,
        onsuspend: 2 /* Event */,
        ontimeupdate: 2 /* Event */,
        onvolumechange: 2 /* Event */,
        onwaiting: 2 /* Event */
    };
    /**
     * Insert an element into an array at a specified index.
     */
    function arrayInsert(array, i, value) {
        for (var k = array.length; k > i; --k) {
            array[k] = array[k - 1];
        }
        array[i] = value;
    }
    /**
     * Move an element in an array from one index to another.
     */
    function arrayMove(array, i, j) {
        if (i === j) {
            return;
        }
        var value = array[i];
        var d = i < j ? 1 : -1;
        for (var k = i; k !== j; k += d) {
            array[k] = array[k + d];
        }
        array[j] = value;
    }
})(Private || (Private = {}));
