"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
var messaging_1 = require("../core/messaging");
var signaling_1 = require("../core/signaling");
var platform_1 = require("../dom/platform");
var sizing_1 = require("../dom/sizing");
var panel_1 = require("./panel");
var widget_1 = require("./widget");
/**
 * The class name added to StackedPanel instances.
 */
var STACKED_PANEL_CLASS = 'p-StackedPanel';
/**
 * The class name added to a StackedPanel child.
 */
var CHILD_CLASS = 'p-StackedPanel-child';
/**
 * A panel where visible widgets are stacked atop one another.
 *
 * #### Notes
 * This class provides a convenience wrapper around a [[StackedLayout]].
 */
var StackedPanel = (function (_super) {
    __extends(StackedPanel, _super);
    /**
     * Construct a new stacked panel.
     *
     * @param options - The options for initializing the panel.
     */
    function StackedPanel(options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, { layout: Private.createLayout(options) }) || this;
        _this.addClass(STACKED_PANEL_CLASS);
        return _this;
    }
    /**
     * A message handler invoked on a `'child-added'` message.
     */
    StackedPanel.prototype.onChildAdded = function (msg) {
        msg.child.addClass(CHILD_CLASS);
    };
    /**
     * A message handler invoked on a `'child-removed'` message.
     */
    StackedPanel.prototype.onChildRemoved = function (msg) {
        msg.child.removeClass(CHILD_CLASS);
        this.widgetRemoved.emit(msg.child);
    };
    return StackedPanel;
}(panel_1.Panel));
exports.StackedPanel = StackedPanel;
// Define the signals for the `StackedPanel` class.
signaling_1.defineSignal(StackedPanel.prototype, 'widgetRemoved');
/**
 * A layout where visible widgets are stacked atop one another.
 *
 * #### Notes
 * The Z-order of the visible widgets follows their layout order.
 */
var StackedLayout = (function (_super) {
    __extends(StackedLayout, _super);
    function StackedLayout() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._dirty = false;
        _this._box = null;
        return _this;
    }
    /**
     * Attach a widget to the parent's DOM node.
     *
     * @param index - The current index of the widget in the layout.
     *
     * @param widget - The widget to attach to the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    StackedLayout.prototype.attachWidget = function (index, widget) {
        // Prepare the layout geometry for the widget.
        widget_1.Widget.prepareGeometry(widget);
        // Add the widget's node to the parent.
        this.parent.node.appendChild(widget.node);
        // Send an `'after-attach'` message if the parent is attached.
        if (this.parent.isAttached)
            messaging_1.sendMessage(widget, widget_1.WidgetMessage.AfterAttach);
        // Post a fit request for the parent widget.
        this.parent.fit();
    };
    /**
     * Move a widget in the parent's DOM node.
     *
     * @param fromIndex - The previous index of the widget in the layout.
     *
     * @param toIndex - The current index of the widget in the layout.
     *
     * @param widget - The widget to move in the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    StackedLayout.prototype.moveWidget = function (fromIndex, toIndex, widget) {
        // Post an update request for the parent widget.
        this.parent.update();
    };
    /**
     * Detach a widget from the parent's DOM node.
     *
     * @param index - The previous index of the widget in the layout.
     *
     * @param widget - The widget to detach from the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    StackedLayout.prototype.detachWidget = function (index, widget) {
        // Send a `'before-detach'` message if the parent is attached.
        if (this.parent.isAttached)
            messaging_1.sendMessage(widget, widget_1.WidgetMessage.BeforeDetach);
        // Remove the widget's node from the parent.
        this.parent.node.removeChild(widget.node);
        // Reset the layout geometry for the widget.
        widget_1.Widget.resetGeometry(widget);
        // Reset the z-index for the widget.
        widget.node.style.zIndex = '';
        // Post a fit request for the parent widget.
        this.parent.fit();
    };
    /**
     * A message handler invoked on an `'after-show'` message.
     */
    StackedLayout.prototype.onAfterShow = function (msg) {
        _super.prototype.onAfterShow.call(this, msg);
        this.parent.update();
    };
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    StackedLayout.prototype.onAfterAttach = function (msg) {
        _super.prototype.onAfterAttach.call(this, msg);
        this.parent.fit();
    };
    /**
     * A message handler invoked on a `'child-shown'` message.
     */
    StackedLayout.prototype.onChildShown = function (msg) {
        if (platform_1.IS_IE || platform_1.IS_EDGE) {
            messaging_1.sendMessage(this.parent, widget_1.WidgetMessage.FitRequest);
        }
        else {
            this.parent.fit();
        }
    };
    /**
     * A message handler invoked on a `'child-hidden'` message.
     */
    StackedLayout.prototype.onChildHidden = function (msg) {
        if (platform_1.IS_IE || platform_1.IS_EDGE) {
            messaging_1.sendMessage(this.parent, widget_1.WidgetMessage.FitRequest);
        }
        else {
            this.parent.fit();
        }
    };
    /**
     * A message handler invoked on a `'resize'` message.
     */
    StackedLayout.prototype.onResize = function (msg) {
        if (this.parent.isVisible) {
            this._update(msg.width, msg.height);
        }
    };
    /**
     * A message handler invoked on an `'update-request'` message.
     */
    StackedLayout.prototype.onUpdateRequest = function (msg) {
        if (this.parent.isVisible) {
            this._update(-1, -1);
        }
    };
    /**
     * A message handler invoked on a `'fit-request'` message.
     */
    StackedLayout.prototype.onFitRequest = function (msg) {
        if (this.parent.isAttached) {
            this._fit();
        }
    };
    /**
     * Fit the layout to the total size required by the widgets.
     */
    StackedLayout.prototype._fit = function () {
        // Setup the initial size limits.
        var minW = 0;
        var minH = 0;
        var maxW = Infinity;
        var maxH = Infinity;
        // Update the computed size limits.
        var widgets = this.widgets;
        for (var i = 0, n = widgets.length; i < n; ++i) {
            var widget = widgets.at(i);
            if (widget.isHidden) {
                continue;
            }
            var limits = sizing_1.sizeLimits(widget.node);
            minW = Math.max(minW, limits.minWidth);
            minH = Math.max(minH, limits.minHeight);
            maxW = Math.min(maxW, limits.maxWidth);
            maxH = Math.min(maxH, limits.maxHeight);
        }
        // Ensure max limits >= min limits.
        maxW = Math.max(minW, maxW);
        maxH = Math.max(minH, maxH);
        // Update the box sizing and add it to the size constraints.
        var box = this._box = sizing_1.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        maxW += box.horizontalSum;
        maxH += box.verticalSum;
        // Update the parent's size constraints.
        var style = this.parent.node.style;
        style.minWidth = minW + "px";
        style.minHeight = minH + "px";
        style.maxWidth = maxW === Infinity ? 'none' : maxW + "px";
        style.maxHeight = maxH === Infinity ? 'none' : maxH + "px";
        // Set the dirty flag to ensure only a single update occurs.
        this._dirty = true;
        // Notify the ancestor that it should fit immediately. This may
        // cause a resize of the parent, fulfilling the required update.
        var ancestor = this.parent.parent;
        if (ancestor)
            messaging_1.sendMessage(ancestor, widget_1.WidgetMessage.FitRequest);
        // If the dirty flag is still set, the parent was not resized.
        // Trigger the required update on the parent widget immediately.
        if (this._dirty)
            messaging_1.sendMessage(this.parent, widget_1.WidgetMessage.UpdateRequest);
    };
    /**
     * Update the layout position and size of the widgets.
     *
     * The parent offset dimensions should be `-1` if unknown.
     */
    StackedLayout.prototype._update = function (offsetWidth, offsetHeight) {
        // Clear the dirty flag to indicate the update occurred.
        this._dirty = false;
        // Bail early if there are no widgets to layout.
        var widgets = this.widgets;
        if (widgets.length === 0) {
            return;
        }
        // Measure the parent if the offset dimensions are unknown.
        if (offsetWidth < 0) {
            offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
            offsetHeight = this.parent.node.offsetHeight;
        }
        // Ensure the parent box sizing data is computed.
        var box = this._box || (this._box = sizing_1.boxSizing(this.parent.node));
        // Compute the actual layout bounds adjusted for border and padding.
        var top = box.paddingTop;
        var left = box.paddingLeft;
        var width = offsetWidth - box.horizontalSum;
        var height = offsetHeight - box.verticalSum;
        // Update the widget stacking order and layout geometry.
        for (var i = 0, n = widgets.length; i < n; ++i) {
            var widget = widgets.at(i);
            if (widget.isHidden) {
                continue;
            }
            widget.node.style.zIndex = "" + i;
            widget_1.Widget.setGeometry(widget, left, top, width, height);
        }
    };
    return StackedLayout;
}(panel_1.PanelLayout));
exports.StackedLayout = StackedLayout;
/**
 * The namespace for the private module data.
 */
var Private;
(function (Private) {
    /**
     * Create a stacked layout for the given panel options.
     */
    function createLayout(options) {
        return options.layout || new StackedLayout();
    }
    Private.createLayout = createLayout;
})(Private || (Private = {}));
