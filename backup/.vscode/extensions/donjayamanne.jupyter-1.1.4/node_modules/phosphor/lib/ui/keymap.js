"use strict";
/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
var json_1 = require("../algorithm/json");
var searching_1 = require("../algorithm/searching");
var vector_1 = require("../collections/vector");
var disposable_1 = require("../core/disposable");
var signaling_1 = require("../core/signaling");
var platform_1 = require("../dom/platform");
var selector_1 = require("../dom/selector");
var keyboard_1 = require("./keyboard");
/**
 * The timeout in ms for triggering a chord.
 */
var CHORD_TIMEOUT = 1000;
/**
 * A class which manages a collection of key bindings.
 */
var Keymap = (function () {
    /**
     * Construct a new keymap.
     *
     * @param options - The options for initializing the keymap.
     */
    function Keymap(options) {
        this._timerID = 0;
        this._replaying = false;
        this._keys = [];
        this._events = [];
        this._exact = null;
        this._bindings = new vector_1.Vector();
        this._commands = options.commands;
        this._layout = options.layout || keyboard_1.EN_US;
    }
    Object.defineProperty(Keymap.prototype, "commands", {
        /**
         * The command registry used by the keymap.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._commands;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Keymap.prototype, "layout", {
        /**
         * Get the keyboard layout used by the keymap.
         *
         * #### Notes
         * The default is a US English layout.
         */
        get: function () {
            return this._layout;
        },
        /**
         * Set the keyboard layout used by the keymap.
         *
         * #### Notes
         * A keymap requires a keyboard layout, so setting this value to
         * `null` will revert the layout to the default US English layout.
         */
        set: function (value) {
            var oldValue = this._layout;
            var newValue = value || keyboard_1.EN_US;
            if (oldValue === newValue) {
                return;
            }
            this._layout = newValue;
            this.layoutChanged.emit({ oldValue: oldValue, newValue: newValue });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Keymap.prototype, "bindings", {
        /**
         * A read-only sequence of the key bindings in the keymap.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._bindings;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Find a key binding which matches the given command and args.
     *
     * @param command - The id of the command of interest.
     *
     * @param args - The arguments for the command.
     *
     * @returns The most recently added key binding which matches the
     *   specified command and args, or `null` if no match is found.
     *
     * #### Notes
     * This is a convenience method which searches through the public
     * sequence of key `bindings`. If custom search behavior is needed,
     * user code may search that sequence manually.
     */
    Keymap.prototype.findBinding = function (command, args) {
        var i = searching_1.findLastIndex(this._bindings, function (kb) {
            return kb.command === command && json_1.deepEqual(kb.args, args);
        });
        return i !== -1 ? this._bindings.at(i) : null;
    };
    /**
     * Add a key binding to the keymap.
     *
     * @param options - The options for creating the key binding.
     *
     * @returns A disposable which removes the added key binding.
     *
     * #### Notes
     * If multiple key bindings are registered for the same sequence, the
     * binding with the highest selector specificity is executed first. A
     * tie is broken by using the most recently added key binding.
     *
     * Ambiguous key bindings are resolved with a timeout. As an example,
     * suppose two key bindings are registered: one with the key sequence
     * `['Ctrl D']`, and another with `['Ctrl D', 'Ctrl W']`. If the user
     * presses `Ctrl D`, the first binding cannot be immediately executed
     * since the user may intend to complete the chord with `Ctrl W`. For
     * such cases, a timer is used to allow the chord to be completed. If
     * the chord is not completed before the timeout, the first binding
     * is executed.
     */
    Keymap.prototype.addBinding = function (options) {
        var _this = this;
        // Create the binding for the given options.
        var binding = Private.createBinding(options);
        // Add the key binding to the internal vector.
        this._bindings.pushBack(binding);
        // Emit the `bindingChanged` signal.
        this.bindingChanged.emit({ binding: binding, type: 'added' });
        // Return a disposable which will remove the binding.
        return new disposable_1.DisposableDelegate(function () {
            // Remove the binding from the vector.
            _this._bindings.remove(binding);
            // Emit the `bindingChanged` signal.
            _this.bindingChanged.emit({ binding: binding, type: 'removed' });
        });
    };
    /**
     * Process a `'keydown'` event and invoke a matching key binding.
     *
     * @param event - The event object for a `'keydown'` event.
     *
     * #### Notes
     * This should be called in response to a `'keydown'` event in order
     * to invoke the command for the best matching key binding.
     *
     * The keymap **does not** install its own key event listeners. This
     * allows the application full control over the nodes for which the
     * keymap processes `'keydown'` events.
     */
    Keymap.prototype.processKeydownEvent = function (event) {
        // Bail immediately if playing back keystrokes.
        if (this._replaying) {
            return;
        }
        // Get the normalized keystroke for the event.
        var keystroke = Keymap.keystrokeForKeydownEvent(event, this._layout);
        // If the keystroke is not valid for the keyboard layout, replay
        // any suppressed events and clear the pending state.
        if (!keystroke) {
            this._replayEvents();
            this._clearPendingState();
            return;
        }
        // Add the keystroke to the current key sequence.
        this._keys.push(keystroke);
        // Find the exact and partial matches for the key sequence.
        var _a = Private.match(this._bindings, this._keys, event), exact = _a.exact, partial = _a.partial;
        // If there is no exact match and no partial match, replay
        // any suppressed events and clear the pending state.
        if (!exact && !partial) {
            this._replayEvents();
            this._clearPendingState();
            return;
        }
        // Stop propagation of the event. If there is only a partial match,
        // the event will be replayed if a final exact match never occurs.
        event.preventDefault();
        event.stopPropagation();
        // If there is an exact match but no partial match, the exact match
        // can be dispatched immediately. The pending state is cleared so
        // the next key press starts from the default state.
        if (!partial) {
            this._execute(exact);
            this._clearPendingState();
            return;
        }
        // If there is both an exact match and a partial match, the exact
        // match is stored for future dispatch in case the timer expires
        // before a more specific match is triggered.
        if (exact)
            this._exact = exact;
        // Store the event for possible playback in the future.
        this._events.push(event);
        // (Re)start the timer to dispatch the most recent exact match
        // in case the partial match fails to result in an exact match.
        this._startTimer();
    };
    /**
     * Start or restart the pending timeout.
     */
    Keymap.prototype._startTimer = function () {
        var _this = this;
        this._clearTimer();
        this._timerID = setTimeout(function () {
            _this._onPendingTimeout();
        }, CHORD_TIMEOUT);
    };
    /**
     * Clear the pending timeout.
     */
    Keymap.prototype._clearTimer = function () {
        if (this._timerID !== 0) {
            clearTimeout(this._timerID);
            this._timerID = 0;
        }
    };
    /**
     * Clear the internal pending state.
     */
    Keymap.prototype._clearPendingState = function () {
        this._clearTimer();
        this._exact = null;
        this._keys.length = 0;
        this._events.length = 0;
    };
    /**
     * Replay the events which were suppressed.
     */
    Keymap.prototype._replayEvents = function () {
        if (this._events.length === 0) {
            return;
        }
        this._replaying = true;
        this._events.forEach(Private.replayEvent);
        this._replaying = false;
    };
    /**
     * Execute the command for the given key binding.
     *
     * If the command is disabled, a message will be logged.
     */
    Keymap.prototype._execute = function (binding) {
        var command = binding.command, args = binding.args;
        if (this._commands.isEnabled(command, args)) {
            this._commands.execute(command, args);
        }
        else {
            // TODO - right way to handle disabled command?
            var formatted = binding.keys.map(Keymap.formatKeystroke).join(' ');
            console.log("Command '" + command + "' is disabled (" + formatted + ").");
        }
    };
    /**
     * Handle the partial match timeout.
     */
    Keymap.prototype._onPendingTimeout = function () {
        this._timerID = 0;
        if (this._exact) {
            this._execute(this._exact);
        }
        else {
            this._replayEvents();
        }
        this._clearPendingState();
    };
    return Keymap;
}());
exports.Keymap = Keymap;
// Define the signals for the `Keymap` class.
signaling_1.defineSignal(Keymap.prototype, 'bindingChanged');
signaling_1.defineSignal(Keymap.prototype, 'layoutChanged');
/**
 * The namespace for the `Keymap` class statics.
 */
(function (Keymap) {
    /**
     * Parse a keystroke into its constituent components.
     *
     * @param keystroke - The keystroke of interest.
     *
     * @returns The parsed components of the keystroke.
     *
     * #### Notes
     * The keystroke should be of the form:
     *   `[<modifier 1> [<modifier 2> [<modifier N> ]]]<primary key>`
     *
     * The supported modifiers are: `Accel`, `Alt`, `Cmd`, `Ctrl`, and
     * `Shift`. The `Accel` modifier is translated to `Cmd` on Mac and
     * `Ctrl` on all other platforms.
     *
     * The parsing is tolerant and will not throw exceptions. Notably:
     *   - Duplicate modifiers are ignored.
     *   - Extra primary keys are ignored.
     *   - The order of modifiers and primary key is irrelevant.
     *   - The keystroke parts should be separated by whitespace.
     *   - The keystroke is case sensitive.
     */
    function parseKeystroke(keystroke) {
        var key = '';
        var alt = false;
        var cmd = false;
        var ctrl = false;
        var shift = false;
        for (var _i = 0, _a = keystroke.split(/\s+/); _i < _a.length; _i++) {
            var token = _a[_i];
            if (token === 'Accel') {
                if (platform_1.IS_MAC) {
                    cmd = true;
                }
                else {
                    ctrl = true;
                }
            }
            else if (token === 'Alt') {
                alt = true;
            }
            else if (token === 'Cmd') {
                cmd = true;
            }
            else if (token === 'Ctrl') {
                ctrl = true;
            }
            else if (token === 'Shift') {
                shift = true;
            }
            else if (token.length > 0) {
                key = token;
            }
        }
        return { cmd: cmd, ctrl: ctrl, alt: alt, shift: shift, key: key };
    }
    Keymap.parseKeystroke = parseKeystroke;
    /**
     * Normalize a keystroke into a canonical representation.
     *
     * @param keystroke - The keystroke of interest.
     *
     * @returns The normalized representation of the keystroke.
     *
     * #### Notes
     * This normalizes the keystroke by removing duplicate modifiers and
     * extra primary keys, and assembling the parts in a canonical order.
     *
     * The `Cmd` modifier is ignored on non-Mac platforms.
     */
    function normalizeKeystroke(keystroke) {
        var mods = '';
        var parts = parseKeystroke(keystroke);
        if (parts.ctrl) {
            mods += 'Ctrl ';
        }
        if (parts.alt) {
            mods += 'Alt ';
        }
        if (parts.shift) {
            mods += 'Shift ';
        }
        if (parts.cmd && platform_1.IS_MAC) {
            mods += 'Cmd ';
        }
        return mods + parts.key;
    }
    Keymap.normalizeKeystroke = normalizeKeystroke;
    /**
     * Format a keystroke for display on the local system.
     *
     * @param keystroke - The keystroke of interest.
     *
     * @returns The keystroke formatted for display on the local system.
     *
     * #### Notes
     * On Mac, this replaces the modifiers with the Mac-specific unicode
     * characters. On other systems, this joins the modifiers with `+`.
     */
    function formatKeystroke(keystroke) {
        var mods = '';
        var parts = parseKeystroke(keystroke);
        if (platform_1.IS_MAC) {
            if (parts.ctrl) {
                mods += '\u2303';
            }
            if (parts.alt) {
                mods += '\u2325';
            }
            if (parts.shift) {
                mods += '\u21E7';
            }
            if (parts.cmd) {
                mods += '\u2318';
            }
        }
        else {
            if (parts.ctrl) {
                mods += 'Ctrl+';
            }
            if (parts.alt) {
                mods += 'Alt+';
            }
            if (parts.shift) {
                mods += 'Shift+';
            }
        }
        return mods + parts.key;
    }
    Keymap.formatKeystroke = formatKeystroke;
    /**
     * Create a normalized keystroke for a `'keydown'` event.
     *
     * @param event - The event object for a `'keydown'` event.
     *
     * @param layout - The keyboard layout for looking up the primary key.
     *
     * @returns A normalized keystroke, or an empty string if the event
     *   does not represent a valid keystroke for the given layout.
     */
    function keystrokeForKeydownEvent(event, layout) {
        var key = layout.keyForKeydownEvent(event);
        if (!key) {
            return '';
        }
        var mods = '';
        if (event.ctrlKey) {
            mods += 'Ctrl ';
        }
        if (event.altKey) {
            mods += 'Alt ';
        }
        if (event.shiftKey) {
            mods += 'Shift ';
        }
        if (event.metaKey && platform_1.IS_MAC) {
            mods += 'Cmd ';
        }
        return mods + key;
    }
    Keymap.keystrokeForKeydownEvent = keystrokeForKeydownEvent;
})(Keymap = exports.Keymap || (exports.Keymap = {}));
exports.Keymap = Keymap;
/**
 * The namespace for the private module data.
 */
var Private;
(function (Private) {
    /**
     * Create a binding object from binding options.
     */
    function createBinding(options) {
        return new KeyBinding(options);
    }
    Private.createBinding = createBinding;
    /**
     * Find the bindings which match a key sequence.
     *
     * This returns a match result which contains the best exact matching
     * binding, and a flag which indicates if there are partial matches.
     */
    function match(bindings, keys, event) {
        // Whether a partial match has been found.
        var partial = false;
        // The current best exact match.
        var exact = null;
        // The match distance for the exact match.
        var distance = Infinity;
        // The specificity for the exact match.
        var specificity = 0;
        // Iterate over the bindings and search for the best match.
        for (var i = 0, n = bindings.length; i < n; ++i) {
            // Lookup the current binding.
            var binding = bindings.at(i);
            // Check whether the key binding sequence is a match.
            var sqm = matchSequence(binding.keys, keys);
            // If there is no match, the binding is ignored.
            if (sqm === 0 /* None */) {
                continue;
            }
            // If it is a partial match and no other partial match has been
            // found, ensure the selector matches and set the partial flag.
            if (sqm === 2 /* Partial */) {
                if (!partial && targetDistance(binding.selector, event) !== -1) {
                    partial = true;
                }
                continue;
            }
            // Ignore the match if the selector doesn't match, or if the
            // matched node is farther away than the current best match.
            var td = targetDistance(binding.selector, event);
            if (td === -1 || td > distance) {
                continue;
            }
            // Get the specificity for the selector.
            var sp = selector_1.calculateSpecificity(binding.selector);
            // Update the best match if this match is stronger.
            if (exact === null || td < distance || sp >= specificity) {
                exact = binding;
                distance = td;
                specificity = sp;
            }
        }
        // Return the match result.
        return { exact: exact, partial: partial };
    }
    Private.match = match;
    /**
     * Replay a keyboard event.
     *
     * This synthetically dispatches a clone of the keyboard event.
     */
    function replayEvent(event) {
        event.target.dispatchEvent(cloneKeyboardEvent(event));
    }
    Private.replayEvent = replayEvent;
    /**
     * A concrete implementation of `Keymap.IBinding`.
     */
    var KeyBinding = (function () {
        /**
         * Construct a new binding.
         */
        function KeyBinding(options) {
            this._keys = normalizeKeys(options);
            this._selector = normalizeSelector(options);
            this._command = options.command;
            this._args = options.args || null;
        }
        Object.defineProperty(KeyBinding.prototype, "keys", {
            /**
             * The key sequence for the key binding.
             */
            get: function () {
                return this._keys;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(KeyBinding.prototype, "selector", {
            /**
             * The CSS selector for the key binding.
             */
            get: function () {
                return this._selector;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(KeyBinding.prototype, "command", {
            /**
             * The command to execute when the key binding is matched.
             */
            get: function () {
                return this._command;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(KeyBinding.prototype, "args", {
            /**
             * The arguments for the command.
             */
            get: function () {
                return this._args;
            },
            enumerable: true,
            configurable: true
        });
        return KeyBinding;
    }());
    /**
     * Get the platform-specific normalized keys for an options object.
     *
     * The normalized keys are frozen to prevent further modification.
     */
    function normalizeKeys(options) {
        var keys;
        if (platform_1.IS_WIN) {
            keys = options.winKeys || options.keys;
        }
        else if (platform_1.IS_MAC) {
            keys = options.macKeys || options.keys;
        }
        else {
            keys = options.linuxKeys || options.keys;
        }
        return Object.freeze(keys.map(Keymap.normalizeKeystroke));
    }
    /**
     * Normalize the selector for an options object.
     *
     * This returns the validated first clause of the selector.
     */
    function normalizeSelector(options) {
        return selector_1.validateSelector(options.selector.split(',', 1)[0]);
    }
    ;
    /**
     * Test whether a binding sequence matches a key sequence.
     *
     * Returns a `SequenceMatch` value indicating the type of match.
     */
    function matchSequence(bindKeys, userKeys) {
        if (bindKeys.length < userKeys.length) {
            return 0 /* None */;
        }
        for (var i = 0, n = userKeys.length; i < n; ++i) {
            if (bindKeys[i] !== userKeys[i]) {
                return 0 /* None */;
            }
        }
        if (bindKeys.length > userKeys.length) {
            return 2 /* Partial */;
        }
        return 1 /* Exact */;
    }
    /**
     * Find the distance from the target node to the first matching node.
     *
     * This traverses the event path from `target` to `currentTarget` and
     * computes the distance from `target` to the first node which matches
     * the CSS selector. If no match is found, `-1` is returned.
     */
    function targetDistance(selector, event) {
        var distance = 0;
        var target = event.target;
        var current = event.currentTarget;
        for (; target !== null; target = target.parentElement, ++distance) {
            if (selector_1.matchesSelector(target, selector)) {
                return distance;
            }
            if (target === current) {
                return -1;
            }
        }
        return -1;
    }
    /**
     * Clone a keyboard event.
     */
    function cloneKeyboardEvent(event) {
        // A custom event is required because Chrome nulls out the
        // `keyCode` field in user-generated `KeyboardEvent` types.
        var clone = document.createEvent('Event');
        var bubbles = event.bubbles || true;
        var cancelable = event.cancelable || true;
        clone.initEvent(event.type || 'keydown', bubbles, cancelable);
        clone.key = event.key || '';
        clone.keyCode = event.keyCode || 0;
        clone.which = event.keyCode || 0;
        clone.ctrlKey = event.ctrlKey || false;
        clone.altKey = event.altKey || false;
        clone.shiftKey = event.shiftKey || false;
        clone.metaKey = event.metaKey || false;
        clone.view = event.view || window;
        return clone;
    }
})(Private || (Private = {}));
