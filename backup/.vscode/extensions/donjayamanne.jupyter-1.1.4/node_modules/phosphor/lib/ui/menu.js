"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var searching_1 = require("../algorithm/searching");
var vector_1 = require("../collections/vector");
var messaging_1 = require("../core/messaging");
var signaling_1 = require("../core/signaling");
var query_1 = require("../dom/query");
var sizing_1 = require("../dom/sizing");
var keymap_1 = require("./keymap");
var widget_1 = require("./widget");
/**
 * The class name added to Menu instances.
 */
var MENU_CLASS = 'p-Menu';
/**
 * The class name added to a menu content node.
 */
var CONTENT_CLASS = 'p-Menu-content';
/**
 * The class name added to a menu item node.
 */
var ITEM_CLASS = 'p-Menu-item';
/**
 * The class name added to a menu item icon node.
 */
var ICON_CLASS = 'p-Menu-itemIcon';
/**
 * The class name added to a menu item label node.
 */
var LABEL_CLASS = 'p-Menu-itemLabel';
/**
 * The class name added to a menu item mnemonic node.
 */
var MNEMONIC_CLASS = 'p-Menu-itemMnemonic';
/**
 * The class name added to a menu item shortcut node.
 */
var SHORTCUT_CLASS = 'p-Menu-itemShortcut';
/**
 * The class name added to a menu item submenu icon node.
 */
var SUBMENU_ICON_CLASS = 'p-Menu-itemSubmenuIcon';
/**
 * The class name added to a `'command'` type menu item.
 */
var COMMAND_TYPE_CLASS = 'p-type-command';
/**
 * The class name added to a `'separator'` type menu item.
 */
var SEPARATOR_TYPE_CLASS = 'p-type-separator';
/**
 * The class name added to a `'submenu'` type menu item.
 */
var SUBMENU_TYPE_CLASS = 'p-type-submenu';
/**
 * The class name added to active menu items.
 */
var ACTIVE_CLASS = 'p-mod-active';
/**
 * The class name added to a disabled menu item.
 */
var DISABLED_CLASS = 'p-mod-disabled';
/**
 * The class name added to a toggled menu item.
 */
var TOGGLED_CLASS = 'p-mod-toggled';
/**
 * The class name added to a hidden menu item.
 */
var HIDDEN_CLASS = 'p-mod-hidden';
/**
 * The ms delay for opening and closing a submenu.
 */
var TIMER_DELAY = 300;
/**
 * The horizontal pixel overlap for an open submenu.
 */
var SUBMENU_OVERLAP = 3;
/**
 * A widget which displays menu items as a canonical menu.
 */
var Menu = (function (_super) {
    __extends(Menu, _super);
    /**
     * Construct a new menu.
     *
     * @param options - The options for initializing the menu.
     */
    function Menu(options) {
        var _this = _super.call(this, { node: Private.createNode() }) || this;
        _this._childIndex = -1;
        _this._openTimerID = 0;
        _this._closeTimerID = 0;
        _this._activeIndex = -1;
        _this._childMenu = null;
        _this._parentMenu = null;
        _this._items = new vector_1.Vector();
        _this._nodes = new vector_1.Vector();
        _this.addClass(MENU_CLASS);
        _this.setFlag(widget_1.WidgetFlag.DisallowLayout);
        _this._keymap = options.keymap;
        _this._commands = options.commands;
        _this._renderer = options.renderer || Menu.defaultRenderer;
        return _this;
    }
    /**
     * Dispose of the resources held by the menu.
     */
    Menu.prototype.dispose = function () {
        this.close();
        this._items.clear();
        this._nodes.clear();
        this._keymap = null;
        this._commands = null;
        this._renderer = null;
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(Menu.prototype, "parentMenu", {
        /**
         * Get the parent menu of the menu.
         *
         * #### Notes
         * This will be `null` if the menu is not an open submenu.
         *
         * This is a read-only property.
         */
        get: function () {
            return this._parentMenu;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Menu.prototype, "childMenu", {
        /**
         * Get the child menu of the menu.
         *
         * #### Notes
         * This will be `null` if the menu does not have an open submenu.
         *
         * This is a read-only property.
         */
        get: function () {
            return this._childMenu;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Menu.prototype, "rootMenu", {
        /**
         * Find the root menu of this menu hierarchy.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            var menu = this;
            while (menu._parentMenu) {
                menu = menu._parentMenu;
            }
            return menu;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Menu.prototype, "leafMenu", {
        /**
         * Find the leaf menu of this menu hierarchy.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            var menu = this;
            while (menu._childMenu) {
                menu = menu._childMenu;
            }
            return menu;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Menu.prototype, "contentNode", {
        /**
         * Get the menu content node.
         *
         * #### Notes
         * This is the node which holds the menu item nodes.
         *
         * Modifying this node directly can lead to undefined behavior.
         *
         * This is a read-only property.
         */
        get: function () {
            return this.node.getElementsByClassName(CONTENT_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Menu.prototype, "commands", {
        /**
         * The command registry used by the menu.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._commands;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Menu.prototype, "keymap", {
        /**
         * The keymap used by the menu.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._keymap;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Menu.prototype, "renderer", {
        /**
         * The renderer used by the menu.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._renderer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Menu.prototype, "items", {
        /**
         * A read-only sequence of the menu items in the menu.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._items;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Menu.prototype, "activeItem", {
        /**
         * Get the currently active menu item.
         *
         * #### Notes
         * This will be `null` if no menu item is active.
         */
        get: function () {
            var i = this._activeIndex;
            return i !== -1 ? this._items.at(i) : null;
        },
        /**
         * Set the currently active menu item.
         *
         * #### Notes
         * If the item cannot be activated, the item will be set to `null`.
         */
        set: function (value) {
            this.activeIndex = searching_1.indexOf(this._items, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Menu.prototype, "activeIndex", {
        /**
         * Get the index of the currently active menu item.
         *
         * #### Notes
         * This will be `-1` if no menu item is active.
         */
        get: function () {
            return this._activeIndex;
        },
        /**
         * Set the index of the currently active menu item.
         *
         * #### Notes
         * If the item cannot be activated, the index will be set to `-1`.
         */
        set: function (value) {
            // Coerce the value to an index.
            var i = Math.floor(value);
            if (i < 0 || i >= this._items.length) {
                i = -1;
            }
            // Ensure the item can be activated.
            if (i !== -1) {
                var item = this._items.at(i);
                if (item.type === 'separator' || !item.isEnabled || !item.isVisible) {
                    i = -1;
                }
            }
            // Bail early if the index will not change.
            if (this._activeIndex === i) {
                return;
            }
            // Remove the active class from the old node.
            if (this._activeIndex !== -1) {
                var node = this._nodes.at(this._activeIndex);
                node.classList.remove(ACTIVE_CLASS);
            }
            // Add the active class to the new node.
            if (i !== -1) {
                var node = this._nodes.at(i);
                node.classList.add(ACTIVE_CLASS);
            }
            // Update the active index.
            this._activeIndex = i;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Activate the next selectable item in the menu.
     *
     * #### Notes
     * If no item is selectable, the index will be set to `-1`.
     */
    Menu.prototype.activateNextItem = function () {
        var n = this._items.length;
        var j = this._activeIndex + 1;
        for (var i = 0; i < n; ++i) {
            var k = (i + j) % n;
            var item = this._items.at(k);
            if (item.type !== 'separator' && item.isEnabled && item.isVisible) {
                this.activeIndex = k;
                return;
            }
        }
        this.activeIndex = -1;
    };
    /**
     * Activate the previous selectable item in the menu.
     *
     * #### Notes
     * If no item is selectable, the index will be set to `-1`.
     */
    Menu.prototype.activatePreviousItem = function () {
        var n = this._items.length;
        var ai = this._activeIndex;
        var j = ai <= 0 ? n - 1 : ai - 1;
        for (var i = 0; i < n; ++i) {
            var k = (j - i + n) % n;
            var item = this._items.at(k);
            if (item.type !== 'separator' && item.isEnabled && item.isVisible) {
                this.activeIndex = k;
                return;
            }
        }
        this.activeIndex = -1;
    };
    /**
     * Trigger the active menu item.
     *
     * #### Notes
     * If the active item is a submenu, it will be opened and the first
     * item will be activated.
     *
     * If the active item is a command, the command will be executed.
     *
     * If the menu is not attached, this is a no-op.
     *
     * If there is no active item, this is a no-op.
     */
    Menu.prototype.triggerActiveItem = function () {
        // Bail if the menu is not attached.
        if (!this.isAttached) {
            return;
        }
        // Bail if there is no active item.
        var item = this.activeItem;
        if (!item) {
            return;
        }
        // Cancel the pending timers.
        this._cancelOpenTimer();
        this._cancelCloseTimer();
        // If the item is a submenu, open it.
        if (item.type === 'submenu') {
            this._openChildMenu(true);
            return;
        }
        // Close the root menu before executing the command.
        this.rootMenu.close();
        // Execute the command for the item.
        var command = item.command, args = item.args;
        if (this._commands.isEnabled(command, args)) {
            this._commands.execute(command, args);
        }
        else {
            // TODO - is this the right logging here?
            console.log("Command '" + command + "' is disabled.");
        }
    };
    /**
     * Add a menu item to the end of the menu.
     *
     * @param options - The options for creating the menu item.
     *
     * @returns The menu item added to the menu.
     */
    Menu.prototype.addItem = function (options) {
        return this.insertItem(this._items.length, options);
    };
    /**
     * Insert a menu item into the menu at the specified index.
     *
     * @param index - The index at which to insert the item.
     *
     * @param options - The options for creating the menu item.
     *
     * @returns The menu item added to the menu.
     *
     * #### Notes
     * The index will be clamped to the bounds of the items.
     */
    Menu.prototype.insertItem = function (index, options) {
        // Close the menu if it's attached.
        if (this.isAttached) {
            this.close();
        }
        // Reset the active index.
        this.activeIndex = -1;
        // Clamp the insert index to the vector bounds.
        var i = Math.max(0, Math.min(Math.floor(index), this._items.length));
        // Create the item for the options.
        var item = Private.createItem(this._commands, this._keymap, options);
        // Create the node for the item. It will be initialized on open.
        var node = this._renderer.createItemNode();
        // Insert the item and node into the vectors.
        this._items.insert(i, item);
        this._nodes.insert(i, node);
        // Look up the next sibling node.
        var ref = i + 1 < this._nodes.length ? this._nodes.at(i + 1) : null;
        // Insert the node into the content node.
        this.contentNode.insertBefore(node, ref);
        // Return the item added to the menu.
        return item;
    };
    /**
     * Remove an item from the menu.
     *
     * @param item - The item to remove from the menu.
     *
     * @returns The index occupied by the item, or `-1` if the item
     *   was not contained in the menu.
     */
    Menu.prototype.removeItem = function (item) {
        var index = searching_1.indexOf(this._items, item);
        if (index !== -1)
            this.removeItemAt(index);
        return index;
    };
    /**
     * Remove the item at a given index from the menu.
     *
     * @param index - The index of the item to remove.
     *
     * @returns The item occupying the index, or `null` if the index
     *   is out of range.
     */
    Menu.prototype.removeItemAt = function (index) {
        // Bail if the index is out of range.
        var i = Math.floor(index);
        if (i < 0 || i >= this._items.length) {
            return null;
        }
        // Close the menu if it's attached.
        if (this.isAttached) {
            this.close();
        }
        // Reset the active index.
        this.activeIndex = -1;
        // Remove the node and items from the vectors.
        var node = this._nodes.removeAt(i);
        var item = this._items.removeAt(i);
        // Remove the node from the content node.
        this.contentNode.removeChild(node);
        // Return the removed item.
        return item;
    };
    /**
     * Remove all menu items from the menu.
     */
    Menu.prototype.clearItems = function () {
        // Close the menu if it's attached.
        if (this.isAttached) {
            this.close();
        }
        // Reset the active index.
        this.activeIndex = -1;
        // Clear the item and node vectors.
        this._items.clear();
        this._nodes.clear();
        // Clear the content node.
        this.contentNode.textContent = '';
    };
    /**
     * Open the menu at the specified location.
     *
     * @param x - The client X coordinate of the menu location.
     *
     * @param y - The client Y coordinate of the menu location.
     *
     * @param options - The additional options for opening the menu.
     *
     * #### Notes
     * The menu will be opened at the given location unless it will not
     * fully fit on the screen. If it will not fit, it will be adjusted
     * to fit naturally on the screen.
     *
     * This is a no-op if the menu is already attached to the DOM.
     */
    Menu.prototype.open = function (x, y, options) {
        if (options === void 0) { options = {}; }
        // Bail early if the menu is already attached.
        if (this.isAttached) {
            return;
        }
        // Extract the position options.
        var forceX = options.forceX || false;
        var forceY = options.forceY || false;
        // Open the menu as a root menu.
        Private.openRootMenu(this, x, y, forceX, forceY);
        // Activate the menu to accept keyboard input.
        this.activate();
    };
    /**
     * Handle the DOM events for the menu.
     *
     * @param event - The DOM event sent to the menu.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the menu's DOM nodes. It should
     * not be called directly by user code.
     */
    Menu.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'keydown':
                this._evtKeyDown(event);
                break;
            case 'mouseup':
                this._evtMouseUp(event);
                break;
            case 'mousemove':
                this._evtMouseMove(event);
                break;
            case 'mouseenter':
                this._evtMouseEnter(event);
                break;
            case 'mouseleave':
                this._evtMouseLeave(event);
                break;
            case 'mousedown':
                this._evtMouseDown(event);
                break;
            case 'contextmenu':
                event.preventDefault();
                event.stopPropagation();
                break;
        }
    };
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    Menu.prototype.onAfterAttach = function (msg) {
        this.node.addEventListener('keydown', this);
        this.node.addEventListener('mouseup', this);
        this.node.addEventListener('mousemove', this);
        this.node.addEventListener('mouseenter', this);
        this.node.addEventListener('mouseleave', this);
        this.node.addEventListener('contextmenu', this);
        document.addEventListener('mousedown', this, true);
    };
    /**
     * A message handler invoked on a `'before-detach'` message.
     */
    Menu.prototype.onBeforeDetach = function (msg) {
        this.node.removeEventListener('keydown', this);
        this.node.removeEventListener('mouseup', this);
        this.node.removeEventListener('mousemove', this);
        this.node.removeEventListener('mouseenter', this);
        this.node.removeEventListener('mouseleave', this);
        this.node.removeEventListener('contextmenu', this);
        document.removeEventListener('mousedown', this, true);
    };
    /**
     * A message handler invoked on an `'activate-request'` message.
     */
    Menu.prototype.onActivateRequest = function (msg) {
        if (this.isAttached)
            this.node.focus();
    };
    /**
     * A message handler invoked on an `'update-request'` message.
     */
    Menu.prototype.onUpdateRequest = function (msg) {
        // TODO - currently, an 'update-request' message is sent to a menu
        // just before it is opened. This ensures it is current when shown
        // without needing to subscribe to any commands or keymap signals.
        // Often, the update will be unnecessary. If it becomes an issue
        // for performance, the menu can maintain a dirty flag.
        // Fetch common variables.
        var items = this._items;
        var nodes = this._nodes;
        var renderer = this._renderer;
        // Update the state of the item nodes.
        for (var i = 0, n = items.length; i < n; ++i) {
            renderer.updateItemNode(nodes.at(i), items.at(i));
        }
        // Add the active class to the active item.
        if (this._activeIndex !== -1) {
            nodes.at(this._activeIndex).classList.add(ACTIVE_CLASS);
        }
        // Hide the extra separator nodes.
        Private.hideExtraSeparators(nodes, items);
    };
    /**
     * A message handler invoked on a `'close-request'` message.
     */
    Menu.prototype.onCloseRequest = function (msg) {
        // Cancel the pending timers.
        this._cancelOpenTimer();
        this._cancelCloseTimer();
        // Reset the active index.
        this.activeIndex = -1;
        // Close any open child menu.
        var childMenu = this._childMenu;
        if (childMenu) {
            this._childIndex = -1;
            this._childMenu = null;
            childMenu._parentMenu = null;
            childMenu.close();
        }
        // Remove this menu from its parent and activate the parent.
        var parentMenu = this._parentMenu;
        if (parentMenu) {
            this._parentMenu = null;
            parentMenu._cancelOpenTimer();
            parentMenu._cancelCloseTimer();
            parentMenu._childIndex = -1;
            parentMenu._childMenu = null;
            parentMenu.activate();
        }
        // Emit the `aboutToClose` signal if the menu is attached.
        if (this.isAttached) {
            this.aboutToClose.emit(void 0);
        }
        // Finish closing the menu.
        _super.prototype.onCloseRequest.call(this, msg);
    };
    /**
     * Handle the `'keydown'` event for the menu.
     *
     * #### Notes
     * This listener is attached to the menu node.
     */
    Menu.prototype._evtKeyDown = function (event) {
        // A menu handles all keydown events.
        event.preventDefault();
        event.stopPropagation();
        // Fetch the key code for the event.
        var kc = event.keyCode;
        // Enter
        if (kc === 13) {
            this.triggerActiveItem();
            return;
        }
        // Escape
        if (kc === 27) {
            this.close();
            return;
        }
        // Left Arrow
        if (kc === 37) {
            if (this._parentMenu) {
                this.close();
            }
            else {
                this.menuRequested.emit('previous');
            }
            return;
        }
        // Up Arrow
        if (kc === 38) {
            this.activatePreviousItem();
            return;
        }
        // Right Arrow
        if (kc === 39) {
            var item = this.activeItem;
            if (item && item.type === 'submenu') {
                this.triggerActiveItem();
            }
            else {
                this.rootMenu.menuRequested.emit('next');
            }
            return;
        }
        // Down Arrow
        if (kc === 40) {
            this.activateNextItem();
            return;
        }
        // The following code activates an item by mnemonic.
        // Get the pressed key character for the current layout.
        var key = this._keymap.layout.keyForKeydownEvent(event);
        // Bail if the key is not valid for the current layout.
        if (!key) {
            return;
        }
        // Normalize the case of the key.
        key = key.toUpperCase();
        // Setup the storage for the search results.
        var mnIndex = -1;
        var autoIndex = -1;
        var mnMultiple = false;
        // Search for the best mnemonic item. This searches the menu items
        // starting at the active index and finds the following:
        //   - the index of the first matching mnemonic item
        //   - whether there are multiple matching mnemonic items
        //   - the index of the first item with no mnemonic, but
        //     which has a matching first character
        var n = this._items.length;
        var j = this._activeIndex + 1;
        for (var i = 0; i < n; ++i) {
            var k = (i + j) % n;
            var item = this._items.at(k);
            if (item.type === 'separator' || !item.isEnabled || !item.isVisible) {
                continue;
            }
            var label = item.label;
            if (label.length === 0) {
                continue;
            }
            var mn = item.mnemonic;
            if (mn >= 0 && mn < label.length) {
                if (label[mn].toUpperCase() === key) {
                    if (mnIndex === -1) {
                        mnIndex = k;
                    }
                    else {
                        mnMultiple = true;
                    }
                }
            }
            else if (autoIndex === -1) {
                if (label[0].toUpperCase() === key) {
                    autoIndex = k;
                }
            }
        }
        // Handle the requested mnemonic based on the search results.
        // If exactly one mnemonic is matched, that item is triggered.
        // Otherwise, the next mnemonic is activated if available,
        // followed by the auto mnemonic if available.
        if (mnIndex !== -1 && !mnMultiple) {
            this.activeIndex = mnIndex;
            this.triggerActiveItem();
        }
        else if (mnIndex !== -1) {
            this.activeIndex = mnIndex;
        }
        else if (autoIndex !== -1) {
            this.activeIndex = autoIndex;
        }
    };
    /**
     * Handle the `'mouseup'` event for the menu.
     *
     * #### Notes
     * This listener is attached to the menu node.
     */
    Menu.prototype._evtMouseUp = function (event) {
        if (event.button !== 0) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        this.triggerActiveItem();
    };
    /**
     * Handle the `'mousemove'` event for the menu.
     *
     * #### Notes
     * This listener is attached to the menu node.
     */
    Menu.prototype._evtMouseMove = function (event) {
        // Hit test the item nodes for the item under the mouse.
        var x = event.clientX;
        var y = event.clientY;
        var i = searching_1.findIndex(this._nodes, function (node) { return query_1.hitTest(node, x, y); });
        // Bail early if the mouse is already over the active index.
        if (i === this._activeIndex) {
            return;
        }
        // Update and coerce the active index.
        this.activeIndex = i;
        i = this.activeIndex;
        // If the index is the current child index, cancel the timers.
        if (i === this._childIndex) {
            this._cancelOpenTimer();
            this._cancelCloseTimer();
            return;
        }
        // If a child menu is currently open, start the close timer.
        if (this._childIndex !== -1) {
            this._startCloseTimer();
        }
        // Cancel the open timer to give a full delay for opening.
        this._cancelOpenTimer();
        // Bail if the active item is not a valid submenu item.
        var item = this.activeItem;
        if (!item || item.type !== 'submenu' || !item.menu) {
            return;
        }
        // Start the open timer to open the active item submenu.
        this._startOpenTimer();
    };
    /**
     * Handle the `'mouseenter'` event for the menu.
     *
     * #### Notes
     * This listener is attached to the menu node.
     */
    Menu.prototype._evtMouseEnter = function (event) {
        // Synchronize the active ancestor items.
        for (var menu = this._parentMenu; menu; menu = menu._parentMenu) {
            menu._cancelOpenTimer();
            menu._cancelCloseTimer();
            menu.activeIndex = menu._childIndex;
        }
    };
    /**
     * Handle the `'mouseleave'` event for the menu.
     *
     * #### Notes
     * This listener is attached to the menu node.
     */
    Menu.prototype._evtMouseLeave = function (event) {
        // Cancel any pending submenu opening.
        this._cancelOpenTimer();
        // If there is no open child menu, just reset the active index.
        if (!this._childMenu) {
            this.activeIndex = -1;
            return;
        }
        // If the mouse is over the child menu, cancel the close timer.
        if (query_1.hitTest(this._childMenu.node, event.clientX, event.clientY)) {
            this._cancelCloseTimer();
            return;
        }
        // Otherwise, reset the active index and start the close timer.
        this.activeIndex = -1;
        this._startCloseTimer();
    };
    /**
     * Handle the `'mousedown'` event for the menu.
     *
     * #### Notes
     * This listener is attached to the document node.
     */
    Menu.prototype._evtMouseDown = function (event) {
        // Bail if the menu is not a root menu.
        if (this._parentMenu) {
            return;
        }
        // The mouse button which is pressed is irrelevant. If the press
        // is not on a menu, the entire hierarchy is closed and the event
        // is allowed to propagate. This allows other code to act on the
        // event, such as focusing the clicked element.
        if (Private.hitTestMenus(this, event.clientX, event.clientY)) {
            event.preventDefault();
            event.stopPropagation();
        }
        else {
            this.close();
        }
    };
    /**
     * Open the child menu at the active index immediately.
     *
     * If a different child menu is already open, it will be closed,
     * even if the active item is not a valid submenu.
     */
    Menu.prototype._openChildMenu = function (activateFirst) {
        if (activateFirst === void 0) { activateFirst = false; }
        // If the item is not a valid submenu, close the child menu.
        var item = this.activeItem;
        if (!item || item.type !== 'submenu' || !item.menu) {
            this._closeChildMenu();
            return;
        }
        // Do nothing if the child menu will not change.
        var menu = item.menu;
        if (menu === this._childMenu) {
            return;
        }
        // Ensure the current child menu is closed.
        this._closeChildMenu();
        // Update the private child state.
        this._childMenu = menu;
        this._childIndex = this._activeIndex;
        // Set the parent menu reference for the child.
        menu._parentMenu = this;
        // Open the submenu at the active node.
        Private.openSubmenu(menu, this._nodes.at(this._activeIndex));
        // Activate the first item if desired.
        if (activateFirst) {
            menu.activeIndex = -1;
            menu.activateNextItem();
        }
        // Activate the child menu.
        menu.activate();
    };
    /**
     * Close the child menu immediately.
     *
     * This is a no-op if a child menu is not open.
     */
    Menu.prototype._closeChildMenu = function () {
        if (this._childMenu) {
            this._childMenu.close();
        }
    };
    /**
     * Start the open timer, unless it is already pending.
     */
    Menu.prototype._startOpenTimer = function () {
        var _this = this;
        if (this._openTimerID === 0) {
            this._openTimerID = setTimeout(function () {
                _this._openTimerID = 0;
                _this._openChildMenu();
            }, TIMER_DELAY);
        }
    };
    /**
     * Start the close timer, unless it is already pending.
     */
    Menu.prototype._startCloseTimer = function () {
        var _this = this;
        if (this._closeTimerID === 0) {
            this._closeTimerID = setTimeout(function () {
                _this._closeTimerID = 0;
                _this._closeChildMenu();
            }, TIMER_DELAY);
        }
    };
    /**
     * Cancel the open timer, if the timer is pending.
     */
    Menu.prototype._cancelOpenTimer = function () {
        if (this._openTimerID !== 0) {
            clearTimeout(this._openTimerID);
            this._openTimerID = 0;
        }
    };
    /**
     * Cancel the close timer, if the timer is pending.
     */
    Menu.prototype._cancelCloseTimer = function () {
        if (this._closeTimerID !== 0) {
            clearTimeout(this._closeTimerID);
            this._closeTimerID = 0;
        }
    };
    return Menu;
}(widget_1.Widget));
exports.Menu = Menu;
// Define the signals for the `Menu` class.
signaling_1.defineSignal(Menu.prototype, 'aboutToClose');
signaling_1.defineSignal(Menu.prototype, 'menuRequested');
/**
 * The namespace for the `Menu` class statics.
 */
(function (Menu) {
    /**
     * The default implementation of `IRenderer`.
     */
    var Renderer = (function () {
        function Renderer() {
        }
        /**
         * Create a node for a menu item.
         *
         * @returns A new node for a menu item.
         */
        Renderer.prototype.createItemNode = function () {
            var node = document.createElement('li');
            var icon = document.createElement('div');
            var label = document.createElement('div');
            var shortcut = document.createElement('div');
            var submenu = document.createElement('div');
            node.className = ITEM_CLASS;
            icon.className = ICON_CLASS;
            label.className = LABEL_CLASS;
            shortcut.className = SHORTCUT_CLASS;
            submenu.className = SUBMENU_ICON_CLASS;
            node.appendChild(icon);
            node.appendChild(label);
            node.appendChild(shortcut);
            node.appendChild(submenu);
            return node;
        };
        /**
         * Update an item node to reflect the state of a menu item.
         *
         * @param node - A node created by a call to `createItemNode`.
         *
         * @param item - The menu item holding the data for the node.
         */
        Renderer.prototype.updateItemNode = function (node, item) {
            // Setup the initial item class.
            var itemClass = ITEM_CLASS;
            // Add the item type to the item class.
            switch (item.type) {
                case 'command':
                    itemClass += " " + COMMAND_TYPE_CLASS;
                    break;
                case 'submenu':
                    itemClass += " " + SUBMENU_TYPE_CLASS;
                    break;
                case 'separator':
                    itemClass += " " + SEPARATOR_TYPE_CLASS;
                    break;
            }
            // Add the boolean states to the item class.
            if (!item.isEnabled) {
                itemClass += " " + DISABLED_CLASS;
            }
            if (item.isToggled) {
                itemClass += " " + TOGGLED_CLASS;
            }
            if (!item.isVisible) {
                itemClass += " " + HIDDEN_CLASS;
            }
            // Add the extra class name(s) to the item class.
            var extraItemClass = item.className;
            if (extraItemClass) {
                itemClass += " " + extraItemClass;
            }
            // Setup the initial icon class.
            var iconClass = ICON_CLASS;
            // Add the extra class name(s) to the icon class.
            var extraIconClass = item.icon;
            if (extraIconClass) {
                iconClass += " " + extraIconClass;
            }
            // Generate the formatted label HTML.
            var labelHTML = this.formatLabel(item.label, item.mnemonic);
            // Generate the formatted shortcut text.
            var shortcutText = this.formatShortcut(item.keyBinding);
            // Extract the relevant child nodes.
            var icon = node.firstChild;
            var label = icon.nextSibling;
            var shortcut = label.nextSibling;
            // Set the command ID in the data set.
            if (item.type === 'command') {
                node.setAttribute('data-command', item.command);
            }
            else {
                node.removeAttribute('data-command');
            }
            // Update the rest of the node state.
            node.title = item.caption;
            node.className = itemClass;
            icon.className = iconClass;
            label.innerHTML = labelHTML;
            shortcut.textContent = shortcutText;
        };
        /**
         * Format a label into HTML for display.
         *
         * @param label - The label text of interest.
         *
         * @param mnemonic - The index of the mnemonic character.
         *
         * @return The formatted label HTML for display.
         */
        Renderer.prototype.formatLabel = function (label, mnemonic) {
            // If the index is out of range, do not modify the label.
            if (mnemonic < 0 || mnemonic >= label.length) {
                return label;
            }
            // Split the label into parts.
            var pref = label.slice(0, mnemonic);
            var suff = label.slice(mnemonic + 1);
            var char = label[mnemonic];
            // Join the label with the mnemonic span.
            return pref + "<span class=\"" + MNEMONIC_CLASS + "\">" + char + "</span>" + suff;
        };
        /**
         * Format a key binding into shortcut text for display.
         *
         * @param binding - The key binding to format. This may be `null`.
         *
         * @returns The formatted shortcut text for display.
         */
        Renderer.prototype.formatShortcut = function (binding) {
            return binding ? binding.keys.map(keymap_1.Keymap.formatKeystroke).join(' ') : '';
        };
        return Renderer;
    }());
    Menu.Renderer = Renderer;
    /**
     * The default `Renderer` instance.
     */
    Menu.defaultRenderer = new Renderer();
})(Menu = exports.Menu || (exports.Menu = {}));
exports.Menu = Menu;
/**
 * The namespace for the private module data.
 */
var Private;
(function (Private) {
    /**
     * Create the DOM node for a menu.
     */
    function createNode() {
        var node = document.createElement('div');
        var content = document.createElement('ul');
        content.className = CONTENT_CLASS;
        node.appendChild(content);
        node.tabIndex = -1;
        return node;
    }
    Private.createNode = createNode;
    /**
     * Create a new menu item from a keymap, commands, and options.
     */
    function createItem(commands, keymap, options) {
        return new MenuItem(commands, keymap, options);
    }
    Private.createItem = createItem;
    /**
     * Hit test a menu hierarchy starting at the given root.
     */
    function hitTestMenus(menu, x, y) {
        for (; menu; menu = menu.childMenu) {
            if (query_1.hitTest(menu.node, x, y))
                return true;
        }
        return false;
    }
    Private.hitTestMenus = hitTestMenus;
    /**
     * Hide the extra and redundant separator nodes.
     */
    function hideExtraSeparators(nodes, items) {
        // Hide the leading separators.
        var k1 = 0;
        var n = items.length;
        for (; k1 < n; ++k1) {
            var item = items.at(k1);
            if (!item.isVisible) {
                continue;
            }
            if (item.type !== 'separator') {
                break;
            }
            nodes.at(k1).classList.add(HIDDEN_CLASS);
        }
        // Hide the trailing separators.
        var k2 = n - 1;
        for (; k2 >= 0; --k2) {
            var item = items.at(k2);
            if (!item.isVisible) {
                continue;
            }
            if (item.type !== 'separator') {
                break;
            }
            nodes.at(k2).classList.add(HIDDEN_CLASS);
        }
        // Hide the remaining consecutive separators.
        var hide = false;
        while (++k1 < k2) {
            var item = items.at(k1);
            if (!item.isVisible) {
                continue;
            }
            if (item.type !== 'separator') {
                hide = false;
            }
            else if (hide) {
                nodes.at(k1).classList.add(HIDDEN_CLASS);
            }
            else {
                hide = true;
            }
        }
    }
    Private.hideExtraSeparators = hideExtraSeparators;
    /**
     * Open a menu as a root menu at the target location.
     */
    function openRootMenu(menu, x, y, forceX, forceY) {
        // Ensure the menu is updated before opening.
        messaging_1.sendMessage(menu, widget_1.WidgetMessage.UpdateRequest);
        // Get the current position and size of the main viewport.
        var px = window.pageXOffset;
        var py = window.pageYOffset;
        var cw = document.documentElement.clientWidth;
        var ch = document.documentElement.clientHeight;
        // Compute the maximum allowed height for the menu.
        var maxHeight = ch - (forceY ? y : 0);
        // Fetch common variables.
        var node = menu.node;
        var style = node.style;
        // Clear the menu geometry and prepare it for measuring.
        style.top = '';
        style.left = '';
        style.width = '';
        style.height = '';
        style.visibility = 'hidden';
        style.maxHeight = maxHeight + "px";
        // Attach the menu to the document.
        widget_1.Widget.attach(menu, document.body);
        // Expand the menu width by the scrollbar size, if present.
        if (node.scrollHeight > maxHeight) {
            style.width = 2 * node.offsetWidth - node.clientWidth + "px";
        }
        // Measure the size of the menu.
        var _a = node.getBoundingClientRect(), width = _a.width, height = _a.height;
        // Adjust the X position of the menu to fit on-screen.
        if (!forceX && (x + width > px + cw)) {
            x = px + cw - width;
        }
        // Adjust the Y position of the menu to fit on-screen.
        if (!forceY && (y + height > py + ch)) {
            if (y > py + ch) {
                y = py + ch - height;
            }
            else {
                y = y - height;
            }
        }
        // Update the position of the menu to the computed position.
        style.top = Math.max(0, y) + "px";
        style.left = Math.max(0, x) + "px";
        // Finally, make the menu visible on the screen.
        style.visibility = '';
    }
    Private.openRootMenu = openRootMenu;
    /**
     * Open a menu as a submenu using an item node for positioning.
     */
    function openSubmenu(menu, itemNode) {
        // Ensure the menu is updated before opening.
        messaging_1.sendMessage(menu, widget_1.WidgetMessage.UpdateRequest);
        // Get the current position and size of the main viewport.
        var px = window.pageXOffset;
        var py = window.pageYOffset;
        var cw = document.documentElement.clientWidth;
        var ch = document.documentElement.clientHeight;
        // Compute the maximum allowed height for the menu.
        var maxHeight = ch;
        // Fetch common variables.
        var node = menu.node;
        var style = node.style;
        // Clear the menu geometry and prepare it for measuring.
        style.top = '';
        style.left = '';
        style.width = '';
        style.height = '';
        style.visibility = 'hidden';
        style.maxHeight = maxHeight + "px";
        // Attach the menu to the document.
        widget_1.Widget.attach(menu, document.body);
        // Expand the menu width by the scrollbar size, if present.
        if (node.scrollHeight > maxHeight) {
            style.width = 2 * node.offsetWidth - node.clientWidth + "px";
        }
        // Measure the size of the menu.
        var _a = node.getBoundingClientRect(), width = _a.width, height = _a.height;
        // Compute the box sizing for the menu.
        var box = sizing_1.boxSizing(menu.node);
        // Get the bounding rect for the target item node.
        var itemRect = itemNode.getBoundingClientRect();
        // Compute the target X position.
        var x = itemRect.right - SUBMENU_OVERLAP;
        // Adjust the X position to fit on the screen.
        if (x + width > px + cw) {
            x = itemRect.left + SUBMENU_OVERLAP - width;
        }
        // Compute the target Y position.
        var y = itemRect.top - box.borderTop - box.paddingTop;
        // Adjust the Y position to fit on the screen.
        if (y + height > py + ch) {
            y = itemRect.bottom + box.borderBottom + box.paddingBottom - height;
        }
        // Update the position of the menu to the computed position.
        style.top = Math.max(0, y) + "px";
        style.left = Math.max(0, x) + "px";
        // Finally, make the menu visible on the screen.
        style.visibility = '';
    }
    Private.openSubmenu = openSubmenu;
    /**
     * A concrete implementation of `Menu.IItem`.
     */
    var MenuItem = (function () {
        /**
         * Construct a new menu item.
         */
        function MenuItem(commands, keymap, options) {
            this._commands = commands;
            this._keymap = keymap;
            this._type = options.type || 'command';
            this._command = options.command || '';
            this._args = options.args || null;
            this._menu = options.menu || null;
        }
        Object.defineProperty(MenuItem.prototype, "type", {
            /**
             * The type of the menu item.
             */
            get: function () {
                return this._type;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuItem.prototype, "command", {
            /**
             * The command to execute when the item is triggered.
             */
            get: function () {
                return this._command;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuItem.prototype, "args", {
            /**
             * The arguments for the command.
             */
            get: function () {
                return this._args;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuItem.prototype, "menu", {
            /**
             * The menu for a `'submenu'` type item.
             */
            get: function () {
                return this._menu;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuItem.prototype, "label", {
            /**
             * The display label for the menu item.
             */
            get: function () {
                if (this._type === 'command') {
                    return this._commands.label(this._command, this._args);
                }
                if (this._type === 'submenu' && this._menu) {
                    return this._menu.title.label;
                }
                return '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuItem.prototype, "mnemonic", {
            /**
             * The mnemonic index for the menu item.
             */
            get: function () {
                if (this._type === 'command') {
                    return this._commands.mnemonic(this._command, this._args);
                }
                if (this._type === 'submenu' && this._menu) {
                    return this._menu.title.mnemonic;
                }
                return -1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuItem.prototype, "icon", {
            /**
             * The icon class for the menu item.
             */
            get: function () {
                if (this._type === 'command') {
                    return this._commands.icon(this._command, this._args);
                }
                if (this._type === 'submenu' && this._menu) {
                    return this._menu.title.icon;
                }
                return '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuItem.prototype, "caption", {
            /**
             * The display caption for the menu item.
             */
            get: function () {
                if (this._type === 'command') {
                    return this._commands.caption(this._command, this._args);
                }
                if (this._type === 'submenu' && this._menu) {
                    return this._menu.title.caption;
                }
                return '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuItem.prototype, "className", {
            /**
             * The extra class name for the menu item.
             */
            get: function () {
                if (this._type === 'command') {
                    return this._commands.className(this._command, this._args);
                }
                if (this._type === 'submenu' && this._menu) {
                    return this._menu.title.className;
                }
                return '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuItem.prototype, "isEnabled", {
            /**
             * Whether the menu item is enabled.
             */
            get: function () {
                if (this._type === 'command') {
                    return this._commands.isEnabled(this._command, this._args);
                }
                if (this._type === 'submenu') {
                    return this._menu !== null;
                }
                return true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuItem.prototype, "isToggled", {
            /**
             * Whether the menu item is toggled.
             */
            get: function () {
                if (this._type === 'command') {
                    return this._commands.isToggled(this._command, this._args);
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuItem.prototype, "isVisible", {
            /**
             * Whether the menu item is visible.
             */
            get: function () {
                if (this._type === 'command') {
                    return this._commands.isVisible(this._command, this._args);
                }
                if (this._type === 'submenu') {
                    return this._menu !== null;
                }
                return true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuItem.prototype, "keyBinding", {
            /**
             * The key binding for the menu item.
             */
            get: function () {
                if (this._type === 'command') {
                    return this._keymap.findBinding(this._command, this._args);
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        return MenuItem;
    }());
})(Private || (Private = {}));
