"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
var iteration_1 = require("../algorithm/iteration");
var searching_1 = require("../algorithm/searching");
var vector_1 = require("../collections/vector");
var messaging_1 = require("../core/messaging");
var signaling_1 = require("../core/signaling");
var mimedata_1 = require("../core/mimedata");
var cursor_1 = require("../dom/cursor");
var dragdrop_1 = require("../dom/dragdrop");
var platform_1 = require("../dom/platform");
var query_1 = require("../dom/query");
var sizing_1 = require("../dom/sizing");
var boxengine_1 = require("./boxengine");
var focustracker_1 = require("./focustracker");
var tabbar_1 = require("./tabbar");
var widget_1 = require("./widget");
/**
 * The class name added to a DockPanel instance.
 */
var DOCK_PANEL_CLASS = 'p-DockPanel';
/**
 * The class name added to DockPanel widgets.
 */
var WIDGET_CLASS = 'p-DockPanel-widget';
/**
 * The class name added to a DockPanel tab bar.
 */
var TAB_BAR_CLASS = 'p-DockPanel-tabBar';
/**
 * The class name added to a DockPanel handle.
 */
var HANDLE_CLASS = 'p-DockPanel-handle';
/**
 * The class name added to a DockPanel overlay.
 */
var OVERLAY_CLASS = 'p-DockPanel-overlay';
/**
 * The class name added to hidden entities.
 */
var HIDDEN_CLASS = 'p-mod-hidden';
/**
 * The class name added to horizontal handles.
 */
var HORIZONTAL_CLASS = 'p-mod-horizontal';
/**
 * The class name added to vertical handles.
 */
var VERTICAL_CLASS = 'p-mod-vertical';
/**
 * The factory MIME type supported by the dock panel.
 */
var FACTORY_MIME = 'application/vnd.phosphor.widget-factory';
/**
 * A fraction used for sizing root panels; ~= `1 / golden_ratio`.
 */
var GOLDEN = 0.618;
/**
 * A widget which provides a flexible docking area for widgets.
 */
var DockPanel = (function (_super) {
    __extends(DockPanel, _super);
    /**
     * Construct a new dock panel.
     *
     * @param options - The options for initializing the panel.
     */
    function DockPanel(options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        _this._drag = null;
        _this._pressData = null;
        _this._tracker = new focustracker_1.FocusTracker();
        _this.addClass(DOCK_PANEL_CLASS);
        // Extract the inter-panel spacing.
        var spacing = options.spacing !== void 0 ? options.spacing : 4;
        // Extract the content renderer for the panel.
        _this._renderer = options.renderer || DockPanel.defaultRenderer;
        // Create the delegate renderer for the layout.
        var renderer = {
            createTabBar: function () { return _this._createTabBar(); },
            createHandle: function () { return _this._createHandle(); }
        };
        // Setup the dock layout for the panel.
        _this.layout = new DockLayout({ renderer: renderer, spacing: spacing });
        // Setup the overlay drop indicator.
        _this._overlay = options.overlay || new DockPanel.Overlay();
        _this._overlay.node.classList.add(OVERLAY_CLASS);
        _this.node.appendChild(_this._overlay.node);
        // Connect the focus tracker changed signal.
        _this._tracker.currentChanged.connect(_this._onCurrentChanged, _this);
        return _this;
    }
    /**
     * Dispose of the resources held by the panel.
     */
    DockPanel.prototype.dispose = function () {
        // Ensure the mouse is released.
        this._releaseMouse();
        // Hide the overlay.
        this._overlay.hide(0);
        // Cancel a drag if one is in progress.
        if (this._drag) {
            this._drag.dispose();
        }
        // Dispose of the focus tracker.
        this._tracker.dispose();
        // Dispose of the base class.
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(DockPanel.prototype, "currentWidget", {
        /**
         * The current widget in the dock panel.
         *
         * #### Notes
         * The current widget is the widget among the added widgets which
         * has the *descendant node* which has most recently been focused.
         *
         * This is the `currentWidget` of an internal `FocusTracker` which
         * tracks all widgets in the dock panel.
         *
         * This will be `null` if there is no current widget.
         *
         * This is a read-only property.
         */
        get: function () {
            return this._tracker.currentWidget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DockPanel.prototype, "overlay", {
        /**
         * The overlay used by the dock panel.
         */
        get: function () {
            return this._overlay;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DockPanel.prototype, "spacing", {
        /**
         * Get the spacing between the widgets.
         */
        get: function () {
            return this.layout.spacing;
        },
        /**
         * Set the spacing between the widgets.
         */
        set: function (value) {
            this.layout.spacing = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DockPanel.prototype, "isEmpty", {
        /**
         * Whether the dock panel is empty.
         */
        get: function () {
            return this.layout.isEmpty;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DockPanel.prototype, "renderer", {
        /**
         * The renderer used by the dock panel.
         */
        get: function () {
            return this.layout.renderer;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Create an iterator over the user widgets in the panel.
     *
     * @returns A new iterator over the user widgets in the panel.
     *
     * #### Notes
     * This iterator does not include the generated tab bars.
     */
    DockPanel.prototype.widgets = function () {
        return this.layout.widgets();
    };
    /**
     * Create an iterator over the tab bars in the panel.
     *
     * @returns A new iterator over the tab bars in the panel.
     *
     * #### Notes
     * This iterator does not include the user widgets.
     */
    DockPanel.prototype.tabBars = function () {
        return this.layout.tabBars();
    };
    /**
     * Create an iterator over the handles in the panel.
     *
     * @returns A new iterator over the handles in the panel.
     */
    DockPanel.prototype.handles = function () {
        return this.layout.handles();
    };
    /**
     * Activate the specified widget in the dock panel.
     *
     * @param widget - The widget of interest.
     *
     * #### Notes
     * This will make the widget the current widget in its tab area and
     * post the widget an `activate-request` message.
     */
    DockPanel.prototype.activateWidget = function (widget) {
        // Find the tab bar which contains the widget.
        var title = widget.title;
        var tabBar = searching_1.find(this.tabBars(), function (bar) { return searching_1.contains(bar.titles, title); });
        // Throw an error if no tab bar is found.
        if (!tabBar) {
            throw new Error('Widget is not contained in the dock panel.');
        }
        // Update the current title and activate the widget.
        tabBar.currentTitle = title;
        widget.activate();
    };
    /**
     * Add a widget to the dock panel.
     *
     * @param widget - The widget to add to the dock panel.
     *
     * @param options - The additional options for adding the widget.
     */
    DockPanel.prototype.addWidget = function (widget, options) {
        if (options === void 0) { options = {}; }
        // Add the widget to the layout.
        this.layout.addWidget(widget, options);
        // Add the widget to the focus tracker.
        this._tracker.add(widget);
    };
    /**
     * Handle the DOM events for the dock panel.
     *
     * @param event - The DOM event sent to the panel.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the panel's DOM node. It should
     * not be called directly by user code.
     */
    DockPanel.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'p-dragenter':
                this._evtDragEnter(event);
                break;
            case 'p-dragleave':
                this._evtDragLeave(event);
                break;
            case 'p-dragover':
                this._evtDragOver(event);
                break;
            case 'p-drop':
                this._evtDrop(event);
                break;
            case 'mousedown':
                this._evtMouseDown(event);
                break;
            case 'mousemove':
                this._evtMouseMove(event);
                break;
            case 'mouseup':
                this._evtMouseUp(event);
                break;
            case 'keydown':
                this._evtKeyDown(event);
                break;
            case 'contextmenu':
                event.preventDefault();
                event.stopPropagation();
                break;
        }
    };
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    DockPanel.prototype.onAfterAttach = function (msg) {
        this.node.addEventListener('p-dragenter', this);
        this.node.addEventListener('p-dragleave', this);
        this.node.addEventListener('p-dragover', this);
        this.node.addEventListener('p-drop', this);
        this.node.addEventListener('mousedown', this);
    };
    /**
     * A message handler invoked on a `'before-detach'` message.
     */
    DockPanel.prototype.onBeforeDetach = function (msg) {
        this.node.removeEventListener('p-dragenter', this);
        this.node.removeEventListener('p-dragleave', this);
        this.node.removeEventListener('p-dragover', this);
        this.node.removeEventListener('p-drop', this);
        this.node.removeEventListener('mousedown', this);
        this._releaseMouse();
    };
    /**
     * A message handler invoked on a `'child-added'` message.
     */
    DockPanel.prototype.onChildAdded = function (msg) {
        // Ignore the generated tab bars.
        if (msg.child.hasClass(TAB_BAR_CLASS)) {
            return;
        }
        // Add the widget class to the child.
        msg.child.addClass(WIDGET_CLASS);
    };
    /**
     * A message handler invoked on a `'child-removed'` message.
     */
    DockPanel.prototype.onChildRemoved = function (msg) {
        // Ignore the generated tab bars.
        if (msg.child.hasClass(TAB_BAR_CLASS)) {
            return;
        }
        // Remove the widget class from the child.
        msg.child.removeClass(WIDGET_CLASS);
        // Remove the widget from the focus tracker.
        this._tracker.remove(msg.child);
    };
    /**
     * Handle the `'p-dragenter'` event for the dock panel.
     */
    DockPanel.prototype._evtDragEnter = function (event) {
        // If the factory mime type is present, mark the event as
        // handled in order to get the rest of the drag events.
        if (event.mimeData.hasData(FACTORY_MIME)) {
            event.preventDefault();
            event.stopPropagation();
        }
    };
    /**
     * Handle the `'p-dragleave'` event for the dock panel.
     */
    DockPanel.prototype._evtDragLeave = function (event) {
        // Always mark the event as handled.
        event.preventDefault();
        event.stopPropagation();
        // Get the node into which the drag is entering.
        var related = event.relatedTarget;
        // Hide the overlay if the drag is leaving the dock panel.
        if (!related || !this.node.contains(related)) {
            this._overlay.hide(0);
        }
    };
    /**
     * Handle the `'p-dragover'` event for the dock panel.
     */
    DockPanel.prototype._evtDragOver = function (event) {
        // Always mark the event as handled.
        event.preventDefault();
        event.stopPropagation();
        // Show the drop indicator overlay and update the drop
        // action based on the drop target zone under the mouse.
        var clientX = event.clientX, clientY = event.clientY, shiftKey = event.shiftKey;
        if (this._showOverlay(clientX, clientY, shiftKey) === 'invalid') {
            event.dropAction = 'none';
        }
        else {
            event.dropAction = event.proposedAction;
        }
    };
    /**
     * Handle the `'p-drop'` event for the dock panel.
     */
    DockPanel.prototype._evtDrop = function (event) {
        // Always mark the event as handled.
        event.preventDefault();
        event.stopPropagation();
        // Hide the drop indicator overlay.
        this._overlay.hide(0);
        // Bail if the proposed action is to do nothing.
        if (event.proposedAction === 'none') {
            event.dropAction = 'none';
            return;
        }
        // Find the drop target under the mouse.
        var clientX = event.clientX, clientY = event.clientY, shiftKey = event.shiftKey;
        var _a = this._findDropTarget(clientX, clientY, shiftKey), zone = _a.zone, target = _a.target;
        // Bail if the drop zone is invalid.
        if (zone === 'invalid') {
            event.dropAction = 'none';
            return;
        }
        // Bail if the factory mime type has invalid data.
        var factory = event.mimeData.getData(FACTORY_MIME);
        if (typeof factory !== 'function') {
            event.dropAction = 'none';
            return;
        }
        // Bail if the factory does not produce a widget.
        var widget = factory();
        if (!(widget instanceof widget_1.Widget)) {
            event.dropAction = 'none';
            return;
        }
        // Handle the drop using the generated widget.
        switch (zone) {
            case 'root':
                this.addWidget(widget);
                break;
            case 'root-top':
                this.addWidget(widget, { mode: 'split-top' });
                break;
            case 'root-left':
                this.addWidget(widget, { mode: 'split-left' });
                break;
            case 'root-right':
                this.addWidget(widget, { mode: 'split-right' });
                break;
            case 'root-bottom':
                this.addWidget(widget, { mode: 'split-bottom' });
                break;
            case 'widget-top':
                this.addWidget(widget, { mode: 'split-top', ref: target });
                break;
            case 'widget-left':
                this.addWidget(widget, { mode: 'split-left', ref: target });
                break;
            case 'widget-right':
                this.addWidget(widget, { mode: 'split-right', ref: target });
                break;
            case 'widget-bottom':
                this.addWidget(widget, { mode: 'split-bottom', ref: target });
                break;
            case 'tab-bar':
                var ref = Private.tabBarRef(target);
                this.addWidget(widget, { mode: 'tab-after', ref: ref });
                break;
        }
        // Accept the proposed drop action.
        event.dropAction = event.proposedAction;
        // Activate the dropped widget.
        this.activateWidget(widget);
    };
    /**
     * Handle the `'keydown'` event for the dock panel.
     */
    DockPanel.prototype._evtKeyDown = function (event) {
        // Stop input events during drag.
        event.preventDefault();
        event.stopPropagation();
        // Release the mouse if `Escape` is pressed.
        if (event.keyCode === 27) {
            this._releaseMouse();
        }
    };
    /**
     * Handle the `'mousedown'` event for the dock panel.
     */
    DockPanel.prototype._evtMouseDown = function (event) {
        // Do nothing if the left mouse button is not pressed.
        if (event.button !== 0) {
            return;
        }
        // Find the handle which contains the mouse target, if any.
        var layout = this.layout;
        var target = event.target;
        var handle = searching_1.find(layout.handles(), function (handle) { return handle.contains(target); });
        if (!handle) {
            return;
        }
        // Stop the event when a handle is pressed.
        event.preventDefault();
        event.stopPropagation();
        // Add the extra document listeners.
        document.addEventListener('keydown', this, true);
        document.addEventListener('mouseup', this, true);
        document.addEventListener('mousemove', this, true);
        document.addEventListener('contextmenu', this, true);
        // Compute the offset deltas for the handle press.
        var rect = handle.getBoundingClientRect();
        var deltaX = event.clientX - rect.left;
        var deltaY = event.clientY - rect.top;
        // Override the cursor and store the press data.
        var style = window.getComputedStyle(handle);
        var override = cursor_1.overrideCursor(style.cursor);
        this._pressData = { handle: handle, deltaX: deltaX, deltaY: deltaY, override: override };
    };
    /**
     * Handle the `'mousemove'` event for the dock panel.
     */
    DockPanel.prototype._evtMouseMove = function (event) {
        // Stop the event when dragging a handle.
        event.preventDefault();
        event.stopPropagation();
        // Compute the desired offset position for the handle.
        var rect = this.node.getBoundingClientRect();
        var xPos = event.clientX - rect.left - this._pressData.deltaX;
        var yPos = event.clientY - rect.top - this._pressData.deltaY;
        // Set the handle as close to the desired position as possible.
        var layout = this.layout;
        layout.moveHandle(this._pressData.handle, xPos, yPos);
    };
    /**
     * Handle the `'mouseup'` event for the dock panel.
     */
    DockPanel.prototype._evtMouseUp = function (event) {
        // Do nothing if the left mouse button is not released.
        if (event.button !== 0) {
            return;
        }
        // Stop the event when releasing a handle.
        event.preventDefault();
        event.stopPropagation();
        // Finalize the mouse release.
        this._releaseMouse();
    };
    /**
     * Release the mouse grab for the dock panel.
     */
    DockPanel.prototype._releaseMouse = function () {
        // Bail early if no drag is in progress.
        if (!this._pressData) {
            return;
        }
        // Clear the override cursor.
        this._pressData.override.dispose();
        this._pressData = null;
        // Remove the extra document listeners.
        document.removeEventListener('keydown', this, true);
        document.removeEventListener('mouseup', this, true);
        document.removeEventListener('mousemove', this, true);
        document.removeEventListener('contextmenu', this, true);
    };
    /**
     * Find the drop target for the given client position.
     *
     * @param clientX - The client X position of interest.
     *
     * @param clientY - The client Y position of interest.
     *
     * @param shift - Whether to search for shifted drop targets.
     *
     * @returns The dock target at the specified client position.
     */
    DockPanel.prototype._findDropTarget = function (clientX, clientY, shift) {
        // Bail, if the mouse is not over the dock panel.
        if (!query_1.hitTest(this.node, clientX, clientY)) {
            return { zone: 'invalid', target: null };
        }
        // Lookup the layout for the panel.
        var layout = this.layout;
        // If the layout is empty, indicate a root drop zone.
        if (layout.isEmpty) {
            return { zone: 'root', target: null };
        }
        // Handle the shifted drop zones.
        if (shift) {
            var edge_1 = Private.calcEdge(this.node, clientX, clientY);
            return { zone: "root-" + edge_1, target: null };
        }
        // Find the widget at the given client position.
        var widget = searching_1.find(layout, function (widget) {
            return widget.isVisible && query_1.hitTest(widget.node, clientX, clientY);
        });
        // Bail if no widget is found.
        if (!widget) {
            return { zone: 'invalid', target: null };
        }
        // Handle the drop zone for a generated tab bar.
        if (widget.hasClass(TAB_BAR_CLASS)) {
            return { zone: 'tab-bar', target: widget };
        }
        // Handle the drop zone for a user widget.
        var edge = Private.calcEdge(widget.node, clientX, clientY);
        return { zone: "widget-" + edge, target: widget };
    };
    /**
     * Show the overlay indicator at the given client position.
     *
     * @param clientX - The client X position of interest.
     *
     * @param clientY - The client Y position of interest.
     *
     * @param shift - Whether to show the shifted drop targets.
     *
     * @returns The drop zone at the specified client position.
     *
     * #### Notes
     * If the position is not over a valid zone, the overlay is hidden.
     */
    DockPanel.prototype._showOverlay = function (clientX, clientY, shift) {
        // Find the dock target for the given client position.
        var _a = this._findDropTarget(clientX, clientY, shift), zone = _a.zone, target = _a.target;
        // If the drop zone is invalid, hide the overlay and bail.
        if (zone === 'invalid') {
            this._overlay.hide(100);
            return zone;
        }
        // Setup the variables needed to compute the overlay geometry.
        var top;
        var left;
        var right;
        var bottom;
        var tr;
        var box = sizing_1.boxSizing(this.node); // TODO cache this?
        var rect = this.node.getBoundingClientRect();
        // Compute the overlay geometry based on the dock zone.
        switch (zone) {
            case 'root':
                top = box.paddingTop;
                left = box.paddingLeft;
                right = box.paddingRight;
                bottom = box.paddingBottom;
                break;
            case 'root-top':
                top = box.paddingTop;
                left = box.paddingLeft;
                right = box.paddingRight;
                bottom = rect.height * GOLDEN;
                break;
            case 'root-left':
                top = box.paddingTop;
                left = box.paddingLeft;
                right = rect.width * GOLDEN;
                bottom = box.paddingBottom;
                break;
            case 'root-right':
                top = box.paddingTop;
                left = rect.width * GOLDEN;
                right = box.paddingRight;
                bottom = box.paddingBottom;
                break;
            case 'root-bottom':
                top = rect.height * GOLDEN;
                left = box.paddingLeft;
                right = box.paddingRight;
                bottom = box.paddingBottom;
                break;
            case 'tab-bar':
                tr = target.node.getBoundingClientRect();
                top = tr.top - rect.top - box.borderTop;
                left = tr.left - rect.left - box.borderLeft;
                right = rect.right - tr.right - box.borderRight;
                bottom = rect.bottom - tr.bottom - box.borderBottom;
                break;
            case 'widget-top':
                tr = target.node.getBoundingClientRect();
                top = tr.top - rect.top - box.borderTop;
                left = tr.left - rect.left - box.borderLeft;
                right = rect.right - tr.right - box.borderRight;
                bottom = rect.bottom - tr.bottom + tr.height / 2 - box.borderBottom;
                break;
            case 'widget-left':
                tr = target.node.getBoundingClientRect();
                top = tr.top - rect.top - box.borderTop;
                left = tr.left - rect.left - box.borderLeft;
                right = rect.right - tr.right + tr.width / 2 - box.borderRight;
                bottom = rect.bottom - tr.bottom - box.borderBottom;
                break;
            case 'widget-right':
                tr = target.node.getBoundingClientRect();
                top = tr.top - rect.top - box.borderTop;
                left = tr.left - rect.left + tr.width / 2 - box.borderLeft;
                right = rect.right - tr.right - box.borderRight;
                bottom = rect.bottom - tr.bottom - box.borderBottom;
                break;
            case 'widget-bottom':
                tr = target.node.getBoundingClientRect();
                top = tr.top - rect.top + tr.height / 2 - box.borderTop;
                left = tr.left - rect.left - box.borderLeft;
                right = rect.right - tr.right - box.borderRight;
                bottom = rect.bottom - tr.bottom - box.borderBottom;
                break;
        }
        // Derive the width and height from the other dimensions.
        var width = rect.width - right - left - box.borderLeft - box.borderRight;
        var height = rect.height - bottom - top - box.borderTop - box.borderBottom;
        // Show the overlay with the computed geometry.
        this._overlay.show({
            mouseX: clientX,
            mouseY: clientY,
            parentRect: rect,
            top: top, left: left, right: right, bottom: bottom, width: width, height: height
        });
        // Finally, return the computed drop zone.
        return zone;
    };
    /**
     * Create a new tab bar for use by the panel.
     */
    DockPanel.prototype._createTabBar = function () {
        // Create and initialize the tab bar.
        var tabBar = this._renderer.createTabBar();
        tabBar.addClass(TAB_BAR_CLASS);
        // Setup the signal handlers for the tab bar.
        tabBar.tabCloseRequested.connect(this._onTabCloseRequested, this);
        tabBar.tabDetachRequested.connect(this._onTabDetachRequested, this);
        tabBar.tabActivateRequested.connect(this._onTabActivateRequested, this);
        // Return the initialized tab bar.
        return tabBar;
    };
    /**
     * Create a new handle for use by the panel.
     */
    DockPanel.prototype._createHandle = function () {
        var handle = this._renderer.createHandle();
        handle.classList.add(HANDLE_CLASS);
        return handle;
    };
    /**
     * Handle the `tabActivateRequested` signal from a tab bar.
     */
    DockPanel.prototype._onTabActivateRequested = function (sender, args) {
        args.title.owner.activate();
    };
    /**
     * Handle the `tabCloseRequested` signal from a tab bar.
     */
    DockPanel.prototype._onTabCloseRequested = function (sender, args) {
        args.title.owner.close();
    };
    /**
     * Handle the `tabDetachRequested` signal from a tab bar.
     */
    DockPanel.prototype._onTabDetachRequested = function (sender, args) {
        var _this = this;
        // Do nothing if a drag is already in progress.
        if (this._drag) {
            return;
        }
        // Release the tab bar's hold on the mouse.
        sender.releaseMouse();
        // Extract the data from the args.
        var index = args.index, title = args.title, tab = args.tab, clientX = args.clientX, clientY = args.clientY;
        // Setup the mime data for the drag operation.
        var mimeData = new mimedata_1.MimeData();
        var widget = title.owner;
        mimeData.setData(FACTORY_MIME, function () { return widget; });
        // Create the drag image for the drag operation.
        var dragImage = tab.cloneNode(true);
        // Create the drag object to manage the drag-drop operation.
        this._drag = new dragdrop_1.Drag({
            mimeData: mimeData, dragImage: dragImage,
            proposedAction: 'move',
            supportedActions: 'move',
        });
        // Hide the tab node in the original tab.
        tab.classList.add(HIDDEN_CLASS);
        // Create the cleanup callback.
        var cleanup = (function () {
            _this._drag = null;
            tab.classList.remove(HIDDEN_CLASS);
        });
        // Start the drag operation and cleanup when done.
        this._drag.start(clientX, clientY).then(cleanup);
    };
    /**
     * Handle the `currentChanged` signal from the focus tracker.
     */
    DockPanel.prototype._onCurrentChanged = function (sender, args) {
        this.currentChanged.emit(args);
    };
    return DockPanel;
}(widget_1.Widget));
exports.DockPanel = DockPanel;
// Define the signals for the `DockPanel` class.
signaling_1.defineSignal(DockPanel.prototype, 'currentChanged');
/**
 * The namespace for the `DockPanel` class statics.
 */
(function (DockPanel) {
    /**
     * A concrete implementation of `IOverlay`.
     *
     * This is the default overlay implementation for a dock panel.
     */
    var Overlay = (function () {
        /**
         * Construct a new overlay.
         */
        function Overlay() {
            this._timer = -1;
            this._hidden = true;
            this._node = document.createElement('div');
            this._node.classList.add(HIDDEN_CLASS);
            this._node.style.position = 'absolute';
        }
        Object.defineProperty(Overlay.prototype, "node", {
            /**
             * The DOM node for the overlay.
             */
            get: function () {
                return this._node;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Show the overlay using the given overlay geometry.
         *
         * @param geo - The desired geometry for the overlay.
         */
        Overlay.prototype.show = function (geo) {
            // Update the position of the overlay.
            var style = this._node.style;
            style.top = geo.top + "px";
            style.left = geo.left + "px";
            style.right = geo.right + "px";
            style.bottom = geo.bottom + "px";
            // Clear any pending hide timer.
            clearTimeout(this._timer);
            this._timer = -1;
            // If the overlay is already visible, we're done.
            if (!this._hidden) {
                return;
            }
            // Clear the hidden flag.
            this._hidden = false;
            // Finally, show the overlay.
            this._node.classList.remove(HIDDEN_CLASS);
        };
        /**
         * Hide the overlay node.
         *
         * @param delay - The delay (in ms) before hiding the overlay.
         *   A delay value <= 0 will hide the overlay immediately.
         */
        Overlay.prototype.hide = function (delay) {
            var _this = this;
            // Do nothing if the overlay is already hidden.
            if (this._hidden) {
                return;
            }
            // Hide immediately if the delay is <= 0.
            if (delay <= 0) {
                clearTimeout(this._timer);
                this._timer = -1;
                this._hidden = true;
                this._node.classList.add(HIDDEN_CLASS);
                return;
            }
            // Do nothing if a hide is already pending.
            if (this._timer !== -1) {
                return;
            }
            // Otherwise setup the hide timer.
            this._timer = setTimeout(function () {
                _this._timer = -1;
                _this._hidden = true;
                _this._node.classList.add(HIDDEN_CLASS);
            }, delay);
        };
        return Overlay;
    }());
    DockPanel.Overlay = Overlay;
    /**
     * The default implementation of `IRenderer`.
     */
    var Renderer = (function () {
        function Renderer() {
        }
        /**
         * Create a new tab bar for use with a dock panel.
         *
         * @returns A new tab bar for a dock panel.
         */
        Renderer.prototype.createTabBar = function () {
            return new tabbar_1.TabBar();
        };
        /**
         * Create a new handle node for use with a dock panel.
         *
         * @returns A new handle node for a dock panel.
         */
        Renderer.prototype.createHandle = function () {
            return document.createElement('div');
        };
        return Renderer;
    }());
    DockPanel.Renderer = Renderer;
    /**
     * The default `Renderer` instance.
     */
    DockPanel.defaultRenderer = new Renderer();
})(DockPanel = exports.DockPanel || (exports.DockPanel = {}));
exports.DockPanel = DockPanel;
/**
 * A layout which provides a flexible docking arrangement.
 *
 * #### Notes
 * The layout handles the `currentChanged` signals of the tab bars and
 * the corresponding visibility of the child widgets. The widget which
 * consumes the layout is responsible for all other tab interactions
 * as well as all mouse and drag events.
 */
var DockLayout = (function (_super) {
    __extends(DockLayout, _super);
    /**
     * Construct a new dock layout.
     *
     * @param options - The options for initializing the layout.
     */
    function DockLayout(options) {
        var _this = _super.call(this) || this;
        _this._dirty = false;
        _this._box = null;
        _this._root = null;
        _this._renderer = options.renderer;
        _this._spacing = Private.clampSpacing(options.spacing);
        return _this;
    }
    /**
     * Dispose of the resources held by the layout.
     *
     * #### Notes
     * This will clear and dispose all widgets in the layout.
     */
    DockLayout.prototype.dispose = function () {
        // Clear the reference to the renderer.
        this._renderer = null;
        // Get an iterator over the widgets in the layout.
        var widgets = this.iter();
        // Clear the layout before disposing the widgets.
        this._root = null;
        // Dispose of the widgets contained in the old layout root.
        iteration_1.each(widgets, function (widget) { widget.dispose(); });
        // Dispose of the base class.
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(DockLayout.prototype, "spacing", {
        /**
         * Get the inter-element spacing for the dock layout.
         */
        get: function () {
            return this._spacing;
        },
        /**
         * Set the inter-element spacing for the dock layout.
         */
        set: function (value) {
            value = Private.clampSpacing(value);
            if (this._spacing === value) {
                return;
            }
            this._spacing = value;
            if (!this.parent) {
                return;
            }
            this.parent.fit();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DockLayout.prototype, "isEmpty", {
        /**
         * Whether the dock layout is empty.
         */
        get: function () {
            return this._root === null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DockLayout.prototype, "renderer", {
        /**
         * The renderer used by the dock layout.
         */
        get: function () {
            return this._renderer;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Create an iterator over all widgets in the layout.
     *
     * @returns A new iterator over the widgets in the layout.
     *
     * #### Notes
     * This iterator includes the generated tab bars.
     */
    DockLayout.prototype.iter = function () {
        return this._root ? Private.iterAllWidgets(this._root) : iteration_1.empty();
    };
    /**
     * Create an iterator over the user widgets in the layout.
     *
     * @returns A new iterator over the user widgets in the layout.
     *
     * #### Notes
     * This iterator does not include the generated tab bars.
     */
    DockLayout.prototype.widgets = function () {
        return this._root ? Private.iterUserWidgets(this._root) : iteration_1.empty();
    };
    /**
     * Create an iterator over the tab bars in the layout.
     *
     * @returns A new iterator over the tab bars in the layout.
     *
     * #### Notes
     * This iterator does not include the user widgets.
     */
    DockLayout.prototype.tabBars = function () {
        return this._root ? Private.iterTabBars(this._root) : iteration_1.empty();
    };
    /**
     * Create an iterator over the handles in the layout.
     *
     * @returns A new iterator over the handles in the layout.
     */
    DockLayout.prototype.handles = function () {
        return this._root ? Private.iterHandles(this._root) : iteration_1.empty();
    };
    /**
     * Move a handle to the given offset position.
     *
     * @param handle - The handle to move.
     *
     * @param offsetX - The desired offset X position of the handle.
     *
     * @param offsetY - The desired offset Y position of the handle.
     *
     * #### Notes
     * If the given handle is not contained in the layout, this is no-op.
     *
     * The handle will be moved as close as possible to the desired
     * position without violating any of the layout constraints.
     *
     * Only one of the coordinates is used depending on the orientation
     * of the handle. This method accepts both coordinates to make it
     * easy to invoke from a mouse move event without needing to know
     * the handle orientation.
     */
    DockLayout.prototype.moveHandle = function (handle, offsetX, offsetY) {
        // Bail early if there is no root or if the handle is hidden.
        if (!this._root || handle.classList.contains(HIDDEN_CLASS)) {
            return;
        }
        // Lookup the split node for the handle.
        var data = Private.findSplitNode(this._root, handle);
        if (!data) {
            return;
        }
        // Compute the desired delta movement for the handle.
        var delta;
        if (data.node.orientation === 'horizontal') {
            delta = offsetX - handle.offsetLeft;
        }
        else {
            delta = offsetY - handle.offsetTop;
        }
        // Bail if there is no handle movement.
        if (delta === 0) {
            return;
        }
        // Prevent sibling resizing unless needed.
        Private.holdSizes(data.node.sizers);
        // Adjust the sizers to reflect the handle movement.
        boxengine_1.adjustSizer(data.node.sizers, data.index, delta);
        // Update the layout of the widgets.
        if (this.parent) {
            this.parent.update();
        }
    };
    /**
     * Add a widget to the dock layout.
     *
     * @param widget - The widget to add to the dock layout.
     *
     * @param options - The additional options for adding the widget.
     *
     * #### Notes
     * The widget will be moved if it is already contained in the layout.
     *
     * A warning will be logged if the reference widget is invalid.
     */
    DockLayout.prototype.addWidget = function (widget, options) {
        if (options === void 0) { options = {}; }
        // Parse the options.
        var ref = options.ref || null;
        var mode = options.mode || 'tab-after';
        // Find the tab node which holds the reference widget.
        var refNode = null;
        if (this._root && ref) {
            refNode = Private.findTabNode(this._root, ref);
        }
        // Throw an error if the reference widget is invalid.
        if (ref && !refNode) {
            throw new Error('Reference widget is not in the layout.');
        }
        // Reparent the widget to the current layout parent.
        widget.parent = this.parent;
        // Insert the widget according to the insert mode.
        switch (mode) {
            case 'tab-after':
                this._insertTab(widget, ref, refNode, true);
                break;
            case 'tab-before':
                this._insertTab(widget, ref, refNode, false);
                break;
            case 'split-top':
                this._insertSplit(widget, ref, refNode, 'vertical', false);
                break;
            case 'split-left':
                this._insertSplit(widget, ref, refNode, 'horizontal', false);
                break;
            case 'split-right':
                this._insertSplit(widget, ref, refNode, 'horizontal', true);
                break;
            case 'split-bottom':
                this._insertSplit(widget, ref, refNode, 'vertical', true);
                break;
        }
        // Do nothing else if there is no parent widget.
        if (!this.parent) {
            return;
        }
        // Ensure the widget is attached to the parent widget.
        this.attachWidget(widget);
        // Post a fit request for the parent widget.
        this.parent.fit();
    };
    /**
     * Remove a widget from the layout.
     *
     * @param widget - The widget to remove from the layout.
     *
     * #### Notes
     * A widget is automatically removed from the layout when its `parent`
     * is set to `null`. This method should only be invoked directly when
     * removing a widget from a layout which has yet to be installed on a
     * parent widget.
     *
     * This method does *not* modify the widget's `parent`.
     */
    DockLayout.prototype.removeWidget = function (widget) {
        // Remove the widget from its current layout location.
        this._removeWidget(widget);
        // Do nothing else if there is no parent widget.
        if (!this.parent) {
            return;
        }
        // Detach the widget from the parent widget.
        this.detachWidget(widget);
        // Post a fit request for the parent widget.
        this.parent.fit();
    };
    /**
     * Perform layout initialization which requires the parent widget.
     */
    DockLayout.prototype.init = function () {
        var _this = this;
        // Perform superclass initialization.
        _super.prototype.init.call(this);
        // Attach each widget to the parent.
        iteration_1.each(this, function (widget) { _this.attachWidget(widget); });
        // Attach each handle to the parent.
        iteration_1.each(this.handles(), function (handle) { _this.parent.node.appendChild(handle); });
        // Post a fit request for the parent widget.
        this.parent.fit();
    };
    /**
     * Attach the widget to the layout parent widget.
     *
     * @param widget - The widget to attach to the parent.
     *
     * #### Notes
     * This is a no-op if the widget is already attached.
     */
    DockLayout.prototype.attachWidget = function (widget) {
        // Do nothing if the widget is already attached.
        if (this.parent.node === widget.node.parentNode) {
            return;
        }
        // Prepare the layout geometry for the widget.
        widget_1.Widget.prepareGeometry(widget);
        // Add the widget's node to the parent.
        this.parent.node.appendChild(widget.node);
        // Send an `'after-attach'` message if the parent is attached.
        if (this.parent.isAttached) {
            messaging_1.sendMessage(widget, widget_1.WidgetMessage.AfterAttach);
        }
    };
    /**
     * Detach the widget from the layout parent widget.
     *
     * @param widget - The widget to detach from the parent.
     *
     * #### Notes
     * This is a no-op if the widget is not attached.
     */
    DockLayout.prototype.detachWidget = function (widget) {
        // Do nothing if the widget is not attached.
        if (this.parent.node !== widget.node.parentNode) {
            return;
        }
        // Send a `'before-detach'` message if the parent is attached.
        if (this.parent.isAttached) {
            messaging_1.sendMessage(widget, widget_1.WidgetMessage.BeforeDetach);
        }
        // Remove the widget's node from the parent.
        this.parent.node.removeChild(widget.node);
        // Reset the layout geometry for the widget.
        widget_1.Widget.resetGeometry(widget);
    };
    /**
     * A message handler invoked on an `'after-show'` message.
     */
    DockLayout.prototype.onAfterShow = function (msg) {
        _super.prototype.onAfterShow.call(this, msg);
        this.parent.update();
    };
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    DockLayout.prototype.onAfterAttach = function (msg) {
        _super.prototype.onAfterAttach.call(this, msg);
        this.parent.fit();
    };
    /**
     * A message handler invoked on a `'child-shown'` message.
     */
    DockLayout.prototype.onChildShown = function (msg) {
        if (platform_1.IS_IE || platform_1.IS_EDGE) {
            // TODO not collapsing can cause lots of fitting
            messaging_1.sendMessage(this.parent, widget_1.WidgetMessage.FitRequest);
        }
        else {
            this.parent.fit();
        }
    };
    /**
     * A message handler invoked on a `'child-hidden'` message.
     */
    DockLayout.prototype.onChildHidden = function (msg) {
        if (platform_1.IS_IE || platform_1.IS_EDGE) {
            // TODO not collapsing can cause lots of fitting
            messaging_1.sendMessage(this.parent, widget_1.WidgetMessage.FitRequest);
        }
        else {
            this.parent.fit();
        }
    };
    /**
     * A message handler invoked on a `'resize'` message.
     */
    DockLayout.prototype.onResize = function (msg) {
        if (this.parent.isVisible) {
            this._update(msg.width, msg.height);
        }
    };
    /**
     * A message handler invoked on an `'update-request'` message.
     */
    DockLayout.prototype.onUpdateRequest = function (msg) {
        if (this.parent.isVisible) {
            this._update(-1, -1);
        }
    };
    /**
     * A message handler invoked on a `'fit-request'` message.
     */
    DockLayout.prototype.onFitRequest = function (msg) {
        if (this.parent.isAttached) {
            this._fit();
        }
    };
    /**
     * Remove the specified widget from the layout structure.
     *
     * @param widget - The widget to remove from the layout.
     *
     * #### Notes
     * This is a no-op if the widget is not in the layout tree.
     *
     * This does not detach the widget from the parent node.
     */
    DockLayout.prototype._removeWidget = function (widget) {
        // Bail early if there is no layout root.
        if (!this._root) {
            return;
        }
        // Find the tab node which contains the given widget.
        var tabNode = Private.findTabNode(this._root, widget);
        // Bail early if the tab node is not found.
        if (!tabNode) {
            return;
        }
        // If there are multiple tabs, just remove the widget's tab.
        if (tabNode.tabBar.titles.length > 1) {
            tabNode.tabBar.removeTab(widget.title);
            return;
        }
        // Otherwise, the tab node needs to be removed...
        // Dispose the tab bar.
        tabNode.tabBar.dispose();
        // Handle the case where the tab node is the root.
        if (this._root === tabNode) {
            this._root = null;
            return;
        }
        // Otherwise, remove the tab node from its parent...
        // Prevent widget resizing unless needed.
        Private.holdLayoutSizes(this._root);
        // Clear the parent reference on the tab node.
        var splitNode = tabNode.parent;
        tabNode.parent = null;
        // Remove the tab node from its parent split node.
        var i = splitNode.children.remove(tabNode);
        var handle = splitNode.handles.removeAt(i);
        splitNode.sizers.removeAt(i);
        // Remove the handle from its parent DOM node.
        if (handle.parentNode) {
            handle.parentNode.removeChild(handle);
        }
        // If there are multiple children, just update the handles.
        if (splitNode.children.length > 1) {
            Private.syncHandles(splitNode);
            return;
        }
        // Otherwise, the split node also needs to be removed...
        // Clear the parent reference on the split node.
        var parentNode = splitNode.parent;
        splitNode.parent = null;
        // Lookup the remaining child node and handle.
        var childNode = splitNode.children.front;
        var childHandle = splitNode.handles.front;
        // Clear the split node data.
        splitNode.children.clear();
        splitNode.handles.clear();
        splitNode.sizers.clear();
        // Remove the child handle from its parent node.
        if (childHandle.parentNode) {
            childHandle.parentNode.removeChild(childHandle);
        }
        // Handle the case where the split node is the root.
        if (this._root === splitNode) {
            childNode.parent = null;
            this._root = childNode;
            return;
        }
        // Otherwise, move the child node to the parent node...
        // Lookup the index of the split node.
        var j = searching_1.indexOf(parentNode.children, splitNode);
        // Handle the case where the child node is a tab node.
        if (childNode instanceof Private.TabLayoutNode) {
            childNode.parent = parentNode;
            parentNode.children.set(j, childNode);
            return;
        }
        // Remove the split data from the parent.
        var splitHandle = parentNode.handles.removeAt(j);
        parentNode.children.removeAt(j);
        parentNode.sizers.removeAt(j);
        // Remove the handle from its parent node.
        if (splitHandle.parentNode) {
            splitHandle.parentNode.removeChild(splitHandle);
        }
        // The child node and the split parent node will have the same
        // orientation. Merge the grand-children with the parent node.
        for (var i_1 = 0, n = childNode.children.length; i_1 < n; ++i_1) {
            var gChild = childNode.children.at(i_1);
            var gHandle = childNode.handles.at(i_1);
            var gSizer = childNode.sizers.at(i_1);
            parentNode.children.insert(j + i_1, gChild);
            parentNode.handles.insert(j + i_1, gHandle);
            parentNode.sizers.insert(j + i_1, gSizer);
            gChild.parent = parentNode;
        }
        // Clear the child node.
        childNode.children.clear();
        childNode.handles.clear();
        childNode.sizers.clear();
        childNode.parent = null;
        // Sync the handles on the parent node.
        Private.syncHandles(parentNode);
    };
    /**
     * Insert a widget next to an existing tab.
     *
     * @param widget - The widget to add to the layout.
     *
     * @param ref - The reference widget, or `null`.
     *
     * @param refNode - The layout node for the ref widget, or `null`.
     *
     * @param after - Whether to insert the widget after the ref.
     *
     * #### Notes
     * This assumes the target widget is not in the layout tree.
     *
     * This does not attach the widget to the parent widget.
     */
    DockLayout.prototype._insertTab = function (widget, ref, refNode, after) {
        // Do nothing if the tab is inserted next to itself.
        if (widget === ref) {
            return;
        }
        // Create the root if it does not exist.
        if (!this._root) {
            var tabNode = new Private.TabLayoutNode(this._createTabBar());
            tabNode.tabBar.addTab(widget.title);
            this._root = tabNode;
            return;
        }
        // Use the first tab node as the ref node if needed.
        if (!refNode) {
            refNode = Private.firstTabNode(this._root);
        }
        // If the widget is not contained in the ref node, ensure it is
        // removed from the layout and hidden before being added again.
        if (!searching_1.contains(refNode.tabBar.titles, widget.title)) {
            this._removeWidget(widget);
            widget.hide();
        }
        // Lookup the target index for inserting the tab.
        var index;
        if (ref) {
            index = searching_1.indexOf(refNode.tabBar.titles, ref.title);
        }
        else {
            index = refNode.tabBar.currentIndex;
        }
        // Insert the widget's tab relative to the target index.
        refNode.tabBar.insertTab(index + (after ? 1 : 0), widget.title);
    };
    /**
     * Insert a widget as a new split area.
     *
     * @param widget - The widget to add to the layout.
     *
     * @param ref - The reference widget, or `null`.
     *
     * @param refNode - The layout node for the ref widget, or `null`.
     *
     * @param orientation - The orientation for the split.
     *
     * @param after - Whether to insert the widget after the ref.
     *
     * #### Notes
     * This assumes the target widget is not in the layout tree.
     *
     * This does not attach the widget to the parent widget.
     */
    DockLayout.prototype._insertSplit = function (widget, ref, refNode, orientation, after) {
        // Do nothing if there is no effective split.
        if (widget === ref && refNode.tabBar.titles.length === 1) {
            return;
        }
        // Ensure the widget is removed from the current layout.
        this._removeWidget(widget);
        // Create the tab layout node to hold the widget.
        var tabNode = new Private.TabLayoutNode(this._createTabBar());
        tabNode.tabBar.addTab(widget.title);
        // Set the root if it does not exist.
        if (!this._root) {
            this._root = tabNode;
            return;
        }
        // Lookup the split node for the ref widget.
        var splitNode = refNode ? refNode.parent : null;
        // If the split node is null, split the root.
        if (!splitNode) {
            // Ensure the root is split with the correct orientation.
            var root = this._splitRoot(orientation);
            // Determine the insert index for the new tab node.
            var i_2 = after ? root.children.length : 0;
            // Normalize the split node.
            Private.normalizeSizes(root);
            // Insert the tab node sized to the golden ratio.
            root.children.insert(i_2, tabNode);
            root.sizers.insert(i_2, Private.createSizer(GOLDEN));
            root.handles.insert(i_2, this._createHandle());
            tabNode.parent = root;
            // Re-normalize the split node to maintain the ratios.
            Private.normalizeSizes(root);
            // Finally, synchronize the visibility of the handles.
            Private.syncHandles(root);
            return;
        }
        // If the split node already had the correct orientation,
        // the widget can be inserted into the split node directly.
        if (splitNode.orientation === orientation) {
            // Find the index of the ref node.
            var i_3 = searching_1.indexOf(splitNode.children, refNode);
            // Normalize the split node.
            Private.normalizeSizes(splitNode);
            // Consume half the space for the insert location.
            var s = splitNode.sizers.at(i_3).sizeHint /= 2;
            // Insert the tab node sized to the other half.
            var j_1 = i_3 + (after ? 1 : 0);
            splitNode.children.insert(j_1, tabNode);
            splitNode.sizers.insert(j_1, Private.createSizer(s));
            splitNode.handles.insert(j_1, this._createHandle());
            tabNode.parent = splitNode;
            // Finally, synchronize the visibility of the handles.
            Private.syncHandles(splitNode);
            return;
        }
        // Remove the ref node from the split node.
        var i = splitNode.children.remove(refNode);
        // Create a new normalized split node for the children.
        var childNode = new Private.SplitLayoutNode(orientation);
        childNode.normalized = true;
        // Add the ref node sized to half the space.
        childNode.children.pushBack(refNode);
        childNode.sizers.pushBack(Private.createSizer(0.5));
        childNode.handles.pushBack(this._createHandle());
        refNode.parent = childNode;
        // Add the tab node sized to the other half.
        var j = after ? 1 : 0;
        childNode.children.insert(j, tabNode);
        childNode.sizers.insert(j, Private.createSizer(0.5));
        childNode.handles.insert(j, this._createHandle());
        tabNode.parent = childNode;
        // Synchronize the visibility of the handles.
        Private.syncHandles(childNode);
        // Finally, add the new child node to the original split node.
        splitNode.children.insert(i, childNode);
        childNode.parent = splitNode;
    };
    /**
     * Ensure the root is a split node with the given orientation.
     *
     * @param orientation - The required orientation of the root.
     *
     * @returns The new root node (as a convenience).
     */
    DockLayout.prototype._splitRoot = function (orientation) {
        // Bail early if the root already meets the requirements.
        var root = this._root;
        if (root instanceof Private.SplitLayoutNode) {
            if (root.orientation === orientation) {
                return root;
            }
        }
        // Create a new root node with the specified orientation.
        var result = this._root = new Private.SplitLayoutNode(orientation);
        // Add the old root to the new root.
        result.children.pushBack(root);
        result.sizers.pushBack(Private.createSizer(0));
        result.handles.pushBack(this._createHandle());
        root.parent = result;
        // Return the new root as a convenience.
        return result;
    };
    /**
     * Fit the layout to the total size required by the widgets.
     */
    DockLayout.prototype._fit = function () {
        // Setup the size limits.
        var minW = 0;
        var minH = 0;
        var maxW = Infinity;
        var maxH = Infinity;
        // Update the limits for the root layout node.
        if (this._root) {
            var limits = Private.fitLayoutNode(this._root, this._spacing);
            minW = limits.minWidth;
            minH = limits.minHeight;
            maxW = limits.maxWidth;
            maxH = limits.maxHeight;
        }
        // Update the box sizing and add it to the size limits.
        var box = this._box = sizing_1.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        maxW += box.horizontalSum;
        maxH += box.verticalSum;
        // Update the parent's size constraints.
        var style = this.parent.node.style;
        style.minWidth = minW + "px";
        style.minHeight = minH + "px";
        style.maxWidth = maxW === Infinity ? 'none' : maxW + "px";
        style.maxHeight = maxH === Infinity ? 'none' : maxH + "px";
        // Set the dirty flag to ensure only a single update occurs.
        this._dirty = true;
        // Notify the ancestor that it should fit immediately. This may
        // cause a resize of the parent, fulfilling the required update.
        if (this.parent.parent) {
            messaging_1.sendMessage(this.parent.parent, widget_1.WidgetMessage.FitRequest);
        }
        // If the dirty flag is still set, the parent was not resized.
        // Trigger the required update on the parent widget immediately.
        if (this._dirty) {
            messaging_1.sendMessage(this.parent, widget_1.WidgetMessage.UpdateRequest);
        }
    };
    /**
     * Update the layout position and size of the widgets.
     *
     * The parent offset dimensions should be `-1` if unknown.
     */
    DockLayout.prototype._update = function (offsetWidth, offsetHeight) {
        // Clear the dirty flag to indicate the update occurred.
        this._dirty = false;
        // Bail early if there is no root layout node.
        if (!this._root) {
            return;
        }
        // Measure the parent if the offset dimensions are unknown.
        if (offsetWidth < 0) {
            offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
            offsetHeight = this.parent.node.offsetHeight;
        }
        // Ensure the parent box sizing data is computed.
        var box = this._box || (this._box = sizing_1.boxSizing(this.parent.node));
        // Compute the actual layout bounds adjusted for border and padding.
        var x = box.paddingTop;
        var y = box.paddingLeft;
        var width = offsetWidth - box.horizontalSum;
        var height = offsetHeight - box.verticalSum;
        // Update the geometry of the root layout node.
        Private.updateLayoutNode(this._root, x, y, width, height, this._spacing);
    };
    /**
     * Create a new tab bar for use by the dock layout.
     *
     * #### Notes
     * The tab bar will be attached to the parent if it exists.
     */
    DockLayout.prototype._createTabBar = function () {
        // Create the tab bar using the renderer.
        var tabBar = this._renderer.createTabBar();
        // Enforce necessary tab bar behavior.
        // TODO do we really want to enforce *all* of these?
        tabBar.tabsMovable = true;
        tabBar.allowDeselect = false;
        tabBar.orientation = 'horizontal';
        tabBar.removeBehavior = 'select-previous-tab';
        tabBar.insertBehavior = 'select-tab-if-needed';
        // Setup the signal handlers for the tab bar.
        tabBar.currentChanged.connect(this._onCurrentChanged, this);
        // Reparent and attach the tab bar to the parent if possible.
        if (this.parent) {
            tabBar.parent = this.parent;
            this.attachWidget(tabBar);
        }
        // Return the initialized tab bar.
        return tabBar;
    };
    /**
     * Create a new handle for the dock layout.
     *
     * #### Notes
     * The handle will be attached to the parent if it exists.
     */
    DockLayout.prototype._createHandle = function () {
        // Create the handle using the renderer.
        var handle = this._renderer.createHandle();
        // Initialize the handle layout behavior.
        var style = handle.style;
        style.position = 'absolute';
        style.top = '0';
        style.left = '0';
        style.width = '0';
        style.height = '0';
        // Attach the handle to the parent if it exists.
        if (this.parent) {
            this.parent.node.appendChild(handle);
        }
        // Return the initialized handle.
        return handle;
    };
    /**
     * Handle the `currentChanged` signal from a tab bar in the layout.
     */
    DockLayout.prototype._onCurrentChanged = function (sender, args) {
        // Extract the previous and current title from the args.
        var previousTitle = args.previousTitle, currentTitle = args.currentTitle;
        // Extract the widgets from the titles.
        var previousWidget = previousTitle ? previousTitle.owner : null;
        var currentWidget = currentTitle ? currentTitle.owner : null;
        // Hide the previous widget.
        if (previousWidget) {
            previousWidget.hide();
        }
        // Show the current widget.
        if (currentWidget) {
            currentWidget.show();
        }
    };
    return DockLayout;
}(widget_1.Layout));
exports.DockLayout = DockLayout;
/**
 * The namespace for the module private data.
 */
var Private;
(function (Private) {
    /**
     * A layout node which holds the data for a tabbed area.
     */
    var TabLayoutNode = (function () {
        /**
         * Construct a new tab layout node.
         *
         * @param tabBar - The tab bar to use for the layout node.
         */
        function TabLayoutNode(tabBar) {
            /**
             * The parent of the layout node, or `null`.
             */
            this.parent = null;
            /**
             * The box sizers for the tab bar and current widget.
             */
            this.sizers = new vector_1.Vector();
            var tabSizer = new boxengine_1.BoxSizer();
            var widgetSizer = new boxengine_1.BoxSizer();
            tabSizer.stretch = 0;
            widgetSizer.stretch = 1;
            this.sizers.pushBack(tabSizer);
            this.sizers.pushBack(widgetSizer);
            this.tabBar = tabBar;
        }
        return TabLayoutNode;
    }());
    Private.TabLayoutNode = TabLayoutNode;
    /**
     * A layout node which holds the data for a split area.
     */
    var SplitLayoutNode = (function () {
        /**
         * Construct a new split layout node.
         *
         * @param orientation - The orientation of the node.
         */
        function SplitLayoutNode(orientation) {
            /**
             * The parent of the layout node, or `null`.
             */
            this.parent = null;
            /**
             * Whether the sizers have been normalized.
             */
            this.normalized = false;
            /**
             * The child nodes for the split node.
             */
            this.children = new vector_1.Vector();
            /**
             * The box sizers for the layout children.
             */
            this.sizers = new vector_1.Vector();
            /**
             * The handles for the layout children.
             */
            this.handles = new vector_1.Vector();
            this.orientation = orientation;
        }
        return SplitLayoutNode;
    }());
    Private.SplitLayoutNode = SplitLayoutNode;
    /**
     * Clamp a spacing value to an integer >= 0.
     */
    function clampSpacing(value) {
        return Math.max(0, Math.floor(value));
    }
    Private.clampSpacing = clampSpacing;
    /**
     * Create an iterator for all widgets in the layout tree.
     *
     * @param node - The root layout node of interest.
     *
     * @returns An iterator which yields all widgets in the tree.
     *
     * #### Notes
     * This includes the tab bars for the tab layout nodes.
     */
    function iterAllWidgets(node) {
        var it;
        if (node instanceof TabLayoutNode) {
            it = iteration_1.chain(iteration_1.once(node.tabBar), iterUserWidgets(node));
        }
        else {
            it = new iteration_1.ChainIterator(iteration_1.map(node.children, iterAllWidgets));
        }
        return it;
    }
    Private.iterAllWidgets = iterAllWidgets;
    /**
     * Create an iterator for the user widgets in the layout tree.
     *
     * @param node - The root layout node of interest.
     *
     * @returns An iterator which yields the user widgets in the tree.
     *
     * #### Notes
     * This does not include the tab bars for the tab layout nodes.
     */
    function iterUserWidgets(node) {
        var it;
        if (node instanceof TabLayoutNode) {
            it = iteration_1.map(node.tabBar.titles, function (title) { return title.owner; });
        }
        else {
            it = new iteration_1.ChainIterator(iteration_1.map(node.children, iterUserWidgets));
        }
        return it;
    }
    Private.iterUserWidgets = iterUserWidgets;
    /**
     * Create an iterator for the tab bars in the tree.
     *
     * @param node - The root layout node of interest.
     *
     * @returns An iterator which yields the tab bars in the tree.
     */
    function iterTabBars(node) {
        var it;
        if (node instanceof TabLayoutNode) {
            it = iteration_1.once(node.tabBar);
        }
        else {
            it = new iteration_1.ChainIterator(iteration_1.map(node.children, iterTabBars));
        }
        return it;
    }
    Private.iterTabBars = iterTabBars;
    /**
     * Create an iterator for the handles in the tree.
     *
     * @param node - The root layout node of interest.
     *
     * @returns An iterator which yields the handles in the tree.
     */
    function iterHandles(node) {
        var it;
        if (node instanceof TabLayoutNode) {
            it = iteration_1.empty();
        }
        else {
            var others = iteration_1.map(node.children, iterHandles);
            it = iteration_1.chain(node.handles, new iteration_1.ChainIterator(others));
        }
        return it;
    }
    Private.iterHandles = iterHandles;
    /**
     * Get the reference widget for a tab bar.
     *
     * @param tabBar - The tab bar of interest.
     *
     * @returns The target reference widget in the tab bar, or null.
     */
    function tabBarRef(tabBar) {
        if (tabBar.currentTitle) {
            return tabBar.currentTitle.owner;
        }
        if (tabBar.titles.length > 0) {
            return tabBar.titles.at(tabBar.titles.length - 1).owner;
        }
        return null;
    }
    Private.tabBarRef = tabBarRef;
    /**
     * Find the first tab layout node in a layout tree.
     *
     * @param node - The root layout node of interest.
     *
     * @returns The first tab node in the tree, or `null`.
     */
    function firstTabNode(node) {
        // Return the node if it's a tab layout node.
        if (node instanceof TabLayoutNode) {
            return node;
        }
        // Recursively search the children for a tab layout node.
        for (var i = 0, n = node.children.length; i < n; ++i) {
            var result = firstTabNode(node.children.at(i));
            if (result !== null) {
                return result;
            }
        }
        // Otherwise, there is no tab layout node.
        return null;
    }
    Private.firstTabNode = firstTabNode;
    /**
     * Find the tab layout node which contains the given widget.
     *
     * @param node - The root layout node of interest.
     *
     * @param widget - The widget of interest.
     *
     * @returns The tab node which holds the widget, or `null`.
     */
    function findTabNode(node, widget) {
        // Return the tab node if it contains the widget.
        if (node instanceof TabLayoutNode) {
            return searching_1.contains(node.tabBar.titles, widget.title) ? node : null;
        }
        // Recursively search the children of a split layout node.
        for (var i = 0, n = node.children.length; i < n; ++i) {
            var result = findTabNode(node.children.at(i), widget);
            if (result !== null) {
                return result;
            }
        }
        // Otherwise, the widget does not exist in the tree.
        return null;
    }
    Private.findTabNode = findTabNode;
    /**
     * Find the split layout node which contains the given handle.
     *
     * @param node - The root layout node of interest.
     *
     * @param handle - The handle of interest.
     *
     * @returns An object which contains the split node and the index
     *   of the handle, or `null` if the split node is not found.
     */
    function findSplitNode(node, handle) {
        // Bail if the node is not a split node.
        if (node instanceof TabLayoutNode) {
            return null;
        }
        // Return the pair if the node contains the handle.
        var index = searching_1.indexOf(node.handles, handle);
        if (index !== -1) {
            return { index: index, node: node };
        }
        // Recursively search the child split nodes.
        for (var i = 0, n = node.children.length; i < n; ++i) {
            var result = findSplitNode(node.children.at(i), handle);
            if (result !== null) {
                return result;
            }
        }
        // Otherwise, the handle does not exist in the tree.
        return null;
    }
    Private.findSplitNode = findSplitNode;
    /**
     * Recursively fit the given layout node.
     *
     * @param node - The layout node of interest.
     *
     * @param spacing - The spacing to use between tab areas.
     *
     * @returns The computed size limits for the layout node.
     */
    function fitLayoutNode(node, spacing) {
        var limits;
        if (node instanceof TabLayoutNode) {
            limits = fitTabNode(node);
        }
        else {
            limits = fitSplitNode(node, spacing);
        }
        return limits;
    }
    Private.fitLayoutNode = fitLayoutNode;
    /**
     * Recursively update the given layout node.
     *
     * @param node - The layout node of interest.
     *
     * @param x - The offset left position of the layout area.
     *
     * @param y - The offset top position of the layout area.
     *
     * @param width - The width of the layout area.
     *
     * @param height - The height of the layout area.
     *
     * @param spacing - The spacing to use between tab areas.
     */
    function updateLayoutNode(node, x, y, width, height, spacing) {
        if (node instanceof TabLayoutNode) {
            updateTabNode(node, x, y, width, height);
        }
        else {
            updateSplitNode(node, x, y, width, height, spacing);
        }
    }
    Private.updateLayoutNode = updateLayoutNode;
    /**
     * Sync the visibility and orientation of split node handles.
     *
     * @param splitNode - The split node of interest.
     */
    function syncHandles(splitNode) {
        // Do nothing if there are no handles.
        if (splitNode.handles.isEmpty) {
            return;
        }
        // Compute the classes to add and remove.
        var horizontal = splitNode.orientation === 'horizontal';
        var remClass = horizontal ? VERTICAL_CLASS : HORIZONTAL_CLASS;
        var addClass = horizontal ? HORIZONTAL_CLASS : VERTICAL_CLASS;
        // Show all handles and update their orientation.
        iteration_1.each(splitNode.handles, function (handle) {
            handle.classList.remove(HIDDEN_CLASS);
            handle.classList.remove(remClass);
            handle.classList.add(addClass);
        });
        // Hide the last handle.
        splitNode.handles.back.classList.add(HIDDEN_CLASS);
    }
    Private.syncHandles = syncHandles;
    /**
     * Determine the zone for the given node and client position.
     *
     * This assumes the position lies within the node's client rect.
     */
    function calcEdge(node, x, y) {
        var rect = node.getBoundingClientRect();
        var fracX = (x - rect.left) / rect.width;
        var fracY = (y - rect.top) / rect.height;
        var normX = fracX > 0.5 ? 1 - fracX : fracX;
        var normY = fracY > 0.5 ? 1 - fracY : fracY;
        var result;
        if (normX < normY) {
            result = fracX <= 0.5 ? 'left' : 'right';
        }
        else {
            result = fracY <= 0.5 ? 'top' : 'bottom';
        }
        return result;
    }
    Private.calcEdge = calcEdge;
    /**
     * Hold the current sizes of a vector of box sizers.
     *
     * This sets the size hint of each sizer to its current size.
     */
    function holdSizes(sizers) {
        iteration_1.each(sizers, function (sizer) { sizer.sizeHint = sizer.size; });
    }
    Private.holdSizes = holdSizes;
    /**
     * Recursively hold all the layout sizes in the tree.
     *
     * This ignores the sizers of tab layout nodes.
     */
    function holdLayoutSizes(node) {
        if (node instanceof SplitLayoutNode) {
            iteration_1.each(node.children, holdLayoutSizes);
            holdSizes(node.sizers);
        }
    }
    Private.holdLayoutSizes = holdLayoutSizes;
    /**
     * Create a box sizer with an initial size hint.
     */
    function createSizer(hint) {
        var sizer = new boxengine_1.BoxSizer();
        sizer.sizeHint = hint;
        sizer.size = hint;
        return sizer;
    }
    Private.createSizer = createSizer;
    /**
     * Normalize the sizes of a split layout node.
     */
    function normalizeSizes(splitNode) {
        // Bail early if the sizers are empty.
        var n = splitNode.sizers.length;
        if (n === 0) {
            return;
        }
        // Hold the current sizes of the sizers.
        holdSizes(splitNode.sizers);
        // Compute the sum of the sizes.
        var sum = iteration_1.reduce(splitNode.sizers, function (v, sizer) { return v + sizer.sizeHint; }, 0);
        // Normalize the sizes based on the sum.
        if (sum === 0) {
            iteration_1.each(splitNode.sizers, function (sizer) {
                sizer.size = sizer.sizeHint = 1 / n;
            });
        }
        else {
            iteration_1.each(splitNode.sizers, function (sizer) {
                sizer.size = sizer.sizeHint /= sum;
            });
        }
        // Mark the split node as normalized.
        splitNode.normalized = true;
    }
    Private.normalizeSizes = normalizeSizes;
    /**
     * Fit the given tab layout node.
     *
     * @param tabNode - The tab node of interest.
     *
     * @returns The computed size limits for the node.
     */
    function fitTabNode(tabNode) {
        // Setup the limit variables.
        var minWidth = 0;
        var minHeight = 0;
        var maxWidth = Infinity;
        var maxHeight = Infinity;
        // Lookup common variables.
        var tabBar = tabNode.tabBar;
        var tabSizer = tabNode.sizers.at(0);
        var widgetSizer = tabNode.sizers.at(1);
        var currentTitle = tabBar.currentTitle;
        var widget = currentTitle ? currentTitle.owner : null;
        // Adjust the starting max height if a widget is visible.
        if (!tabBar.isHidden || (widget && !widget.isHidden)) {
            maxHeight = 0;
        }
        // Update the results and sizer for the tab bar.
        if (!tabBar.isHidden) {
            var limits = sizing_1.sizeLimits(tabBar.node);
            minWidth = Math.max(minWidth, limits.minWidth);
            maxWidth = Math.min(maxWidth, limits.maxWidth);
            minHeight += limits.minHeight;
            maxHeight += limits.maxHeight;
            tabSizer.minSize = limits.minHeight;
            tabSizer.maxSize = limits.maxHeight;
        }
        else {
            tabSizer.minSize = 0;
            tabSizer.maxSize = 0;
        }
        // Update the results and sizer for the current widget.
        if (widget && !widget.isHidden) {
            var limits = sizing_1.sizeLimits(widget.node);
            minWidth = Math.max(minWidth, limits.minWidth);
            maxWidth = Math.min(maxWidth, limits.maxWidth);
            minHeight += limits.minHeight;
            maxHeight += limits.maxHeight;
            widgetSizer.minSize = limits.minHeight;
            widgetSizer.maxSize = limits.maxHeight;
        }
        else {
            widgetSizer.minSize = 0;
            widgetSizer.maxSize = 0;
        }
        // Return the computed size limits for the layout node.
        return { minWidth: minWidth, minHeight: minHeight, maxWidth: maxWidth, maxHeight: maxHeight };
    }
    /**
     * Recursively fit the given split layout node.
     *
     * @param splitNode - The split node of interest.
     *
     * @returns The computed size limits for the node.
     */
    function fitSplitNode(splitNode, spacing) {
        // Setup the limit variables.
        var minWidth = 0;
        var minHeight = 0;
        var maxWidth = Infinity;
        var maxHeight = Infinity;
        // Compute common values.
        var horizontal = splitNode.orientation === 'horizontal';
        var fixed = Math.max(0, splitNode.children.length - 1) * spacing;
        // Adjust the starting limits for the orientation.
        if (horizontal) {
            minWidth = fixed;
            maxWidth = fixed;
        }
        else {
            minHeight = fixed;
            maxHeight = fixed;
        }
        // Adjust the limits and sizer for each child area.
        for (var i = 0, n = splitNode.children.length; i < n; ++i) {
            var sizer = splitNode.sizers.at(i);
            var child = splitNode.children.at(i);
            var limits = fitLayoutNode(child, spacing);
            if (horizontal) {
                minHeight = Math.max(minHeight, limits.minHeight);
                maxHeight = Math.min(maxHeight, limits.maxHeight);
                minWidth += limits.minWidth;
                maxWidth += limits.maxWidth;
                sizer.minSize = limits.minWidth;
                sizer.maxSize = limits.maxWidth;
            }
            else {
                minWidth = Math.max(minWidth, limits.minWidth);
                maxWidth = Math.min(maxWidth, limits.maxWidth);
                minHeight += limits.minHeight;
                maxHeight += limits.maxHeight;
                sizer.minSize = limits.minHeight;
                sizer.maxSize = limits.maxHeight;
            }
        }
        // Return the computed size limits for the layout node.
        return { minWidth: minWidth, minHeight: minHeight, maxWidth: maxWidth, maxHeight: maxHeight };
    }
    /**
     * Update the given tab layout node.
     *
     * @param tabNode - The tab node of interest.
     *
     * @param x - The offset left position of the layout area.
     *
     * @param y - The offset top position of the layout area.
     *
     * @param width - The width of the layout area.
     *
     * @param height - The height of the layout area.
     */
    function updateTabNode(tabNode, x, y, width, height) {
        // Lookup common variables.
        var tabBar = tabNode.tabBar;
        var tabSizer = tabNode.sizers.at(0);
        var widgetSizer = tabNode.sizers.at(1);
        var currentTitle = tabBar.currentTitle;
        var widget = currentTitle ? currentTitle.owner : null;
        // Distribute the layout space to the sizers.
        boxengine_1.boxCalc(tabNode.sizers, height);
        // Layout the tab bar using the computed size.
        if (!tabBar.isHidden) {
            widget_1.Widget.setGeometry(tabBar, x, y, width, tabSizer.size);
            y += tabSizer.size;
        }
        // Layout the widget using the computed size.
        if (widget && !widget.isHidden) {
            widget_1.Widget.setGeometry(widget, x, y, width, widgetSizer.size);
        }
    }
    /**
     * Update the given split layout node.
     *
     * @param splitNode - The split node of interest.
     *
     * @param x - The offset left position of the layout area.
     *
     * @param y - The offset top position of the layout area.
     *
     * @param width - The width of the layout area.
     *
     * @param height - The height of the layout area.
     *
     * @param spacing - The spacing to use between tab areas.
     */
    function updateSplitNode(splitNode, x, y, width, height, spacing) {
        // Compute the available layout space.
        var horizontal = splitNode.orientation === 'horizontal';
        var fixed = Math.max(0, splitNode.children.length - 1) * spacing;
        var space = Math.max(0, (horizontal ? width : height) - fixed);
        // De-normalize the split node if needed.
        if (splitNode.normalized) {
            iteration_1.each(splitNode.sizers, function (sizer) { sizer.sizeHint *= space; });
            splitNode.normalized = false;
        }
        // Distribute the layout space to the sizers.
        boxengine_1.boxCalc(splitNode.sizers, space);
        // Update the geometry of the child areas and handles.
        for (var i = 0, n = splitNode.children.length; i < n; ++i) {
            var child = splitNode.children.at(i);
            var size = splitNode.sizers.at(i).size;
            var hStyle = splitNode.handles.at(i).style;
            if (horizontal) {
                updateLayoutNode(child, x, y, size, height, spacing);
                x += size;
                hStyle.top = y + "px";
                hStyle.left = x + "px";
                hStyle.width = spacing + "px";
                hStyle.height = height + "px";
                x += spacing;
            }
            else {
                updateLayoutNode(child, x, y, width, size, spacing);
                y += size;
                hStyle.top = y + "px";
                hStyle.left = x + "px";
                hStyle.width = width + "px";
                hStyle.height = spacing + "px";
                y += spacing;
            }
        }
    }
})(Private || (Private = {}));
