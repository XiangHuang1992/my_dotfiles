import { IIterator } from '../algorithm/iteration';
import { Message } from '../core/messaging';
import { ISignal } from '../core/signaling';
import { FocusTracker } from './focustracker';
import { TabBar } from './tabbar';
import { ChildMessage, Layout, ResizeMessage, Widget } from './widget';
/**
 * A widget which provides a flexible docking area for widgets.
 */
export declare class DockPanel extends Widget {
    /**
     * Construct a new dock panel.
     *
     * @param options - The options for initializing the panel.
     */
    constructor(options?: DockPanel.IOptions);
    /**
     * Dispose of the resources held by the panel.
     */
    dispose(): void;
    /**
     * A signal emitted when the current widget has changed.
     */
    currentChanged: ISignal<DockPanel, DockPanel.ICurrentChangedArgs>;
    /**
     * The current widget in the dock panel.
     *
     * #### Notes
     * The current widget is the widget among the added widgets which
     * has the *descendant node* which has most recently been focused.
     *
     * This is the `currentWidget` of an internal `FocusTracker` which
     * tracks all widgets in the dock panel.
     *
     * This will be `null` if there is no current widget.
     *
     * This is a read-only property.
     */
    readonly currentWidget: Widget;
    /**
     * The overlay used by the dock panel.
     */
    readonly overlay: DockPanel.IOverlay;
    /**
     * Get the spacing between the widgets.
     */
    /**
     * Set the spacing between the widgets.
     */
    spacing: number;
    /**
     * Whether the dock panel is empty.
     */
    readonly isEmpty: boolean;
    /**
     * The renderer used by the dock panel.
     */
    readonly renderer: DockPanel.IRenderer;
    /**
     * Create an iterator over the user widgets in the panel.
     *
     * @returns A new iterator over the user widgets in the panel.
     *
     * #### Notes
     * This iterator does not include the generated tab bars.
     */
    widgets(): IIterator<Widget>;
    /**
     * Create an iterator over the tab bars in the panel.
     *
     * @returns A new iterator over the tab bars in the panel.
     *
     * #### Notes
     * This iterator does not include the user widgets.
     */
    tabBars(): IIterator<TabBar>;
    /**
     * Create an iterator over the handles in the panel.
     *
     * @returns A new iterator over the handles in the panel.
     */
    handles(): IIterator<HTMLDivElement>;
    /**
     * Activate the specified widget in the dock panel.
     *
     * @param widget - The widget of interest.
     *
     * #### Notes
     * This will make the widget the current widget in its tab area and
     * post the widget an `activate-request` message.
     */
    activateWidget(widget: Widget): void;
    /**
     * Add a widget to the dock panel.
     *
     * @param widget - The widget to add to the dock panel.
     *
     * @param options - The additional options for adding the widget.
     */
    addWidget(widget: Widget, options?: DockPanel.IAddOptions): void;
    /**
     * Handle the DOM events for the dock panel.
     *
     * @param event - The DOM event sent to the panel.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the panel's DOM node. It should
     * not be called directly by user code.
     */
    handleEvent(event: Event): void;
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    protected onAfterAttach(msg: Message): void;
    /**
     * A message handler invoked on a `'before-detach'` message.
     */
    protected onBeforeDetach(msg: Message): void;
    /**
     * A message handler invoked on a `'child-added'` message.
     */
    protected onChildAdded(msg: ChildMessage): void;
    /**
     * A message handler invoked on a `'child-removed'` message.
     */
    protected onChildRemoved(msg: ChildMessage): void;
    /**
     * Handle the `'p-dragenter'` event for the dock panel.
     */
    private _evtDragEnter(event);
    /**
     * Handle the `'p-dragleave'` event for the dock panel.
     */
    private _evtDragLeave(event);
    /**
     * Handle the `'p-dragover'` event for the dock panel.
     */
    private _evtDragOver(event);
    /**
     * Handle the `'p-drop'` event for the dock panel.
     */
    private _evtDrop(event);
    /**
     * Handle the `'keydown'` event for the dock panel.
     */
    private _evtKeyDown(event);
    /**
     * Handle the `'mousedown'` event for the dock panel.
     */
    private _evtMouseDown(event);
    /**
     * Handle the `'mousemove'` event for the dock panel.
     */
    private _evtMouseMove(event);
    /**
     * Handle the `'mouseup'` event for the dock panel.
     */
    private _evtMouseUp(event);
    /**
     * Release the mouse grab for the dock panel.
     */
    private _releaseMouse();
    /**
     * Find the drop target for the given client position.
     *
     * @param clientX - The client X position of interest.
     *
     * @param clientY - The client Y position of interest.
     *
     * @param shift - Whether to search for shifted drop targets.
     *
     * @returns The dock target at the specified client position.
     */
    private _findDropTarget(clientX, clientY, shift);
    /**
     * Show the overlay indicator at the given client position.
     *
     * @param clientX - The client X position of interest.
     *
     * @param clientY - The client Y position of interest.
     *
     * @param shift - Whether to show the shifted drop targets.
     *
     * @returns The drop zone at the specified client position.
     *
     * #### Notes
     * If the position is not over a valid zone, the overlay is hidden.
     */
    private _showOverlay(clientX, clientY, shift);
    /**
     * Create a new tab bar for use by the panel.
     */
    private _createTabBar();
    /**
     * Create a new handle for use by the panel.
     */
    private _createHandle();
    /**
     * Handle the `tabActivateRequested` signal from a tab bar.
     */
    private _onTabActivateRequested(sender, args);
    /**
     * Handle the `tabCloseRequested` signal from a tab bar.
     */
    private _onTabCloseRequested(sender, args);
    /**
     * Handle the `tabDetachRequested` signal from a tab bar.
     */
    private _onTabDetachRequested(sender, args);
    /**
     * Handle the `currentChanged` signal from the focus tracker.
     */
    private _onCurrentChanged(sender, args);
    private _drag;
    private _overlay;
    private _renderer;
    private _pressData;
    private _tracker;
}
/**
 * The namespace for the `DockPanel` class statics.
 */
export declare namespace DockPanel {
    /**
     * An options object for creating a dock panel.
     */
    interface IOptions {
        /**
         * The overlay to use with the dock panel.
         *
         * The default is a new `Overlay` instance.
         */
        overlay?: IOverlay;
        /**
         * The renderer to use for the dock panel.
         *
         * The default is a shared renderer instance.
         */
        renderer?: IRenderer;
        /**
         * The spacing between the items in the panel.
         *
         * The default is `4`.
         */
        spacing?: number;
    }
    /**
     * An arguments object for the `currentChanged` signal.
     */
    type ICurrentChangedArgs = FocusTracker.ICurrentChangedArgs<Widget>;
    /**
     * A type alias for the supported insertion modes.
     */
    type InsertMode = DockLayout.InsertMode;
    /**
     * A type alias for the add widget options.
     */
    type IAddOptions = DockLayout.IAddOptions;
    /**
     * An object which holds the geometry for overlay positioning.
     */
    interface IOverlayGeometry {
        /**
         * The client X position of the mouse.
         */
        mouseX: number;
        /**
         * The client Y position of the mouse.
         */
        mouseY: number;
        /**
         * The client rect of the overlay parent node.
         */
        parentRect: ClientRect;
        /**
         * The distance between the overlay and parent top edges.
         */
        top: number;
        /**
         * The distance between the overlay and parent left edges.
         */
        left: number;
        /**
         * The distance between the overlay and parent right edges.
         */
        right: number;
        /**
         * The distance between the overlay and parent bottom edges.
         */
        bottom: number;
        /**
         * The width of the overlay.
         */
        width: number;
        /**
         * The height of the overlay.
         */
        height: number;
    }
    /**
     * An object which manages the overlay node for a dock panel.
     */
    interface IOverlay {
        /**
         * The DOM node for the overlay.
         */
        readonly node: HTMLDivElement;
        /**
         * Show the overlay using the given overlay geometry.
         *
         * @param geo - The desired geometry for the overlay.
         *
         * #### Notes
         * The given geometry values assume the node will use absolute
         * positioning.
         *
         * This is called on every mouse move event during a drag in order
         * to update the position of the overlay. It should be efficient.
         */
        show(geo: IOverlayGeometry): void;
        /**
         * Hide the overlay node.
         *
         * @param delay - The delay (in ms) before hiding the overlay.
         *   A delay value <= 0 should hide the overlay immediately.
         *
         * #### Notes
         * This is called whenever the overlay node should been hidden.
         */
        hide(delay: number): void;
    }
    /**
     * A concrete implementation of `IOverlay`.
     *
     * This is the default overlay implementation for a dock panel.
     */
    class Overlay implements IOverlay {
        /**
         * Construct a new overlay.
         */
        constructor();
        /**
         * The DOM node for the overlay.
         */
        readonly node: HTMLDivElement;
        /**
         * Show the overlay using the given overlay geometry.
         *
         * @param geo - The desired geometry for the overlay.
         */
        show(geo: IOverlayGeometry): void;
        /**
         * Hide the overlay node.
         *
         * @param delay - The delay (in ms) before hiding the overlay.
         *   A delay value <= 0 will hide the overlay immediately.
         */
        hide(delay: number): void;
        private _timer;
        private _hidden;
        private _node;
    }
    /**
     * A type alias for a dock panel renderer;
     */
    type IRenderer = DockLayout.IRenderer;
    /**
     * The default implementation of `IRenderer`.
     */
    class Renderer implements IRenderer {
        /**
         * Create a new tab bar for use with a dock panel.
         *
         * @returns A new tab bar for a dock panel.
         */
        createTabBar(): TabBar;
        /**
         * Create a new handle node for use with a dock panel.
         *
         * @returns A new handle node for a dock panel.
         */
        createHandle(): HTMLDivElement;
    }
    /**
     * The default `Renderer` instance.
     */
    const defaultRenderer: Renderer;
}
/**
 * A layout which provides a flexible docking arrangement.
 *
 * #### Notes
 * The layout handles the `currentChanged` signals of the tab bars and
 * the corresponding visibility of the child widgets. The widget which
 * consumes the layout is responsible for all other tab interactions
 * as well as all mouse and drag events.
 */
export declare class DockLayout extends Layout {
    /**
     * Construct a new dock layout.
     *
     * @param options - The options for initializing the layout.
     */
    constructor(options: DockLayout.IOptions);
    /**
     * Dispose of the resources held by the layout.
     *
     * #### Notes
     * This will clear and dispose all widgets in the layout.
     */
    dispose(): void;
    /**
     * Get the inter-element spacing for the dock layout.
     */
    /**
     * Set the inter-element spacing for the dock layout.
     */
    spacing: number;
    /**
     * Whether the dock layout is empty.
     */
    readonly isEmpty: boolean;
    /**
     * The renderer used by the dock layout.
     */
    readonly renderer: DockLayout.IRenderer;
    /**
     * Create an iterator over all widgets in the layout.
     *
     * @returns A new iterator over the widgets in the layout.
     *
     * #### Notes
     * This iterator includes the generated tab bars.
     */
    iter(): IIterator<Widget>;
    /**
     * Create an iterator over the user widgets in the layout.
     *
     * @returns A new iterator over the user widgets in the layout.
     *
     * #### Notes
     * This iterator does not include the generated tab bars.
     */
    widgets(): IIterator<Widget>;
    /**
     * Create an iterator over the tab bars in the layout.
     *
     * @returns A new iterator over the tab bars in the layout.
     *
     * #### Notes
     * This iterator does not include the user widgets.
     */
    tabBars(): IIterator<TabBar>;
    /**
     * Create an iterator over the handles in the layout.
     *
     * @returns A new iterator over the handles in the layout.
     */
    handles(): IIterator<HTMLDivElement>;
    /**
     * Move a handle to the given offset position.
     *
     * @param handle - The handle to move.
     *
     * @param offsetX - The desired offset X position of the handle.
     *
     * @param offsetY - The desired offset Y position of the handle.
     *
     * #### Notes
     * If the given handle is not contained in the layout, this is no-op.
     *
     * The handle will be moved as close as possible to the desired
     * position without violating any of the layout constraints.
     *
     * Only one of the coordinates is used depending on the orientation
     * of the handle. This method accepts both coordinates to make it
     * easy to invoke from a mouse move event without needing to know
     * the handle orientation.
     */
    moveHandle(handle: HTMLDivElement, offsetX: number, offsetY: number): void;
    /**
     * Add a widget to the dock layout.
     *
     * @param widget - The widget to add to the dock layout.
     *
     * @param options - The additional options for adding the widget.
     *
     * #### Notes
     * The widget will be moved if it is already contained in the layout.
     *
     * A warning will be logged if the reference widget is invalid.
     */
    addWidget(widget: Widget, options?: DockLayout.IAddOptions): void;
    /**
     * Remove a widget from the layout.
     *
     * @param widget - The widget to remove from the layout.
     *
     * #### Notes
     * A widget is automatically removed from the layout when its `parent`
     * is set to `null`. This method should only be invoked directly when
     * removing a widget from a layout which has yet to be installed on a
     * parent widget.
     *
     * This method does *not* modify the widget's `parent`.
     */
    removeWidget(widget: Widget): void;
    /**
     * Perform layout initialization which requires the parent widget.
     */
    protected init(): void;
    /**
     * Attach the widget to the layout parent widget.
     *
     * @param widget - The widget to attach to the parent.
     *
     * #### Notes
     * This is a no-op if the widget is already attached.
     */
    protected attachWidget(widget: Widget): void;
    /**
     * Detach the widget from the layout parent widget.
     *
     * @param widget - The widget to detach from the parent.
     *
     * #### Notes
     * This is a no-op if the widget is not attached.
     */
    protected detachWidget(widget: Widget): void;
    /**
     * A message handler invoked on an `'after-show'` message.
     */
    protected onAfterShow(msg: Message): void;
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    protected onAfterAttach(msg: Message): void;
    /**
     * A message handler invoked on a `'child-shown'` message.
     */
    protected onChildShown(msg: ChildMessage): void;
    /**
     * A message handler invoked on a `'child-hidden'` message.
     */
    protected onChildHidden(msg: ChildMessage): void;
    /**
     * A message handler invoked on a `'resize'` message.
     */
    protected onResize(msg: ResizeMessage): void;
    /**
     * A message handler invoked on an `'update-request'` message.
     */
    protected onUpdateRequest(msg: Message): void;
    /**
     * A message handler invoked on a `'fit-request'` message.
     */
    protected onFitRequest(msg: Message): void;
    /**
     * Remove the specified widget from the layout structure.
     *
     * @param widget - The widget to remove from the layout.
     *
     * #### Notes
     * This is a no-op if the widget is not in the layout tree.
     *
     * This does not detach the widget from the parent node.
     */
    private _removeWidget(widget);
    /**
     * Insert a widget next to an existing tab.
     *
     * @param widget - The widget to add to the layout.
     *
     * @param ref - The reference widget, or `null`.
     *
     * @param refNode - The layout node for the ref widget, or `null`.
     *
     * @param after - Whether to insert the widget after the ref.
     *
     * #### Notes
     * This assumes the target widget is not in the layout tree.
     *
     * This does not attach the widget to the parent widget.
     */
    private _insertTab(widget, ref, refNode, after);
    /**
     * Insert a widget as a new split area.
     *
     * @param widget - The widget to add to the layout.
     *
     * @param ref - The reference widget, or `null`.
     *
     * @param refNode - The layout node for the ref widget, or `null`.
     *
     * @param orientation - The orientation for the split.
     *
     * @param after - Whether to insert the widget after the ref.
     *
     * #### Notes
     * This assumes the target widget is not in the layout tree.
     *
     * This does not attach the widget to the parent widget.
     */
    private _insertSplit(widget, ref, refNode, orientation, after);
    /**
     * Ensure the root is a split node with the given orientation.
     *
     * @param orientation - The required orientation of the root.
     *
     * @returns The new root node (as a convenience).
     */
    private _splitRoot(orientation);
    /**
     * Fit the layout to the total size required by the widgets.
     */
    private _fit();
    /**
     * Update the layout position and size of the widgets.
     *
     * The parent offset dimensions should be `-1` if unknown.
     */
    private _update(offsetWidth, offsetHeight);
    /**
     * Create a new tab bar for use by the dock layout.
     *
     * #### Notes
     * The tab bar will be attached to the parent if it exists.
     */
    private _createTabBar();
    /**
     * Create a new handle for the dock layout.
     *
     * #### Notes
     * The handle will be attached to the parent if it exists.
     */
    private _createHandle();
    /**
     * Handle the `currentChanged` signal from a tab bar in the layout.
     */
    private _onCurrentChanged(sender, args);
    private _dirty;
    private _spacing;
    private _box;
    private _renderer;
    private _root;
}
/**
 * The namespace for the `DockLayout` class statics.
 */
export declare namespace DockLayout {
    /**
     * An options object for creating a dock layout.
     */
    interface IOptions {
        /**
         * The renderer to use for the dock layout.
         */
        renderer: IRenderer;
        /**
         * The spacing between items in the layout.
         */
        spacing: number;
    }
    /**
     * A renderer for use with a dock layout.
     */
    interface IRenderer {
        /**
         * Create a new tab bar for use with a dock layout.
         *
         * @returns A new tab bar for a dock layout.
         */
        createTabBar(): TabBar;
        /**
         * Create a new handle node for use with a dock layout.
         *
         * @returns A new handle node for a dock layout.
         */
        createHandle(): HTMLDivElement;
    }
    /**
     * A type alias for the supported insertion modes.
     *
     * An insert mode is used to specify how a widget should be added
     * to the dock layout relative to a reference widget.
     */
    type InsertMode = ('split-top' | 'split-left' | 'split-right' | 'split-bottom' | 'tab-before' | 'tab-after');
    /**
     * An options object for adding a widget to the dock layout.
     */
    interface IAddOptions {
        /**
         * The insertion mode for adding the widget.
         *
         * The default is `'tab-after'`.
         */
        mode?: InsertMode;
        /**
         * The reference widget for the insert location.
         *
         * The default is `null`.
         */
        ref?: Widget;
    }
}
