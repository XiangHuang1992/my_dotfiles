"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
var iteration_1 = require("../algorithm/iteration");
var mutation_1 = require("../algorithm/mutation");
var searching_1 = require("../algorithm/searching");
var vector_1 = require("../collections/vector");
var query_1 = require("../dom/query");
var widget_1 = require("./widget");
/**
 * The class name added to a menu bar widget.
 */
var MENU_BAR_CLASS = 'p-MenuBar';
/**
 * The class name added to a menu bar content node.
 */
var CONTENT_CLASS = 'p-MenuBar-content';
/**
 * The class name added to an open menu bar menu.
 */
var MENU_CLASS = 'p-MenuBar-menu';
/**
 * The class name added to a menu bar item node.
 */
var ITEM_CLASS = 'p-MenuBar-item';
/**
 * The class name added to a menu bar item icon node.
 */
var ICON_CLASS = 'p-MenuBar-itemIcon';
/**
 * The class name added to a menu bar item label node.
 */
var LABEL_CLASS = 'p-MenuBar-itemLabel';
/**
 * The class name added to a menu bar item mnemonic node.
 */
var MNEMONIC_CLASS = 'p-MenuBar-itemMnemonic';
/**
 * The class name added to an active menu bar and item.
 */
var ACTIVE_CLASS = 'p-mod-active';
/**
 * A widget which displays menus as a canonical menu bar.
 */
var MenuBar = (function (_super) {
    __extends(MenuBar, _super);
    /**
     * Construct a new menu bar.
     *
     * @param options - The options for initializing the menu bar.
     */
    function MenuBar(options) {
        var _this = _super.call(this, { node: Private.createNode() }) || this;
        _this._activeIndex = -1;
        _this._childMenu = null;
        _this._menus = new vector_1.Vector();
        _this._nodes = new vector_1.Vector();
        _this.addClass(MENU_BAR_CLASS);
        _this.setFlag(widget_1.WidgetFlag.DisallowLayout);
        _this._keymap = options.keymap;
        _this._renderer = options.renderer || MenuBar.defaultRenderer;
        return _this;
    }
    /**
     * Dispose of the resources held by the widget.
     */
    MenuBar.prototype.dispose = function () {
        this._closeChildMenu();
        this._menus.clear();
        this._nodes.clear();
        this._keymap = null;
        this._renderer = null;
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(MenuBar.prototype, "contentNode", {
        /**
         * Get the menu bar content node.
         *
         * #### Notes
         * This is the node which holds the menu title nodes.
         *
         * Modifying this node directly can lead to undefined behavior.
         *
         * This is a read-only property.
         */
        get: function () {
            return this.node.getElementsByClassName(CONTENT_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MenuBar.prototype, "keymap", {
        /**
         * The keymap used by the menu bar.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._keymap;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MenuBar.prototype, "renderer", {
        /**
         * The renderer used by the menu bar.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._renderer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MenuBar.prototype, "menus", {
        /**
         * A read-only sequence of the menus in the menu bar.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._menus;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MenuBar.prototype, "childMenu", {
        /**
         * Get the child menu of the menu bar.
         *
         * #### Notes
         * This will be `null` if the menu bar does not have an open menu.
         *
         * This is a read-only property.
         */
        get: function () {
            return this._childMenu;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MenuBar.prototype, "activeMenu", {
        /**
         * Get the currently active menu.
         *
         * #### Notes
         * This will be `null` if no menu is active.
         */
        get: function () {
            var i = this._activeIndex;
            return i !== -1 ? this._menus.at(i) : null;
        },
        /**
         * Set the currently active menu.
         *
         * #### Notes
         * If the menu does not exist, the menu will be set to `null`.
         */
        set: function (value) {
            this.activeIndex = searching_1.indexOf(this._menus, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MenuBar.prototype, "activeIndex", {
        /**
         * Get the index of the currently active menu.
         *
         * #### Notes
         * This will be `-1` if no menu is active.
         */
        get: function () {
            return this._activeIndex;
        },
        /**
         * Set the index of the currently active menu.
         *
         * #### Notes
         * If the index is out of range, the index will be set to `-1`.
         */
        set: function (value) {
            // Coerce the value to an index.
            var i = Math.floor(value);
            if (i < 0 || i >= this._menus.length) {
                i = -1;
            }
            // Bail early if the index will not change.
            if (this._activeIndex === i) {
                return;
            }
            // Remove the active class from the old node.
            if (this._activeIndex !== -1) {
                var node = this._nodes.at(this._activeIndex);
                node.classList.remove(ACTIVE_CLASS);
            }
            // Add the active class to the new node.
            if (i !== -1) {
                var node = this._nodes.at(i);
                node.classList.add(ACTIVE_CLASS);
            }
            // Update the active index.
            this._activeIndex = i;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Open the active menu and activate its first menu item.
     *
     * #### Notes
     * If there is no active menu, this is a no-op.
     */
    MenuBar.prototype.openActiveMenu = function () {
        // Bail early if there is no active item.
        if (this._activeIndex === -1) {
            return;
        }
        // Open the child menu.
        this._openChildMenu();
        // Activate the first item in the child menu.
        if (this._childMenu) {
            this._childMenu.activeIndex = -1;
            this._childMenu.activateNextItem();
        }
    };
    /**
     * Add a menu to the end of the menu bar.
     *
     * @param menu - The menu to add to the menu bar.
     *
     * #### Notes
     * If the menu is already added to the menu bar, it will be moved.
     */
    MenuBar.prototype.addMenu = function (menu) {
        this.insertMenu(this._menus.length, menu);
    };
    /**
     * Insert a menu into the menu bar at the specified index.
     *
     * @param index - The index at which to insert the menu.
     *
     * @param menu - The menu to insert into the menu bar.
     *
     * #### Notes
     * The index will be clamped to the bounds of the menus.
     *
     * If the menu is already added to the menu bar, it will be moved.
     */
    MenuBar.prototype.insertMenu = function (index, menu) {
        // Close the child menu before making changes.
        this._closeChildMenu();
        // Look up the index of the menu.
        var i = searching_1.indexOf(this._menus, menu);
        // Clamp the insert index to the vector bounds.
        var j = Math.max(0, Math.min(Math.floor(index), this._menus.length));
        // If the menu is not in the vector, insert it.
        if (i === -1) {
            // Create the new item node for the menu.
            var node = this._renderer.createItemNode();
            this._renderer.updateItemNode(node, menu.title);
            // Insert the node and menu into the vectors.
            this._nodes.insert(j, node);
            this._menus.insert(j, menu);
            // Add the styling class to the menu.
            menu.addClass(MENU_CLASS);
            // Look up the next sibling node.
            var ref_1 = j + 1 < this._nodes.length ? this._nodes.at(j + 1) : null;
            // Insert the item node into the content node.
            this.contentNode.insertBefore(node, ref_1);
            // Connect to the menu signals.
            menu.aboutToClose.connect(this._onMenuAboutToClose, this);
            menu.menuRequested.connect(this._onMenuMenuRequested, this);
            menu.title.changed.connect(this._onTitleChanged, this);
            // There is nothing more to do.
            return;
        }
        // Otherwise, the menu exists in the vector and should be moved.
        // Adjust the index if the location is at the end of the vector.
        if (j === this._menus.length)
            j--;
        // Bail if there is no effective move.
        if (i === j)
            return;
        // Move the item node and menu to the new locations.
        mutation_1.move(this._nodes, i, j);
        mutation_1.move(this._menus, i, j);
        // Look up the next sibling node.
        var ref = j + 1 < this._nodes.length ? this._nodes.at(j + 1) : null;
        // Move the node in the content node.
        this.contentNode.insertBefore(this._nodes.at(j), ref);
    };
    /**
     * Remove a menu from the menu bar.
     *
     * @param menu - The menu to remove from the menu bar.
     *
     * @returns The index occupied by the menu, or `-1` if the menu
     *   was not contained in the menu bar.
     */
    MenuBar.prototype.removeMenu = function (menu) {
        var index = searching_1.indexOf(this._menus, menu);
        if (index !== -1)
            this.removeMenuAt(index);
        return index;
    };
    /**
     * Remove the menu at a given index from the menu bar.
     *
     * @param index - The index of the menu to remove.
     *
     * @returns The menu occupying the index, or `null` if the index
     *   is out of range.
     */
    MenuBar.prototype.removeMenuAt = function (index) {
        // Bail if the index is out of range.
        var i = Math.floor(index);
        if (i < 0 || i >= this._menus.length) {
            return null;
        }
        // Close the child menu before making changes.
        this._closeChildMenu();
        // Remove the node and menu from the vectors.
        var node = this._nodes.removeAt(i);
        var menu = this._menus.removeAt(i);
        // Disconnect from the menu signals.
        menu.aboutToClose.disconnect(this._onMenuAboutToClose, this);
        menu.menuRequested.disconnect(this._onMenuMenuRequested, this);
        menu.title.changed.disconnect(this._onTitleChanged, this);
        // Remove the node from the content node.
        this.contentNode.removeChild(node);
        // Remove the styling class from the menu.
        menu.removeClass(MENU_CLASS);
        // Return the removed menu.
        return menu;
    };
    /**
     * Remove all menus from the menu bar.
     */
    MenuBar.prototype.clearMenus = function () {
        var _this = this;
        // Bail if there is nothing to remove.
        if (this._menus.length === 0) {
            return;
        }
        // Close the child menu before making changes.
        this._closeChildMenu();
        // Disconnect from the menu signals and remove the styling class.
        iteration_1.each(this._menus, function (menu) {
            menu.aboutToClose.disconnect(_this._onMenuAboutToClose, _this);
            menu.menuRequested.disconnect(_this._onMenuMenuRequested, _this);
            menu.title.changed.disconnect(_this._onTitleChanged, _this);
            menu.removeClass(MENU_CLASS);
        });
        // Clear the node and menus vectors.
        this._nodes.clear();
        this._menus.clear();
        // Clear the content node.
        this.contentNode.textContent = '';
    };
    /**
     * Handle the DOM events for the menu bar.
     *
     * @param event - The DOM event sent to the menu bar.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the menu bar's DOM nodes. It
     * should not be called directly by user code.
     */
    MenuBar.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'keydown':
                this._evtKeyDown(event);
                break;
            case 'mousedown':
                this._evtMouseDown(event);
                break;
            case 'mousemove':
                this._evtMouseMove(event);
                break;
            case 'mouseleave':
                this._evtMouseLeave(event);
                break;
            case 'contextmenu':
                event.preventDefault();
                event.stopPropagation();
                break;
        }
    };
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    MenuBar.prototype.onAfterAttach = function (msg) {
        this.node.addEventListener('keydown', this);
        this.node.addEventListener('mousedown', this);
        this.node.addEventListener('mousemove', this);
        this.node.addEventListener('mouseleave', this);
        this.node.addEventListener('contextmenu', this);
    };
    /**
     * A message handler invoked on a `'before-detach'` message.
     */
    MenuBar.prototype.onBeforeDetach = function (msg) {
        this.node.removeEventListener('keydown', this);
        this.node.removeEventListener('mousedown', this);
        this.node.removeEventListener('mousemove', this);
        this.node.removeEventListener('mouseleave', this);
        this.node.removeEventListener('contextmenu', this);
        this._closeChildMenu();
    };
    /**
     * A message handler invoked on an `'activate-request'` message.
     */
    MenuBar.prototype.onActivateRequest = function (msg) {
        if (this.isAttached)
            this.node.focus();
    };
    /**
     * A message handler invoked on an `'update-request'` message.
     */
    MenuBar.prototype.onUpdateRequest = function (msg) {
        // Fetch common variables.
        var menus = this._menus;
        var nodes = this._nodes;
        var renderer = this._renderer;
        // Update the state of the item nodes.
        for (var i = 0, n = menus.length; i < n; ++i) {
            renderer.updateItemNode(nodes.at(i), menus.at(i).title);
        }
        // Add the active class to the active item.
        if (this._activeIndex !== -1) {
            nodes.at(this._activeIndex).classList.add(ACTIVE_CLASS);
        }
    };
    /**
     * Handle the `'keydown'` event for the menu bar.
     */
    MenuBar.prototype._evtKeyDown = function (event) {
        // A menu bar handles all keydown events.
        event.preventDefault();
        event.stopPropagation();
        // Fetch the key code for the event.
        var kc = event.keyCode;
        // Enter, Up Arrow, Down Arrow
        if (kc === 13 || kc === 38 || kc === 40) {
            this.openActiveMenu();
            return;
        }
        // Escape
        if (kc === 27) {
            this._closeChildMenu();
            this.activeIndex = -1;
            this.node.blur();
            return;
        }
        // Left Arrow
        if (kc === 37) {
            var i = this._activeIndex;
            var n_1 = this._menus.length;
            this.activeIndex = i === 0 ? n_1 - 1 : i - 1;
            return;
        }
        // Right Arrow
        if (kc === 39) {
            var i = this._activeIndex;
            var n_2 = this._menus.length;
            this.activeIndex = i === n_2 - 1 ? 0 : i + 1;
            return;
        }
        // The following code activates an item by mnemonic.
        // Get the pressed key character for the current layout.
        var key = this._keymap.layout.keyForKeydownEvent(event);
        // Bail if the key is not valid for the current layout.
        if (!key) {
            return;
        }
        // Normalize the case of the key.
        key = key.toUpperCase();
        // Setup the storage for the search results.
        var mnIndex = -1;
        var autoIndex = -1;
        var mnMultiple = false;
        // Search for the best mnemonic menu. This searches the menus
        // starting at the active index and finds the following:
        //   - the index of the first matching mnemonic menu
        //   - whether there are multiple matching mnemonic menus
        //   - the index of the first menu with no mnemonic, but
        //     which has a matching first character.
        var n = this._menus.length;
        var j = this._activeIndex + 1;
        for (var i = 0; i < n; ++i) {
            var k = (i + j) % n;
            var title = this._menus.at(k).title;
            if (title.label.length === 0) {
                continue;
            }
            var mn = title.mnemonic;
            if (mn >= 0 && mn < title.label.length) {
                if (title.label[mn].toUpperCase() === key) {
                    if (mnIndex === -1) {
                        mnIndex = k;
                    }
                    else {
                        mnMultiple = true;
                    }
                }
            }
            else if (autoIndex === -1) {
                if (title.label[0].toUpperCase() === key) {
                    autoIndex = k;
                }
            }
        }
        // Handle the requested mnemonic based on the search results.
        // If exactly one mnemonic is matched, that menu is opened.
        // Otherwise, the next mnemonic is activated if available,
        // followed by the auto mnemonic if available.
        if (mnIndex !== -1 && !mnMultiple) {
            this.activeIndex = mnIndex;
            this.openActiveMenu();
        }
        else if (mnIndex !== -1) {
            this.activeIndex = mnIndex;
        }
        else if (autoIndex !== -1) {
            this.activeIndex = autoIndex;
        }
    };
    /**
     * Handle the `'mousedown'` event for the menu bar.
     */
    MenuBar.prototype._evtMouseDown = function (event) {
        // Bail if the mouse press was not on the menu bar. This can occur
        // when the document listener is installed for an active menu bar.
        var x = event.clientX;
        var y = event.clientY;
        if (!query_1.hitTest(this.node, x, y)) {
            return;
        }
        // Stop the propagation of the event. Immediate propagation is
        // also stopped so that an open menu does not handle the event.
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
        // Check if the mouse is over one of the menu items.
        var i = searching_1.findIndex(this._nodes, function (node) { return query_1.hitTest(node, x, y); });
        // If the press was not on an item, close the child menu.
        if (i === -1) {
            this._closeChildMenu();
            return;
        }
        // If the press was not the left mouse button, do nothing further.
        if (event.button !== 0) {
            return;
        }
        // Otherwise, toggle the open state of the child menu.
        if (this._childMenu) {
            this._closeChildMenu();
            this.activeIndex = i;
        }
        else {
            this.activeIndex = i;
            this._openChildMenu();
        }
    };
    /**
     * Handle the `'mousemove'` event for the menu bar.
     */
    MenuBar.prototype._evtMouseMove = function (event) {
        // Check if the mouse is over one of the menu items.
        var x = event.clientX;
        var y = event.clientY;
        var i = searching_1.findIndex(this._nodes, function (node) { return query_1.hitTest(node, x, y); });
        // Bail early if the active index will not change.
        if (i === this._activeIndex) {
            return;
        }
        // Bail early if a child menu is open and the mouse is not over
        // an item. This allows the child menu to be kept open when the
        // mouse is over the empty part of the menu bar.
        if (i === -1 && this._childMenu) {
            return;
        }
        // Update the active index to the hovered item.
        this.activeIndex = i;
        // Open the new menu if a menu is already open.
        if (this._childMenu) {
            this._openChildMenu();
        }
    };
    /**
     * Handle the `'mouseleave'` event for the menu bar.
     */
    MenuBar.prototype._evtMouseLeave = function (event) {
        // Reset the active index if there is no open menu.
        if (!this._childMenu) {
            this.activeIndex = -1;
        }
    };
    /**
     * Open the child menu at the active index immediately.
     *
     * If a different child menu is already open, it will be closed,
     * even if there is no active menu.
     */
    MenuBar.prototype._openChildMenu = function () {
        // If there is no active menu, close the current menu.
        var newMenu = this.activeMenu;
        if (!newMenu) {
            this._closeChildMenu();
            return;
        }
        // Bail, if there is no effective menu change.
        var oldMenu = this._childMenu;
        if (oldMenu === newMenu) {
            return;
        }
        // Swap the internal menu reference.
        this._childMenu = newMenu;
        // Close the current menu, or setup for the new menu.
        if (oldMenu) {
            oldMenu.close();
        }
        else {
            this.addClass(ACTIVE_CLASS);
            document.addEventListener('mousedown', this, true);
        }
        // Get the positioning data for the new menu.
        var node = this._nodes.at(this._activeIndex);
        var _a = node.getBoundingClientRect(), left = _a.left, bottom = _a.bottom;
        // Open the new menu at the computed location.
        newMenu.open(left, bottom, { forceX: true, forceY: true });
    };
    /**
     * Close the child menu immediately.
     *
     * This is a no-op if a child menu is not open.
     */
    MenuBar.prototype._closeChildMenu = function () {
        // Bail if no child menu is open.
        if (!this._childMenu) {
            return;
        }
        // Remove the active class from the menu bar.
        this.removeClass(ACTIVE_CLASS);
        // Remove the document listeners.
        document.removeEventListener('mousedown', this, true);
        // Clear the internal menu reference.
        var menu = this._childMenu;
        this._childMenu = null;
        // Close the menu.
        menu.close();
        // Reset the active index.
        this.activeIndex = -1;
    };
    /**
     * Handle the `aboutToClose` signal of a menu.
     */
    MenuBar.prototype._onMenuAboutToClose = function (sender) {
        // Bail if the sender is not the child menu.
        if (sender !== this._childMenu) {
            return;
        }
        // Remove the active class from the menu bar.
        this.removeClass(ACTIVE_CLASS);
        // Remove the document listeners.
        document.removeEventListener('mousedown', this, true);
        // Clear the internal menu reference.
        this._childMenu = null;
        // Reset the active index.
        this.activeIndex = -1;
    };
    /**
     * Handle the `menuRequested` signal of a child menu.
     */
    MenuBar.prototype._onMenuMenuRequested = function (sender, args) {
        // Bail if the sender is not the child menu.
        if (sender !== this._childMenu) {
            return;
        }
        // Lookup the active index and menu count.
        var i = this._activeIndex;
        var n = this._menus.length;
        // Active the next requested index.
        switch (args) {
            case 'next':
                this.activeIndex = i === n - 1 ? 0 : i + 1;
                break;
            case 'previous':
                this.activeIndex = i === 0 ? n - 1 : i - 1;
                break;
        }
        // Open the active menu.
        this.openActiveMenu();
    };
    /**
     * Handle the `changed` signal of a title object.
     */
    MenuBar.prototype._onTitleChanged = function (sender) {
        this.update();
    };
    return MenuBar;
}(widget_1.Widget));
exports.MenuBar = MenuBar;
/**
 * The namespaces for the `MenuBar` class statics.
 */
(function (MenuBar) {
    /**
     * The default implementation of `IRenderer`.
     */
    var Renderer = (function () {
        function Renderer() {
        }
        /**
         * Create a node for a menu bar item.
         *
         * @returns A new node for a menu bar item.
         */
        Renderer.prototype.createItemNode = function () {
            var node = document.createElement('li');
            var icon = document.createElement('div');
            var label = document.createElement('div');
            node.className = ITEM_CLASS;
            icon.className = ICON_CLASS;
            label.className = LABEL_CLASS;
            node.appendChild(icon);
            node.appendChild(label);
            return node;
        };
        /**
         * Update an item node to reflect the state of a menu title.
         *
         * @param node - A node created by a call to `createItemNode`.
         *
         * @param title - The menu title holding the data for the node.
         */
        Renderer.prototype.updateItemNode = function (node, title) {
            var icon = node.firstChild;
            var label = node.lastChild;
            var itemClass = ITEM_CLASS;
            var iconClass = ICON_CLASS;
            if (title.className)
                itemClass += " " + title.className;
            if (title.icon)
                iconClass += " " + title.icon;
            node.className = itemClass;
            icon.className = iconClass;
            label.innerHTML = this.formatLabel(title.label, title.mnemonic);
        };
        /**
         * Format a label into HTML for display.
         *
         * @param label - The label text of interest.
         *
         * @param mnemonic - The index of the mnemonic character.
         *
         * @return The formatted label HTML for display.
         */
        Renderer.prototype.formatLabel = function (label, mnemonic) {
            // If the index is out of range, do not modify the label.
            if (mnemonic < 0 || mnemonic >= label.length) {
                return label;
            }
            // Split the label into parts.
            var pref = label.slice(0, mnemonic);
            var suff = label.slice(mnemonic + 1);
            var char = label[mnemonic];
            // Join the label with the mnemonic span.
            return pref + "<span class=\"" + MNEMONIC_CLASS + "\">" + char + "</span>" + suff;
        };
        return Renderer;
    }());
    MenuBar.Renderer = Renderer;
    /**
     * The default `Renderer` instance.
     */
    MenuBar.defaultRenderer = new Renderer();
})(MenuBar = exports.MenuBar || (exports.MenuBar = {}));
exports.MenuBar = MenuBar;
/**
 * The namespace for the private module data.
 */
var Private;
(function (Private) {
    /**
     * Create the DOM node for a menu bar.
     */
    function createNode() {
        var node = document.createElement('div');
        var content = document.createElement('ul');
        content.className = CONTENT_CLASS;
        node.appendChild(content);
        node.tabIndex = -1;
        return node;
    }
    Private.createNode = createNode;
})(Private || (Private = {}));
