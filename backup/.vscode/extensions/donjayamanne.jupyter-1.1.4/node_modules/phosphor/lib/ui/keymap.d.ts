import { JSONObject } from '../algorithm/json';
import { ISequence } from '../algorithm/sequence';
import { IDisposable } from '../core/disposable';
import { ISignal } from '../core/signaling';
import { CommandRegistry } from './commandregistry';
import { IKeyboardLayout } from './keyboard';
/**
 * A class which manages a collection of key bindings.
 */
export declare class Keymap {
    /**
     * Construct a new keymap.
     *
     * @param options - The options for initializing the keymap.
     */
    constructor(options: Keymap.IOptions);
    /**
     * A signal emitted when a key binding is changed.
     */
    bindingChanged: ISignal<Keymap, Keymap.IBindingChangedArgs>;
    /**
     * A signal emitted when the keyboard layout has changed.
     */
    layoutChanged: ISignal<Keymap, Keymap.ILayoutChangedArgs>;
    /**
     * The command registry used by the keymap.
     *
     * #### Notes
     * This is a read-only property.
     */
    readonly commands: CommandRegistry;
    /**
     * Get the keyboard layout used by the keymap.
     *
     * #### Notes
     * The default is a US English layout.
     */
    /**
     * Set the keyboard layout used by the keymap.
     *
     * #### Notes
     * A keymap requires a keyboard layout, so setting this value to
     * `null` will revert the layout to the default US English layout.
     */
    layout: IKeyboardLayout;
    /**
     * A read-only sequence of the key bindings in the keymap.
     *
     * #### Notes
     * This is a read-only property.
     */
    readonly bindings: ISequence<Keymap.IBinding>;
    /**
     * Find a key binding which matches the given command and args.
     *
     * @param command - The id of the command of interest.
     *
     * @param args - The arguments for the command.
     *
     * @returns The most recently added key binding which matches the
     *   specified command and args, or `null` if no match is found.
     *
     * #### Notes
     * This is a convenience method which searches through the public
     * sequence of key `bindings`. If custom search behavior is needed,
     * user code may search that sequence manually.
     */
    findBinding(command: string, args: JSONObject): Keymap.IBinding;
    /**
     * Add a key binding to the keymap.
     *
     * @param options - The options for creating the key binding.
     *
     * @returns A disposable which removes the added key binding.
     *
     * #### Notes
     * If multiple key bindings are registered for the same sequence, the
     * binding with the highest selector specificity is executed first. A
     * tie is broken by using the most recently added key binding.
     *
     * Ambiguous key bindings are resolved with a timeout. As an example,
     * suppose two key bindings are registered: one with the key sequence
     * `['Ctrl D']`, and another with `['Ctrl D', 'Ctrl W']`. If the user
     * presses `Ctrl D`, the first binding cannot be immediately executed
     * since the user may intend to complete the chord with `Ctrl W`. For
     * such cases, a timer is used to allow the chord to be completed. If
     * the chord is not completed before the timeout, the first binding
     * is executed.
     */
    addBinding(options: Keymap.IBindingOptions): IDisposable;
    /**
     * Process a `'keydown'` event and invoke a matching key binding.
     *
     * @param event - The event object for a `'keydown'` event.
     *
     * #### Notes
     * This should be called in response to a `'keydown'` event in order
     * to invoke the command for the best matching key binding.
     *
     * The keymap **does not** install its own key event listeners. This
     * allows the application full control over the nodes for which the
     * keymap processes `'keydown'` events.
     */
    processKeydownEvent(event: KeyboardEvent): void;
    /**
     * Start or restart the pending timeout.
     */
    private _startTimer();
    /**
     * Clear the pending timeout.
     */
    private _clearTimer();
    /**
     * Clear the internal pending state.
     */
    private _clearPendingState();
    /**
     * Replay the events which were suppressed.
     */
    private _replayEvents();
    /**
     * Execute the command for the given key binding.
     *
     * If the command is disabled, a message will be logged.
     */
    private _execute(binding);
    /**
     * Handle the partial match timeout.
     */
    private _onPendingTimeout();
    private _timerID;
    private _replaying;
    private _keys;
    private _layout;
    private _commands;
    private _events;
    private _exact;
    private _bindings;
}
/**
 * The namespace for the `Keymap` class statics.
 */
export declare namespace Keymap {
    /**
     * An options object for initializing a keymap.
     */
    interface IOptions {
        /**
         * The command registry to use with the keymap.
         */
        commands: CommandRegistry;
        /**
         * The keyboard layout to use with the keymap.
         *
         * The default is a US English keyboard layout.
         */
        layout?: IKeyboardLayout;
    }
    /**
     * An options object for creating a key binding.
     */
    interface IBindingOptions {
        /**
         * The default key sequence for the key binding.
         *
         * A key sequence is composed of one or more keystrokes, where each
         * keystroke is a combination of modifiers and a primary key.
         *
         * Most key sequences will contain a single keystroke. Key sequences
         * with multiple keystrokes are called "chords", and are useful for
         * implementing modal input (ala Vim).
         *
         * Each keystroke in the sequence should be of the form:
         *   `[<modifier 1> [<modifier 2> [<modifier N> ]]]<primary key>`
         *
         * The supported modifiers are: `Accel`, `Alt`, `Cmd`, `Ctrl`, and
         * `Shift`. The `Accel` modifier is translated to `Cmd` on Mac and
         * `Ctrl` on all other platforms. The `Cmd` modifier is ignored on
         * non-Mac platforms.
         *
         * Keystrokes are case sensitive.
         *
         * **Examples:** `['Accel C']`, `['Shift F11']`, `['D', 'D']`
         */
        keys: string[];
        /**
         * The CSS selector for the binding.
         *
         * The binding will only be invoked when the selector matches a
         * node on the propagation path of the keydown event. This allows
         * the binding to be restricted to user-defined contexts.
         */
        selector: string;
        /**
         * The command to execute when the binding is matched.
         */
        command: string;
        /**
         * The arguments for the command, if necessary.
         */
        args?: JSONObject;
        /**
         * The key sequence to use when running on Windows.
         *
         * If provided, this will override `keys` on Windows platforms.
         */
        winKeys?: string[];
        /**
         * The key sequence to use when running on Mac.
         *
         * If provided, this will override `keys` on Mac platforms.
         */
        macKeys?: string[];
        /**
         * The key sequence to use when running on Linux.
         *
         * If provided, this will override `keys` on Linux platforms.
         */
        linuxKeys?: string[];
    }
    /**
     * An object which represents a key binding.
     *
     * #### Notes
     * A binding is an immutable object created by a keymap.
     */
    interface IBinding {
        /**
         * The key sequence for the binding.
         */
        keys: string[];
        /**
         * The CSS selector for the binding.
         */
        selector: string;
        /**
         * The command executed when the binding is matched.
         */
        command: string;
        /**
         * The arguments for the command.
         */
        args: JSONObject;
    }
    /**
     * An arguments object for the `bindingChanged` signal.
     */
    interface IBindingChangedArgs {
        /**
         * The keybinding which was changed.
         */
        binding: IBinding;
        /**
         * Whether the binding was added or removed.
         */
        type: 'added' | 'removed';
    }
    /**
     * An arguments object for the `layoutChanged` signal.
     */
    interface ILayoutChangedArgs {
        /**
         * The old value for the keyboard layout.
         */
        oldValue: IKeyboardLayout;
        /**
         * The new value for the keyboard layout.
         */
        newValue: IKeyboardLayout;
    }
    /**
     * An object which holds the results of parsing a keystroke.
     */
    interface IKeystrokeParts {
        /**
         * Whether `'Cmd'` appears in the keystroke.
         */
        cmd: boolean;
        /**
         * Whether `'Ctrl'` appears in the keystroke.
         */
        ctrl: boolean;
        /**
         * Whether `'Alt'` appears in the keystroke.
         */
        alt: boolean;
        /**
         * Whether `'Shift'` appears in the keystroke.
         */
        shift: boolean;
        /**
         * The primary key for the keystroke.
         */
        key: string;
    }
    /**
     * Parse a keystroke into its constituent components.
     *
     * @param keystroke - The keystroke of interest.
     *
     * @returns The parsed components of the keystroke.
     *
     * #### Notes
     * The keystroke should be of the form:
     *   `[<modifier 1> [<modifier 2> [<modifier N> ]]]<primary key>`
     *
     * The supported modifiers are: `Accel`, `Alt`, `Cmd`, `Ctrl`, and
     * `Shift`. The `Accel` modifier is translated to `Cmd` on Mac and
     * `Ctrl` on all other platforms.
     *
     * The parsing is tolerant and will not throw exceptions. Notably:
     *   - Duplicate modifiers are ignored.
     *   - Extra primary keys are ignored.
     *   - The order of modifiers and primary key is irrelevant.
     *   - The keystroke parts should be separated by whitespace.
     *   - The keystroke is case sensitive.
     */
    function parseKeystroke(keystroke: string): IKeystrokeParts;
    /**
     * Normalize a keystroke into a canonical representation.
     *
     * @param keystroke - The keystroke of interest.
     *
     * @returns The normalized representation of the keystroke.
     *
     * #### Notes
     * This normalizes the keystroke by removing duplicate modifiers and
     * extra primary keys, and assembling the parts in a canonical order.
     *
     * The `Cmd` modifier is ignored on non-Mac platforms.
     */
    function normalizeKeystroke(keystroke: string): string;
    /**
     * Format a keystroke for display on the local system.
     *
     * @param keystroke - The keystroke of interest.
     *
     * @returns The keystroke formatted for display on the local system.
     *
     * #### Notes
     * On Mac, this replaces the modifiers with the Mac-specific unicode
     * characters. On other systems, this joins the modifiers with `+`.
     */
    function formatKeystroke(keystroke: string): string;
    /**
     * Create a normalized keystroke for a `'keydown'` event.
     *
     * @param event - The event object for a `'keydown'` event.
     *
     * @param layout - The keyboard layout for looking up the primary key.
     *
     * @returns A normalized keystroke, or an empty string if the event
     *   does not represent a valid keystroke for the given layout.
     */
    function keystrokeForKeydownEvent(event: KeyboardEvent, layout: IKeyboardLayout): string;
}
