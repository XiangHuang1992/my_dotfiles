/**
 * A type alias for a slot function.
 *
 * @param sender - The object emitting the signal.
 *
 * @param args - The args object emitted with the signal.
 *
 * #### Notes
 * A slot is invoked when a signal to which it is connected is emitted.
 */
export declare type Slot<T, U> = (sender: T, args: U) => void;
/**
 * An object used for type-safe inter-object communication.
 *
 * #### Notes
 * Signals provide a type-safe implementation of the publish-subscribe
 * pattern. An object (publisher) declares which signals it will emit,
 * and consumers connect callbacks (subscribers) to those signals. The
 * subscribers are invoked whenever the publisher emits the signal.
 *
 * #### Example
 * ```typescript
 * import { ISignal, defineSignal } from 'phosphor/lib/core/signaling';
 *
 * class SomeClass {
 *
 *   constructor(name: string) {
 *     this._name = name;
 *   }
 *
 *   valueChanged: ISignal<SomeClass, number>;
 *
 *   get name(): string {
 *     return this._name;
 *   }
 *
 *   get value(): number {
 *     return this._value;
 *   }
 *
 *   set value(value: number) {
 *     if (value === this._value) {
 *       return;
 *     }
 *     this._value = value;
 *     this.valueChanged.emit(value);
 *   }
 *
 *   private _name: string;
 *   private _value = 0;
 * }
 *
 * defineSignal(SomeClass.prototype, 'valueChanged');
 *
 * function logger(sender: SomeClass, value: number): void {
 *   console.log(sender.name, value);
 * }
 *
 * let m1 = new SomeClass('foo');
 * let m2 = new SomeClass('bar');
 *
 * m1.valueChanged.connect(logger);
 * m2.valueChanged.connect(logger);
 *
 * m1.value = 42;  // logs: foo 42
 * m2.value = 17;  // logs: bar 17
 * ```
 */
export interface ISignal<T, U> {
    /**
     * Connect a slot to the signal.
     *
     * @param slot - The slot to invoke when the signal is emitted.
     *
     * @param thisArg - The `this` context for the slot. If provided,
     *   this must be a non-primitive object.
     *
     * @returns `true` if the connection succeeds, `false` otherwise.
     *
     * #### Notes
     * Signal connections are unique. If a connection already exists for
     * the given `slot` and `thisArg`, this method returns `false`.
     *
     * A newly connected slot will not be invoked until the next time the
     * signal is emitted, even if the slot is connected while the signal
     * is dispatching.
     *
     * #### Example
     * ```typescript
     * // connect a method
     * someObject.valueChanged.connect(myObject.onValueChanged, myObject);
     *
     * // connect a plain function
     * someObject.valueChanged.connect(myCallback);
     * ```
     */
    connect(slot: Slot<T, U>, thisArg?: any): boolean;
    /**
     * Disconnect a slot from the signal.
     *
     * @param slot - The slot to disconnect from the signal.
     *
     * @param thisArg - The `this` context for the slot. If provided,
     *   this must be a non-primitive object.
     *
     * @returns `true` if the connection is removed, `false` otherwise.
     *
     * #### Notes
     * If no connection exists for the given `slot` and `thisArg`, this
     * method returns `false`.
     *
     * A disconnected slot will no longer be invoked, even if the slot
     * is disconnected while the signal is dispatching.
     *
     * #### Example
     * ```typescript
     * // disconnect a method
     * someObject.valueChanged.disconnect(myObject.onValueChanged, myObject);
     *
     * // disconnect a plain function
     * someObject.valueChanged.disconnect(myCallback);
     * ```
     */
    disconnect(slot: Slot<T, U>, thisArg?: any): boolean;
    /**
     * Emit the signal and invoke the connected slots.
     *
     * @param args - The args to pass to the connected slots.
     *
     * #### Notes
     * Connected slots are invoked synchronously, in the order in which
     * they are connected.
     *
     * Exceptions thrown by connected slots will be caught and logged.
     *
     * #### Example
     * ```typescript
     * someObject.valueChanged.emit(42);
     * ```
     */
    emit(args: U): void;
}
/**
 * Define a signal property on a prototype object.
 *
 * @param target - The prototype for the class of interest.
 *
 * @param name - The name of the signal property.
 *
 * #### Notes
 * The defined signal property is read-only.
 *
 * #### Example
 * ```typescript
 * class SomeClass {
 *   valueChanged: ISignal<SomeClass, number>;
 * }
 *
 * defineSignal(SomeClass.prototype, 'valueChanged');
 */
export declare function defineSignal(target: any, name: string): void;
/**
 * Remove all connections where the given object is the sender.
 *
 * @param sender - The sender object of interest.
 *
 * #### Example
 * ```typescript
 * disconnectSender(someObject);
 * ```
 */
export declare function disconnectSender(sender: any): void;
/**
 * Remove all connections where the given object is the receiver.
 *
 * @param receiver - The receiver object of interest.
 *
 * #### Notes
 * If a `thisArg` is provided when connecting a signal, that object
 * is considered the receiver. Otherwise, the `callback` is used as
 * the receiver.
 *
 * #### Example
 * ```typescript
 * // disconnect a regular object receiver
 * disconnectReceiver(myObject);
 *
 * // disconnect a plain callback receiver
 * disconnectReceiver(myCallback);
 * ```
 */
export declare function disconnectReceiver(receiver: any): void;
/**
 * Clear all signal data associated with the given object.
 *
 * @param obj - The object for which the signal data should be cleared.
 *
 * #### Notes
 * This removes all signal connections where the object is used as
 * either the sender or the receiver.
 *
 * #### Example
 * ```typescript
 * clearSignalData(someObject);
 * ```
 */
export declare function clearSignalData(obj: any): void;
