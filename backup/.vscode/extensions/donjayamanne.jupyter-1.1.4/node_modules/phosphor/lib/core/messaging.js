"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
var iteration_1 = require("../algorithm/iteration");
var queue_1 = require("../collections/queue");
/**
 * A message which can be delivered to a message handler.
 *
 * #### Notes
 * This class may be subclassed to create complex message types.
 *
 * **See also:** [[postMessage]] and [[sendMessage]].
 */
var Message = (function () {
    /**
     * Construct a new message.
     *
     * @param type - The type of the message.
     */
    function Message(type) {
        this._type = type;
    }
    Object.defineProperty(Message.prototype, "type", {
        /**
         * The type of the message.
         *
         * #### Notes
         * This value can be used to cast the message to a derived type.
         *
         * This is a read-only property.
         */
        get: function () {
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Message.prototype, "isConflatable", {
        /**
         * Test whether the message is conflatable.
         *
         * #### Notes
         * Message conflation is an advanced topic. Most message types will
         * not make use of this feature.
         *
         * If a conflatable message is posted to the event queue when another
         * conflatable message of the same type and handler has already been
         * posted, the `conflate()` method of the existing message will be
         * invoked. If that method returns `true`, the new message will not
         * be enqueued. This allows messages to be compressed, so that only
         * a single instance of the message type is processed per cycle, no
         * matter how many times messages of that type are posted.
         *
         * Custom message types may reimplement this property. The default
         * implementation is always `false`.
         *
         * This is a read-only property.
         *
         * **See also:** [[conflateMessage]]
         */
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Conflate this message with another message of the same `type`.
     *
     * @param other - A conflatable message of the same `type`.
     *
     * @returns `true` if the message was successfully conflated, or
     *   `false` otherwise.
     *
     * #### Notes
     * Message conflation is an advanced topic. Most message types will
     * not make use of this feature.
     *
     * This method is called automatically by the message loop when the
     * given message is posted to the handler paired with this message.
     * This message will already be enqueued and conflatable, and the
     * given message will have the same `type` and also be conflatable.
     *
     * This method should merge the state of the other message into this
     * message as needed so that when this message is finally delivered
     * to the handler, it receives the most up-to-date information.
     *
     * If this method returns `true`, it signals that the other message
     * was successfully conflated and it will not be enqueued.
     *
     * If this method returns `false`, the other message will be enqueued
     * for normal delivery.
     *
     * Custom message types may reimplement this method. The default
     * implementation always returns `false`.
     *
     * **See also:** [[isConflatable]]
     */
    Message.prototype.conflate = function (other) {
        return false;
    };
    return Message;
}());
exports.Message = Message;
/**
 * A convenience message class which conflates automatically.
 *
 * #### Notes
 * Message conflation is an advanced topic. Most user code will not
 * make use of this class.
 *
 * This message class is useful for creating message instances which
 * should be conflated, but which have no state other than `type`.
 *
 * If conflation of stateful messages is required, a custom `Message`
 * subclass should be created.
 */
var ConflatableMessage = (function (_super) {
    __extends(ConflatableMessage, _super);
    function ConflatableMessage() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ConflatableMessage.prototype, "isConflatable", {
        /**
         * Test whether the message is conflatable.
         *
         * #### Notes
         * This property is always `true`.
         *
         * This is a read-only property.
         */
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Conflate this message with another message of the same `type`.
     *
     * #### Notes
     * This method always returns `true`.
     */
    ConflatableMessage.prototype.conflate = function (other) {
        return true;
    };
    return ConflatableMessage;
}(Message));
exports.ConflatableMessage = ConflatableMessage;
/**
 * Send a message to a message handler to process immediately.
 *
 * @param handler - The handler which should process the message.
 *
 * @param msg - The message to deliver to the handler.
 *
 * #### Notes
 * The message will first be sent through any installed message hooks
 * for the handler. If the message passes all hooks, it will then be
 * delivered to the `processMessage` method of the handler.
 *
 * The message will not be conflated with pending posted messages.
 *
 * Exceptions in hooks and handlers will be caught and logged.
 */
function sendMessage(handler, msg) {
    MessageLoop.sendMessage(handler, msg);
}
exports.sendMessage = sendMessage;
/**
 * Post a message to the message handler to process in the future.
 *
 * @param handler - The handler which should process the message.
 *
 * @param msg - The message to post to the handler.
 *
 * #### Notes
 * The message will be conflated with the pending posted messages for
 * the handler, if possible. If the message is not conflated, it will
 * be queued for normal delivery on the next cycle of the event loop.
 *
 * Exceptions in hooks and handlers will be caught and logged.
 */
function postMessage(handler, msg) {
    MessageLoop.postMessage(handler, msg);
}
exports.postMessage = postMessage;
/**
 * Install a message hook for a message handler.
 *
 * @param handler - The message handler of interest.
 *
 * @param hook - The message hook to install.
 *
 * #### Notes
 * A message hook is invoked before a message is delivered to the
 * handler. If the hook returns `false`, no other hooks will be
 * invoked and the message will not be delivered to the handler.
 *
 * The most recently installed message hook is executed first.
 *
 * If the hook is already installed, it will be moved to the front.
 *
 * **See also:** [[removeMessageHook]]
 */
function installMessageHook(handler, hook) {
    MessageLoop.installMessageHook(handler, hook);
}
exports.installMessageHook = installMessageHook;
/**
 * Remove an installed message hook for a message handler.
 *
 * @param handler - The message handler of interest.
 *
 * @param hook - The message hook to remove.
 *
 * #### Notes
 * If the hook is not installed, this is a no-op.
 *
 * It is safe to call this function while the hook is executing.
 */
function removeMessageHook(handler, hook) {
    MessageLoop.removeMessageHook(handler, hook);
}
exports.removeMessageHook = removeMessageHook;
/**
 * Clear all message data associated with a message handler.
 *
 * @param handler - The message handler of interest.
 *
 * #### Notes
 * This will clear all pending messages and hooks for the handler.
 */
function clearMessageData(handler) {
    MessageLoop.clearMessageData(handler);
}
exports.clearMessageData = clearMessageData;
/**
 * The namespace for the global singleton message loop.
 */
var MessageLoop;
(function (MessageLoop) {
    /**
     * Send a message to a handler for immediate processing.
     *
     * This will first call all message hooks for the handler. If any
     * hook rejects the message, the message will not be delivered.
     */
    function sendMessage(handler, msg) {
        // Handle the common case of no message hooks.
        var node = hooks.get(handler);
        if (node === void 0) {
            invokeHandler(handler, msg);
            return;
        }
        // Run the message hooks and bail early if any hook returns false.
        // A null hook indicates the hook was removed during dispatch.
        for (; node !== null; node = node.next) {
            if (node.hook !== null && !invokeHook(node.hook, handler, msg)) {
                return;
            }
        }
        // All message hooks returned true, so invoke the handler.
        invokeHandler(handler, msg);
    }
    MessageLoop.sendMessage = sendMessage;
    /**
     * Post a message to a handler for processing in the future.
     *
     * This will first conflate the message, if possible. If it cannot
     * be conflated, it will be queued for delivery on the next cycle
     * of the event loop.
     */
    function postMessage(handler, msg) {
        // Handle the common case a non-conflatable message first.
        if (!msg.isConflatable) {
            enqueueMessage(handler, msg);
            return;
        }
        // Conflate message if possible.
        var conflated = iteration_1.some(queue, function (posted) {
            if (posted.handler !== handler) {
                return false;
            }
            if (posted.msg.type !== msg.type) {
                return false;
            }
            if (!posted.msg.isConflatable) {
                return false;
            }
            return posted.msg.conflate(msg);
        });
        // If the message was not conflated, enqueue the message.
        if (!conflated)
            enqueueMessage(handler, msg);
    }
    MessageLoop.postMessage = postMessage;
    /**
     * Install a message hook for a handler.
     *
     * This will first remove the hook if it exists, then install the
     * hook in front of other hooks for the handler.
     */
    function installMessageHook(handler, hook) {
        // Remove the message hook if it's already installed.
        removeMessageHook(handler, hook);
        // Install the hook at the front of the list.
        var next = hooks.get(handler) || null;
        hooks.set(handler, { next: next, hook: hook });
    }
    MessageLoop.installMessageHook = installMessageHook;
    /**
     * Remove a message hook for a handler, if it exists.
     */
    function removeMessageHook(handler, hook) {
        // Traverse the list and find the matching hook. If found, clear
        // the reference to the hook and remove the node from the list.
        // The node's next reference is *not* cleared so that dispatch
        // may continue when the hook is removed during dispatch.
        var prev = null;
        var node = hooks.get(handler) || null;
        for (; node !== null; prev = node, node = node.next) {
            if (node.hook === hook) {
                if (prev === null && node.next === null) {
                    hooks.delete(handler);
                }
                else if (prev === null) {
                    hooks.set(handler, node.next);
                }
                else {
                    prev.next = node.next;
                }
                node.hook = null;
                return;
            }
        }
    }
    MessageLoop.removeMessageHook = removeMessageHook;
    /**
     * Clear all message data for a handler.
     *
     * This will remove all message hooks and clear pending messages.
     */
    function clearMessageData(handler) {
        // Clear all message hooks.
        var node = hooks.get(handler) || null;
        for (; node !== null; node = node.next) {
            node.hook = null;
        }
        // Remove the handler from the hooks map.
        hooks.delete(handler);
        // Clear all pending messages.
        iteration_1.each(queue, function (posted) {
            if (posted.handler === handler) {
                posted.handler = null;
            }
        });
    }
    MessageLoop.clearMessageData = clearMessageData;
    /**
     * The queue of posted message pairs.
     */
    var queue = new queue_1.Queue();
    /**
     * A mapping of handler to list of installed message hooks.
     */
    var hooks = new WeakMap();
    /**
     * A local reference to an event loop callback.
     */
    var defer = (function () {
        var ok = typeof requestAnimationFrame === 'function';
        return ok ? requestAnimationFrame : setImmediate;
    })();
    /**
     * Whether a message loop cycle is pending.
     */
    var cyclePending = false;
    /**
     * Invoke a message hook with the specified handler and message.
     *
     * Returns the result of the hook, or `true` if the hook throws.
     *
     * Exceptions in the hook will be caught and logged.
     */
    function invokeHook(hook, handler, msg) {
        var result;
        try {
            if (typeof hook === 'function') {
                result = hook(handler, msg);
            }
            else {
                result = hook.messageHook(handler, msg);
            }
        }
        catch (err) {
            result = true;
            console.error(err);
        }
        return result;
    }
    /**
     * Invoke a message handler with the specified message.
     *
     * Exceptions in the handler will be caught and logged.
     */
    function invokeHandler(handler, msg) {
        try {
            handler.processMessage(msg);
        }
        catch (err) {
            console.error(err);
        }
    }
    /**
     * Add a message to the end of the message queue.
     *
     * This will automatically schedule a cycle of the loop.
     */
    function enqueueMessage(handler, msg) {
        queue.pushBack({ handler: handler, msg: msg });
        scheduleMessageLoop();
    }
    /**
     * Schedule a message loop cycle to process any pending messages.
     *
     * This is a no-op if a loop cycle is already pending.
     */
    function scheduleMessageLoop() {
        if (!cyclePending) {
            defer(runMessageLoop);
            cyclePending = true;
        }
    }
    /**
     * Run an iteration of the message loop.
     *
     * This will process all pending messages in the queue. If a message
     * is added to the queue while the message loop is running, it will
     * be processed on the next cycle of the loop.
     */
    function runMessageLoop() {
        // Clear the pending flag so the next loop can be scheduled.
        cyclePending = false;
        // If the queue is empty, there is nothing else to do.
        if (queue.isEmpty) {
            return;
        }
        // Add a sentinel value to the end of the queue. The queue will
        // only be processed up to the sentinel. Messages posted during
        // this cycle will execute on the next cycle.
        var sentinel = { handler: null, msg: null };
        queue.pushBack(sentinel);
        // Enter the message loop.
        while (!queue.isEmpty) {
            // Remove the first posted message in the queue.
            var posted = queue.popFront();
            // If the value is the sentinel, exit the loop.
            if (posted === sentinel) {
                return;
            }
            // Dispatch the message if the handler has not been cleared.
            if (posted.handler !== null) {
                sendMessage(posted.handler, posted.msg);
            }
        }
    }
})(MessageLoop || (MessageLoop = {}));
