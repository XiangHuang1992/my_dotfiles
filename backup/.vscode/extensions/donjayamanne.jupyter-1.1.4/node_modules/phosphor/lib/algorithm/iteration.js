/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
"use strict";
/**
 * Create an iterator for an iterable or array-like object.
 *
 * @param object - The iterable or array-like object of interest.
 *
 * @returns A new iterator for the given object.
 *
 * #### Notes
 * This function allows iteration algorithms to operate on user-defined
 * iterable types and builtin array-like objects in a uniform fashion.
 */
function iter(object) {
    var it;
    if (typeof object.iter === 'function') {
        it = object.iter();
    }
    else {
        it = new ArrayIterator(object, 0);
    }
    return it;
}
exports.iter = iter;
/**
 * Create an array from an iterable of values.
 *
 * @param object - The iterable or array-like object of interest.
 *
 * @returns A new array of values from the given object.
 */
function toArray(object) {
    var value;
    var result = [];
    var it = iter(object);
    while ((value = it.next()) !== void 0) {
        result[result.length] = value;
    }
    return result;
}
exports.toArray = toArray;
/**
 * Create an empty iterator.
 *
 * @returns A new iterator which yields nothing.
 */
function empty() {
    return new EmptyIterator();
}
exports.empty = empty;
/**
 * An iterator which is always empty.
 */
var EmptyIterator = (function () {
    /**
     * Construct a new empty iterator.
     */
    function EmptyIterator() {
    }
    /**
     * Create an iterator over the object's values.
     *
     * @returns A reference to `this` iterator.
     */
    EmptyIterator.prototype.iter = function () {
        return this;
    };
    /**
     * Create an independent clone of the current iterator.
     *
     * @returns A new independent clone of the current iterator.
     */
    EmptyIterator.prototype.clone = function () {
        return new EmptyIterator();
    };
    /**
     * Get the next value from the iterator.
     *
     * @returns Always `undefined`.
     */
    EmptyIterator.prototype.next = function () {
        return void 0;
    };
    return EmptyIterator;
}());
exports.EmptyIterator = EmptyIterator;
/**
 * An iterator for an array-like object.
 *
 * #### Notes
 * This iterator can be used for any builtin JS array-like object.
 */
var ArrayIterator = (function () {
    /**
     * Construct a new array iterator.
     *
     * @param source - The array-like object of interest.
     *
     * @param start - The starting index for iteration.
     */
    function ArrayIterator(source, start) {
        this._source = source;
        this._index = start;
    }
    /**
     * Create an iterator over the object's values.
     *
     * @returns A reference to `this` iterator.
     */
    ArrayIterator.prototype.iter = function () {
        return this;
    };
    /**
     * Create an independent clone of the current iterator.
     *
     * @returns A new independent clone of the current iterator.
     *
     * #### Notes
     * The source array is shared among clones.
     */
    ArrayIterator.prototype.clone = function () {
        return new ArrayIterator(this._source, this._index);
    };
    /**
     * Get the next value from the source array.
     *
     * @returns The next value from the source array, or `undefined`
     *   if the iterator is exhausted.
     */
    ArrayIterator.prototype.next = function () {
        if (this._index >= this._source.length) {
            return void 0;
        }
        return this._source[this._index++];
    };
    return ArrayIterator;
}());
exports.ArrayIterator = ArrayIterator;
/**
 * Invoke a function for each value in an iterable.
 *
 * @param object - The iterable or array-like object of interest.
 *
 * @param fn - The callback function to invoke for each value.
 *
 * #### Notes
 * Iteration cannot be terminated early.
 */
function each(object, fn) {
    var value;
    var it = iter(object);
    while ((value = it.next()) !== void 0) {
        fn(value);
    }
}
exports.each = each;
/**
 * Test whether all values in an iterable satisfy a predicate.
 *
 * @param object - The iterable or array-like object of interest.
 *
 * @param fn - The predicate function to invoke for each value.
 *
 * @returns `true` if all values pass the test, `false` otherwise.
 *
 * #### Notes
 * Iteration terminates on the first `false` predicate result.
 */
function every(object, fn) {
    var value;
    var it = iter(object);
    while ((value = it.next()) !== void 0) {
        if (!fn(value)) {
            return false;
        }
    }
    return true;
}
exports.every = every;
/**
 * Test whether any value in an iterable satisfies a predicate.
 *
 * @param object - The iterable or array-like object of interest.
 *
 * @param fn - The predicate function to invoke for each value.
 *
 * @returns `true` if any value passes the test, `false` otherwise.
 *
 * #### Notes
 * Iteration terminates on the first `true` predicate result.
 */
function some(object, fn) {
    var value;
    var it = iter(object);
    while ((value = it.next()) !== void 0) {
        if (fn(value)) {
            return true;
        }
    }
    return false;
}
exports.some = some;
function reduce(object, fn, initial) {
    // Setup the iterator and fetch the first value.
    var it = iter(object);
    var first = it.next();
    // An empty iterator and no initial value is an error.
    if (first === void 0 && initial === void 0) {
        throw new TypeError('Reduce of empty iterable with no initial value.');
    }
    // If the iterator is empty, return the initial value.
    if (first === void 0) {
        return initial;
    }
    // If the iterator has a single item and no initial value, the
    // reducer is not invoked and the first item is the return value.
    var second = it.next();
    if (second === void 0 && initial === void 0) {
        return first;
    }
    // If iterator has a single item and an initial value is provided,
    // the reducer is invoked and that result is the return value.
    if (second === void 0) {
        return fn(initial, first);
    }
    // Setup the initial accumulator value.
    var accumulator;
    if (initial === void 0) {
        accumulator = fn(first, second);
    }
    else {
        accumulator = fn(fn(initial, first), second);
    }
    // Iterate the rest of the values, updating the accumulator.
    var next;
    while ((next = it.next()) !== void 0) {
        accumulator = fn(accumulator, next);
    }
    // Return the final accumulated value.
    return accumulator;
}
exports.reduce = reduce;
/**
 * Filter an iterable for values which pass a test.
 *
 * @param object - The iterable or array-like object of interest.
 *
 * @param fn - The predicate function to invoke for each value.
 *
 * @returns An iterator which yields the values which pass the test.
 */
function filter(object, fn) {
    return new FilterIterator(iter(object), fn);
}
exports.filter = filter;
/**
 * An iterator which yields values which pass a test.
 */
var FilterIterator = (function () {
    /**
     * Construct a new filter iterator.
     *
     * @param source - The iterator of values of interest.
     *
     * @param fn - The predicate function to invoke for each value in
     *   the iterator. It returns whether the value passes the test.
     */
    function FilterIterator(source, fn) {
        this._source = source;
        this._fn = fn;
    }
    /**
     * Create an iterator over the object's values.
     *
     * @returns A reference to `this` iterator.
     */
    FilterIterator.prototype.iter = function () {
        return this;
    };
    /**
     * Create an independent clone of the current iterator.
     *
     * @returns A new independent clone of the current iterator.
     *
     * #### Notes
     * The source iterator must be cloneable.
     *
     * The predicate function is shared among clones.
     */
    FilterIterator.prototype.clone = function () {
        return new FilterIterator(this._source.clone(), this._fn);
    };
    /**
     * Get the next value which passes the test.
     *
     * @returns The next value from the source iterator which passes
     *   the predicate, or `undefined` if the iterator is exhausted.
     */
    FilterIterator.prototype.next = function () {
        var value;
        var fn = this._fn;
        var it = this._source;
        while ((value = it.next()) !== void 0) {
            if (fn(value)) {
                return value;
            }
        }
        return void 0;
    };
    return FilterIterator;
}());
exports.FilterIterator = FilterIterator;
/**
 * Transform the values of an iterable with a mapping function.
 *
 * @param object - The iterable or array-like object of interest.
 *
 * @param fn - The mapping function to invoke for each value.
 *
 * @returns An iterator which yields the transformed values.
 */
function map(object, fn) {
    return new MapIterator(iter(object), fn);
}
exports.map = map;
/**
 * An iterator which transforms values using a mapping function.
 */
var MapIterator = (function () {
    /**
     * Construct a new map iterator.
     *
     * @param source - The iterator of values of interest.
     *
     * @param fn - The mapping function to invoke for each value in the
     *   iterator. It returns the transformed value.
     */
    function MapIterator(source, fn) {
        this._source = source;
        this._fn = fn;
    }
    /**
     * Create an iterator over the object's values.
     *
     * @returns A reference to `this` iterator.
     */
    MapIterator.prototype.iter = function () {
        return this;
    };
    /**
     * Create an independent clone of the current iterator.
     *
     * @returns A new independent clone of the current iterator.
     *
     * #### Notes
     * The source iterator must be cloneable.
     *
     * The mapping function is shared among clones.
     */
    MapIterator.prototype.clone = function () {
        return new MapIterator(this._source.clone(), this._fn);
    };
    /**
     * Get the next mapped value from the source iterator.
     *
     * @returns The next value from the source iterator transformed
     *   by the mapper, or `undefined` if the iterator is exhausted.
     */
    MapIterator.prototype.next = function () {
        var value = this._source.next();
        if (value === void 0) {
            return void 0;
        }
        return this._fn.call(void 0, value);
    };
    return MapIterator;
}());
exports.MapIterator = MapIterator;
/**
 * Attach an incremental index to an iterable.
 *
 * @param object - The iterable or array-like object of interest.
 *
 * @param start - The initial value of the index. The default is zero.
 *
 * @returns An iterator which yields `[index, value]` tuples.
 */
function enumerate(object, start) {
    if (start === void 0) { start = 0; }
    return new EnumerateIterator(iter(object), start);
}
exports.enumerate = enumerate;
/**
 * An iterator which attaches an incremental index to a source.
 */
var EnumerateIterator = (function () {
    /**
     * Construct a new enumerate iterator.
     *
     * @param source - The iterator of values of interest.
     *
     * @param start - The initial value of the index.
     */
    function EnumerateIterator(source, start) {
        this._source = source;
        this._index = start;
    }
    /**
     * Create an iterator over the object's values.
     *
     * @returns A reference to `this` iterator.
     */
    EnumerateIterator.prototype.iter = function () {
        return this;
    };
    /**
     * Create an independent clone of the enumerate iterator.
     *
     * @returns A new iterator starting with the current value.
     *
     * #### Notes
     * The source iterator must be cloneable.
     */
    EnumerateIterator.prototype.clone = function () {
        return new EnumerateIterator(this._source.clone(), this._index);
    };
    /**
     * Get the next value from the enumeration.
     *
     * @returns The next value from the enumeration, or `undefined` if
     *   the iterator is exhausted.
     */
    EnumerateIterator.prototype.next = function () {
        var value = this._source.next();
        if (value === void 0) {
            return void 0;
        }
        return [this._index++, value];
    };
    return EnumerateIterator;
}());
exports.EnumerateIterator = EnumerateIterator;
/**
 * Create an iterator which yields a value a single time.
 *
 * @param value - The value to wrap in an iterator.
 *
 * @returns A new iterator which yields the value a single time.
 */
function once(value) {
    return new RepeatIterator(value, 1);
}
exports.once = once;
/**
 * Create an iterator which repeats a value a number of times.
 *
 * @param value - The value to repeat.
 *
 * @param count - The number of times to repeat the value.
 *
 * @returns A new iterator which repeats the specified value.
 */
function repeat(value, count) {
    return new RepeatIterator(value, count);
}
exports.repeat = repeat;
/**
 * An iterator which repeats a value a specified number of times.
 */
var RepeatIterator = (function () {
    /**
     * Construct a new repeat iterator.
     *
     * @param value - The value to repeat.
     *
     * @param count - The number of times to repeat the value.
     */
    function RepeatIterator(value, count) {
        this._value = value;
        this._count = count;
    }
    /**
     * Create an iterator over the object's values.
     *
     * @returns A reference to `this` iterator.
     */
    RepeatIterator.prototype.iter = function () {
        return this;
    };
    /**
     * Create an independent clone of the repeat iterator.
     *
     * @returns A new iterator starting with the current value.
     */
    RepeatIterator.prototype.clone = function () {
        return new RepeatIterator(this._value, this._count);
    };
    /**
     * Get the next value from the iterator.
     *
     * @returns The next value from the iterator, or `undefined` if
     *   the iterator is exhausted.
     */
    RepeatIterator.prototype.next = function () {
        if (this._count <= 0) {
            return void 0;
        }
        this._count--;
        return this._value;
    };
    return RepeatIterator;
}());
exports.RepeatIterator = RepeatIterator;
/**
 * Chain together several iterables.
 *
 * @param objects - The iterables or array-like objects of interest.
 *
 * @returns An iterator which yields the values of the given iterables
 *   in the order in which they are supplied.
 */
function chain() {
    var objects = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        objects[_i] = arguments[_i];
    }
    return new ChainIterator(map(objects, iter));
}
exports.chain = chain;
/**
 * An iterator which chains together several iterators.
 */
var ChainIterator = (function () {
    /**
     * Construct a new chain iterator.
     *
     * @param source - The iterator of iterators of interest.
     */
    function ChainIterator(source) {
        this._cloned = false;
        this._source = source;
        this._active = void 0;
    }
    /**
     * Create an iterator over the object's values.
     *
     * @returns A reference to `this` iterator.
     */
    ChainIterator.prototype.iter = function () {
        return this;
    };
    /**
     * Create an independent clone of the chain iterator.
     *
     * @returns A new iterator starting with the current value.
     *
     * #### Notes
     * The source iterators must be cloneable.
     */
    ChainIterator.prototype.clone = function () {
        var result = new ChainIterator(this._source.clone());
        result._active = this._active && this._active.clone();
        result._cloned = true;
        this._cloned = true;
        return result;
    };
    /**
     * Get the next value from the iterator.
     *
     * @returns The next value from the iterator, or `undefined` when
     *   all source iterators are exhausted.
     */
    ChainIterator.prototype.next = function () {
        if (this._active === void 0) {
            this._active = this._source.next();
            if (this._active === void 0) {
                return void 0;
            }
            if (this._cloned) {
                this._active = this._active.clone();
            }
        }
        var value = this._active.next();
        if (value !== void 0) {
            return value;
        }
        this._active = void 0;
        return this.next();
    };
    return ChainIterator;
}());
exports.ChainIterator = ChainIterator;
/**
 * Iterate several iterables in lockstep.
 *
 * @param objects - The iterables or array-like objects of interest.
 *
 * @returns An iterator which yields successive tuples of values where
 *   each value is taken in turn from the provided iterables. It will
 *   be as long as the shortest provided iterable.
 */
function zip() {
    var objects = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        objects[_i] = arguments[_i];
    }
    return new ZipIterator(objects.map(iter));
}
exports.zip = zip;
/**
 * An iterator which iterates several sources in lockstep.
 */
var ZipIterator = (function () {
    /**
     * Construct a new zip iterator.
     *
     * @param source - The iterators of interest.
     */
    function ZipIterator(source) {
        this._source = source;
    }
    /**
     * Create an iterator over the object's values.
     *
     * @returns A reference to `this` iterator.
     */
    ZipIterator.prototype.iter = function () {
        return this;
    };
    /**
     * Create an independent clone of the zip iterator.
     *
     * @returns A new iterator starting with the current value.
     *
     * #### Notes
     * The source iterators must be cloneable.
     */
    ZipIterator.prototype.clone = function () {
        return new ZipIterator(this._source.map(function (it) { return it.clone(); }));
    };
    /**
     * Get the next zipped value from the iterator.
     *
     * @returns The next zipped value from the iterator, or `undefined`
     *   when the first source iterator is exhausted.
     */
    ZipIterator.prototype.next = function () {
        var iters = this._source;
        var result = new Array(iters.length);
        for (var i = 0, n = iters.length; i < n; ++i) {
            var value = iters[i].next();
            if (value === void 0) {
                return void 0;
            }
            result[i] = value;
        }
        return result;
    };
    return ZipIterator;
}());
exports.ZipIterator = ZipIterator;
/**
 * Iterate over an iterable using a stepped increment.
 *
 * @param object - The iterable or array-like object of interest.
 *
 * @param step - The distance to step on each iteration. A value
 *   of less than `1` will behave the same as a value of `1`.
 *
 * @returns An iterator which traverses the iterable step-wise.
 */
function stride(object, step) {
    return new StrideIterator(iter(object), step);
}
exports.stride = stride;
/**
 * An iterator which traverses a source iterator step-wise.
 */
var StrideIterator = (function () {
    /**
     * Construct a new stride iterator.
     *
     * @param source - The iterator of values of interest.
     *
     * @param step - The distance to step on each iteration. A value
     *   of less than `1` will behave the same as a value of `1`.
     */
    function StrideIterator(source, step) {
        this._source = source;
        this._step = step;
    }
    /**
     * Create an iterator over the object's values.
     *
     * @returns A reference to `this` iterator.
     */
    StrideIterator.prototype.iter = function () {
        return this;
    };
    /**
     * Create an independent clone of the stride iterator.
     *
     * @returns A new iterator starting with the current value.
     *
     * #### Notes
     * The source iterator must be cloneable.
     */
    StrideIterator.prototype.clone = function () {
        return new StrideIterator(this._source.clone(), this._step);
    };
    /**
     * Get the next stepped value from the iterator.
     *
     * @returns The next stepped value from the iterator, or `undefined`
     *   when the source iterator is exhausted.
     */
    StrideIterator.prototype.next = function () {
        var value = this._source.next();
        if (value === void 0) {
            return void 0;
        }
        var step = this._step;
        while (--step > 0) {
            this._source.next();
        }
        return value;
    };
    return StrideIterator;
}());
exports.StrideIterator = StrideIterator;
