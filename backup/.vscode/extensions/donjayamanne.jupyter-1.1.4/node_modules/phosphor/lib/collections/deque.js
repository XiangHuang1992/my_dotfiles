"use strict";
/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
var iteration_1 = require("../algorithm/iteration");
/**
 * A generic double ended queue data structure.
 */
var Deque = (function () {
    /**
     * Construct a new deque.
     *
     * @param values - The initial values for the deque.
     */
    function Deque(values) {
        var _this = this;
        this._length = 0;
        this._front = null;
        this._back = null;
        if (values)
            iteration_1.each(values, function (value) { _this.pushBack(value); });
    }
    Object.defineProperty(Deque.prototype, "isEmpty", {
        /**
         * Test whether the deque is empty.
         *
         * @returns `true` if the deque is empty, `false` otherwise.
         *
         * #### Notes
         * This is a read-only property.
         *
         * #### Complexity
         * Constant.
         *
         * #### Iterator Validity
         * No changes.
         */
        get: function () {
            return this._length === 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Deque.prototype, "length", {
        /**
         * Get the length of the deque.
         *
         * @return The number of values in the deque.
         *
         * #### Notes
         * This is a read-only property.
         *
         * #### Complexity
         * Constant.
         *
         * #### Iterator Validity
         * No changes.
         */
        get: function () {
            return this._length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Deque.prototype, "front", {
        /**
         * Get the value at the front of the deque.
         *
         * @returns The value at the front of the deque, or `undefined` if
         *   the deque is empty.
         *
         * #### Notes
         * This is a read-only property.
         *
         * #### Complexity
         * Constant.
         *
         * #### Iterator Validity
         * No changes.
         */
        get: function () {
            return this._front ? this._front.value : void 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Deque.prototype, "back", {
        /**
         * Get the value at the back of the deque.
         *
         * @returns The value at the back of the deque, or `undefined` if
         *   the deque is empty.
         *
         * #### Notes
         * This is a read-only property.
         *
         * #### Complexity
         * Constant.
         *
         * #### Iterator Validity
         * No changes.
         */
        get: function () {
            return this._back ? this._back.value : void 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Create an iterator over the values in the deque.
     *
     * @returns A new iterator starting at the front of the deque.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * No changes.
     */
    Deque.prototype.iter = function () {
        return new DequeIterator(this._front);
    };
    /**
     * Add a value to the front of the deque.
     *
     * @param value - The value to add to the front of the deque.
     *
     * @returns The new length of the deque.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * No changes.
     */
    Deque.prototype.pushFront = function (value) {
        var node = new DequeNode(value);
        if (this._length === 0) {
            this._front = node;
            this._back = node;
        }
        else {
            node.next = this._front;
            this._front.prev = node;
            this._front = node;
        }
        return ++this._length;
    };
    /**
     * Add a value to the back of the deque.
     *
     * @param value - The value to add to the back of the deque.
     *
     * @returns The new length of the deque.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * No changes.
     */
    Deque.prototype.pushBack = function (value) {
        var node = new DequeNode(value);
        if (this._length === 0) {
            this._front = node;
            this._back = node;
        }
        else {
            node.prev = this._back;
            this._back.next = node;
            this._back = node;
        }
        return ++this._length;
    };
    /**
     * Remove and return the value at the front of the deque.
     *
     * @returns The value at the front of the deque, or `undefined` if
     *   the deque is empty.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * Iterators pointing at the removed value are invalidated.
     */
    Deque.prototype.popFront = function () {
        if (this._length === 0) {
            return void 0;
        }
        var node = this._front;
        if (this._length === 1) {
            this._front = null;
            this._back = null;
        }
        else {
            this._front = node.next;
            this._front.prev = null;
            node.next = null;
        }
        this._length--;
        return node.value;
    };
    /**
     * Remove and return the value at the back of the deque.
     *
     * @returns The value at the back of the deque, or `undefined` if
     *   the deque is empty.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * Iterators pointing at the removed value are invalidated.
     */
    Deque.prototype.popBack = function () {
        if (this._length === 0) {
            return void 0;
        }
        var node = this._back;
        if (this._length === 1) {
            this._front = null;
            this._back = null;
        }
        else {
            this._back = node.prev;
            this._back.next = null;
            node.prev = null;
        }
        this._length--;
        return node.value;
    };
    /**
     * Remove all values from the deque.
     *
     * #### Complexity
     * Linear.
     *
     * #### Iterator Validity
     * All current iterators are invalidated.
     */
    Deque.prototype.clear = function () {
        var node = this._front;
        while (node) {
            var next = node.next;
            node.prev = null;
            node.next = null;
            node = next;
        }
        this._length = 0;
        this._front = null;
        this._back = null;
    };
    /**
     * Swap the contents of the deque with the contents of another.
     *
     * @param other - The other deque holding the contents to swap.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * All current iterators remain valid, but will now point to the
     * contents of the other deque involved in the swap.
     */
    Deque.prototype.swap = function (other) {
        var length = other._length;
        var front = other._front;
        var back = other._back;
        other._length = this._length;
        other._front = this._front;
        other._back = this._back;
        this._length = length;
        this._front = front;
        this._back = back;
    };
    return Deque;
}());
exports.Deque = Deque;
/**
 * An iterator for a deque.
 */
var DequeIterator = (function () {
    /**
     * Construct a new deque iterator.
     *
     * @param node - The node at the front of range.
     */
    function DequeIterator(node) {
        this._node = node;
    }
    /**
     * Create an iterator over the object's values.
     *
     * @returns A reference to `this` iterator.
     */
    DequeIterator.prototype.iter = function () {
        return this;
    };
    /**
     * Create an independent clone of the deque iterator.
     *
     * @returns A new iterator starting with the current value.
     */
    DequeIterator.prototype.clone = function () {
        return new DequeIterator(this._node);
    };
    /**
     * Get the next value from the deque.
     *
     * @returns The next value from the deque, or `undefined` if the
     *   iterator is exhausted.
     */
    DequeIterator.prototype.next = function () {
        if (!this._node) {
            return void 0;
        }
        var value = this._node.value;
        this._node = this._node.next;
        return value;
    };
    return DequeIterator;
}());
/**
 * The node type for a deque.
 */
var DequeNode = (function () {
    /**
     * Construct a new deque node.
     *
     * @param value - The value for the node.
     */
    function DequeNode(value) {
        /**
         * The next node the deque.
         */
        this.next = null;
        /**
         * The previous node in the deque.
         */
        this.prev = null;
        this.value = value;
    }
    return DequeNode;
}());
