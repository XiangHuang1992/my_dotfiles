"use strict";
/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2016, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
var iteration_1 = require("../algorithm/iteration");
/**
 * A generic FIFO queue data structure.
 */
var Queue = (function () {
    /**
     * Construct a new queue.
     *
     * @param values - The initial values for the queue.
     */
    function Queue(values) {
        var _this = this;
        this._length = 0;
        this._front = null;
        this._back = null;
        if (values)
            iteration_1.each(values, function (value) { _this.pushBack(value); });
    }
    Object.defineProperty(Queue.prototype, "isEmpty", {
        /**
         * Test whether the queue is empty.
         *
         * @returns `true` if the queue is empty, `false` otherwise.
         *
         * #### Notes
         * This is a read-only property.
         *
         * #### Complexity
         * Constant.
         *
         * #### Iterator Validity
         * No changes.
         */
        get: function () {
            return this._length === 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Queue.prototype, "length", {
        /**
         * Get the length of the queue.
         *
         * @return The number of values in the queue.
         *
         * #### Notes
         * This is a read-only property.
         *
         * #### Complexity
         * Constant.
         *
         * #### Iterator Validity
         * No changes.
         */
        get: function () {
            return this._length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Queue.prototype, "front", {
        /**
         * Get the value at the front of the queue.
         *
         * @returns The value at the front of the queue, or `undefined` if
         *   the queue is empty.
         *
         * #### Notes
         * This is a read-only property.
         *
         * #### Complexity
         * Constant.
         *
         * #### Iterator Validity
         * No changes.
         */
        get: function () {
            return this._front ? this._front.value : void 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Queue.prototype, "back", {
        /**
         * Get the value at the back of the queue.
         *
         * @returns The value at the back of the queue, or `undefined` if
         *   the queue is empty.
         *
         * #### Notes
         * This is a read-only property.
         *
         * #### Complexity
         * Constant.
         *
         * #### Iterator Validity
         * No changes.
         */
        get: function () {
            return this._back ? this._back.value : void 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Create an iterator over the values in the queue.
     *
     * @returns A new iterator starting at the front of the queue.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * No changes.
     */
    Queue.prototype.iter = function () {
        return new QueueIterator(this._front);
    };
    /**
     * Add a value to the back of the queue.
     *
     * @param value - The value to add to the back of the queue.
     *
     * @returns The new length of the queue.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * No changes.
     */
    Queue.prototype.pushBack = function (value) {
        var node = new QueueNode(value);
        if (this._length === 0) {
            this._front = node;
            this._back = node;
        }
        else {
            this._back.next = node;
            this._back = node;
        }
        return ++this._length;
    };
    /**
     * Remove and return the value at the front of the queue.
     *
     * @returns The value at the front of the queue, or `undefined` if
     *   the queue is empty.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * Iterators pointing at the removed value are invalidated.
     */
    Queue.prototype.popFront = function () {
        if (this._length === 0) {
            return void 0;
        }
        var node = this._front;
        if (this._length === 1) {
            this._front = null;
            this._back = null;
        }
        else {
            this._front = node.next;
            node.next = null;
        }
        this._length--;
        return node.value;
    };
    /**
     * Remove all values from the queue.
     *
     * #### Complexity
     * Linear.
     *
     * #### Iterator Validity
     * All current iterators are invalidated.
     */
    Queue.prototype.clear = function () {
        var node = this._front;
        while (node) {
            var next = node.next;
            node.next = null;
            node = next;
        }
        this._length = 0;
        this._front = null;
        this._back = null;
    };
    /**
     * Swap the contents of the queue with the contents of another.
     *
     * @param other - The other queue holding the contents to swap.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * All current iterators remain valid, but will now point to the
     * contents of the other queue involved in the swap.
     */
    Queue.prototype.swap = function (other) {
        var length = other._length;
        var front = other._front;
        var back = other._back;
        other._length = this._length;
        other._front = this._front;
        other._back = this._back;
        this._length = length;
        this._front = front;
        this._back = back;
    };
    return Queue;
}());
exports.Queue = Queue;
/**
 * An iterator for a queue.
 */
var QueueIterator = (function () {
    /**
     * Construct a new queue iterator.
     *
     * @param node - The node at the front of range.
     */
    function QueueIterator(node) {
        this._node = node;
    }
    /**
     * Create an iterator over the object's values.
     *
     * @returns A reference to `this` iterator.
     */
    QueueIterator.prototype.iter = function () {
        return this;
    };
    /**
     * Create an independent clone of the queue iterator.
     *
     * @returns A new iterator starting with the current value.
     */
    QueueIterator.prototype.clone = function () {
        return new QueueIterator(this._node);
    };
    /**
     * Get the next value from the queue.
     *
     * @returns The next value from the queue, or `undefined` if the
     *   iterator is exhausted.
     */
    QueueIterator.prototype.next = function () {
        if (!this._node) {
            return void 0;
        }
        var value = this._node.value;
        this._node = this._node.next;
        return value;
    };
    return QueueIterator;
}());
/**
 * The node type for a queue.
 */
var QueueNode = (function () {
    /**
     * Construct a new queue node.
     *
     * @param value - The value for the node.
     */
    function QueueNode(value) {
        /**
         * The next node the queue.
         */
        this.next = null;
        this.value = value;
    }
    return QueueNode;
}());
