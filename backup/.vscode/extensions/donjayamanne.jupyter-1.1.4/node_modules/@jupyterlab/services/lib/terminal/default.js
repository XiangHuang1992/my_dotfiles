// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
"use strict";
var iteration_1 = require('phosphor/lib/algorithm/iteration');
var signaling_1 = require('phosphor/lib/core/signaling');
var utils = require('../utils');
var terminal_1 = require('./terminal');
/**
 * The url for the terminal service.
 */
var TERMINAL_SERVICE_URL = 'api/terminals';
/**
 * An implementation of a terminal interface.
 */
var DefaultTerminalSession = (function () {
    /**
     * Construct a new terminal session.
     */
    function DefaultTerminalSession(name, options) {
        if (options === void 0) { options = {}; }
        this._token = '';
        this._ajaxSettings = '';
        this._ws = null;
        this._isDisposed = false;
        this._isReady = false;
        this._name = name;
        this._baseUrl = options.baseUrl || utils.getBaseUrl();
        this._token = options.token || utils.getConfigOption('token');
        this._ajaxSettings = JSON.stringify(utils.ajaxSettingsWithToken(options.ajaxSettings, this._token));
        this._wsUrl = options.wsUrl || utils.getWsUrl(this._baseUrl);
        this._readyPromise = this._initializeSocket();
    }
    Object.defineProperty(DefaultTerminalSession.prototype, "name", {
        /**
         * Get the name of the terminal session.
         */
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "model", {
        /**
         * Get the model for the terminal session.
         */
        get: function () {
            return { name: this._name };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "baseUrl", {
        /**
         * The base url of the terminal.
         */
        get: function () {
            return this._baseUrl;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "ajaxSettings", {
        /**
         * Get a copy of the default ajax settings for the terminal.
         */
        get: function () {
            return JSON.parse(this._ajaxSettings);
        },
        /**
         * Set the default ajax settings for the terminal.
         */
        set: function (value) {
            this._ajaxSettings = JSON.stringify(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "isReady", {
        /**
         * Test whether the session is ready.
         */
        get: function () {
            return this._isReady;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "ready", {
        /**
         * A promise that fulfills when the manager is ready.
         */
        get: function () {
            return this._readyPromise;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "isDisposed", {
        /**
         * Test whether the session is disposed.
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the session.
     */
    DefaultTerminalSession.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._isDisposed = true;
        if (this._ws) {
            this._ws.close();
            this._ws = null;
        }
        delete Private.running[this._url];
        this._readyPromise = null;
        signaling_1.clearSignalData(this);
    };
    /**
     * Send a message to the terminal session.
     */
    DefaultTerminalSession.prototype.send = function (message) {
        var _this = this;
        var msg = [message.type];
        msg.push.apply(msg, message.content);
        var value = JSON.stringify(msg);
        if (this._isReady) {
            this._ws.send(value);
            return;
        }
        this.ready.then(function () {
            _this._ws.send(value);
        });
    };
    /**
     * Shut down the terminal session.
     */
    DefaultTerminalSession.prototype.shutdown = function () {
        var options = {
            baseUrl: this._baseUrl,
            ajaxSettings: this.ajaxSettings
        };
        return DefaultTerminalSession.shutdown(this.name, options);
    };
    /**
     * Connect to the websocket.
     */
    DefaultTerminalSession.prototype._initializeSocket = function () {
        var _this = this;
        var name = this._name;
        this._url = Private.getTermUrl(this._baseUrl, this._name);
        Private.running[this._url] = this;
        var wsUrl = utils.urlPathJoin(this._wsUrl, "terminals/websocket/" + name);
        if (this._token) {
            wsUrl = wsUrl + ("?token=" + this._token);
        }
        this._ws = new WebSocket(wsUrl);
        this._ws.onmessage = function (event) {
            var data = JSON.parse(event.data);
            _this.messageReceived.emit({
                type: data[0],
                content: data.slice(1)
            });
        };
        return new Promise(function (resolve, reject) {
            _this._ws.onopen = function (event) {
                _this._isReady = true;
                resolve(void 0);
            };
            _this._ws.onerror = function (event) {
                reject(event);
            };
        });
    };
    return DefaultTerminalSession;
}());
exports.DefaultTerminalSession = DefaultTerminalSession;
/**
 * The static namespace for `DefaultTerminalSession`.
 */
var DefaultTerminalSession;
(function (DefaultTerminalSession) {
    /**
     * Whether the terminal service is available.
     */
    function isAvailable() {
        return utils.getConfigOption('terminalsAvailable') === 'True';
    }
    DefaultTerminalSession.isAvailable = isAvailable;
    /**
     * Start a new terminal session.
     *
     * @options - The session options to use.
     *
     * @returns A promise that resolves with the session instance.
     */
    function startNew(options) {
        if (options === void 0) { options = {}; }
        if (!terminal_1.TerminalSession.isAvailable()) {
            return Private.unavailable();
        }
        var baseUrl = options.baseUrl || utils.getBaseUrl();
        var url = Private.getBaseUrl(baseUrl);
        var ajaxSettings = utils.ajaxSettingsWithToken(options.ajaxSettings, options.token);
        ajaxSettings.method = 'POST';
        ajaxSettings.dataType = 'json';
        return utils.ajaxRequest(url, ajaxSettings).then(function (success) {
            if (success.xhr.status !== 200) {
                return utils.makeAjaxError(success);
            }
            var name = success.data.name;
            return new DefaultTerminalSession(name, options);
        });
    }
    DefaultTerminalSession.startNew = startNew;
    /*
     * Connect to a running session.
     *
     * @param name - The name of the target session.
     *
     * @param options - The session options to use.
     *
     * @returns A promise that resolves with the new session instance.
     *
     * #### Notes
     * If the session was already started via `startNew`, the existing
     * session object is used as the fulfillment value.
     *
     * Otherwise, if `options` are given, we attempt to connect to the existing
     * session.
     * The promise is fulfilled when the session is ready on the server,
     * otherwise the promise is rejected.
     *
     * If the session was not already started and no `options` are given,
     * the promise is rejected.
     */
    function connectTo(name, options) {
        if (options === void 0) { options = {}; }
        if (!terminal_1.TerminalSession.isAvailable()) {
            return Private.unavailable();
        }
        var baseUrl = options.baseUrl || utils.getBaseUrl();
        var url = Private.getTermUrl(baseUrl, name);
        if (url in Private.running) {
            return Promise.resolve(Private.running[url]);
        }
        var session = new DefaultTerminalSession(name, options);
        return Promise.resolve(session);
    }
    DefaultTerminalSession.connectTo = connectTo;
    /**
     * List the running terminal sessions.
     *
     * @param options - The session options to use.
     *
     * @returns A promise that resolves with the list of running session models.
     */
    function listRunning(options) {
        if (options === void 0) { options = {}; }
        if (!terminal_1.TerminalSession.isAvailable()) {
            return Private.unavailable();
        }
        var url = Private.getBaseUrl(options.baseUrl);
        var ajaxSettings = utils.ajaxSettingsWithToken(options.ajaxSettings, options.token);
        ajaxSettings.method = 'GET';
        ajaxSettings.dataType = 'json';
        return utils.ajaxRequest(url, ajaxSettings).then(function (success) {
            if (success.xhr.status !== 200) {
                return utils.makeAjaxError(success);
            }
            var data = success.data;
            if (!Array.isArray(data)) {
                return utils.makeAjaxError(success, 'Invalid terminal data');
            }
            // Update the local data store.
            var urls = iteration_1.toArray(iteration_1.map(data, function (item) {
                return utils.urlPathJoin(url, item.name);
            }));
            iteration_1.each(Object.keys(Private.running), function (runningUrl) {
                if (urls.indexOf(runningUrl) === -1) {
                    var session = Private.running[runningUrl];
                    session.terminated.emit(void 0);
                    session.dispose();
                }
            });
            return data;
        });
    }
    DefaultTerminalSession.listRunning = listRunning;
    /**
     * Shut down a terminal session by name.
     *
     * @param name - The name of the target session.
     *
     * @param options - The session options to use.
     *
     * @returns A promise that resolves when the session is shut down.
     */
    function shutdown(name, options) {
        if (options === void 0) { options = {}; }
        if (!terminal_1.TerminalSession.isAvailable()) {
            return Private.unavailable();
        }
        var url = Private.getTermUrl(options.baseUrl, name);
        var ajaxSettings = utils.ajaxSettingsWithToken(options.ajaxSettings, options.token);
        ajaxSettings.method = 'DELETE';
        return utils.ajaxRequest(url, ajaxSettings).then(function (success) {
            if (success.xhr.status !== 204) {
                return utils.makeAjaxError(success);
            }
            Private.killTerminal(url);
        }, function (err) {
            if (err.xhr.status === 404) {
                var response = JSON.parse(err.xhr.responseText);
                console.warn(response['message']);
                Private.killTerminal(url);
                return;
            }
            return Promise.reject(err);
        });
    }
    DefaultTerminalSession.shutdown = shutdown;
})(DefaultTerminalSession = exports.DefaultTerminalSession || (exports.DefaultTerminalSession = {}));
// Define the signals for the `DefaultTerminalSession` class.
signaling_1.defineSignal(DefaultTerminalSession.prototype, 'terminated');
signaling_1.defineSignal(DefaultTerminalSession.prototype, 'messageReceived');
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * A mapping of running terminals by url.
     */
    Private.running = Object.create(null);
    /**
     * A promise returned for when terminals are unavailable.
     */
    function unavailable() {
        return Promise.reject('Terminals Unavailable');
    }
    Private.unavailable = unavailable;
    /**
     * Get the url for a terminal.
     */
    function getTermUrl(baseUrl, name) {
        return utils.urlPathJoin(baseUrl, TERMINAL_SERVICE_URL, name);
    }
    Private.getTermUrl = getTermUrl;
    /**
     * Get the base url.
     */
    function getBaseUrl(baseUrl) {
        return utils.urlPathJoin(baseUrl, TERMINAL_SERVICE_URL);
    }
    Private.getBaseUrl = getBaseUrl;
    /**
     * Kill a terminal by url.
     */
    function killTerminal(url) {
        // Update the local data store.
        if (Private.running[url]) {
            var session = Private.running[url];
            session.terminated.emit(void 0);
            session.dispose();
        }
    }
    Private.killTerminal = killTerminal;
})(Private || (Private = {}));
